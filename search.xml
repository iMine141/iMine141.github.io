<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pulsar 与其他中间件的对比</title>
      <link href="/2023/03/06/pulsar/pulsar%E4%B8%8E%E5%85%B6%E4%BB%96%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94/"/>
      <url>/2023/03/06/pulsar/pulsar%E4%B8%8E%E5%85%B6%E4%BB%96%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>随着业务的快速变化，应用程序通信和集成变得更加重要。一个坚固的、成熟的、紧密耦合的通信基础设施成为了数字企业真正的基础，它让企业可以快速地应对变化。近年来，最有前景的数字通信方法来自开源社区，开发人员在这里合作，为构建数字世界的共同挑战提供解决方案。这些解决方案有 Kafka，RabbitMQ等。因为满足不断变化的业务需求需要仔细考虑，所以在本白皮书中，我们定义了几个开源或商业选项，并列出了它们的优点、缺点以及相关复杂性和成本信息。</p><h3 id="二、messaging-简介"><a href="#二、messaging-简介" class="headerlink" title="二、messaging 简介"></a>二、messaging 简介</h3><p>当计算机开始通讯时，messaging 就成为了系统之间通讯的基础。最开始的消息传递是在阿帕网，它是第一个广域分组交换网络，使用以太网、TCP/IP等网络层协议，来进行系统间的通讯。随着阿帕网的发展，更多的系统相互连接，成为今天的互联网，通信原则开始从网络层进入到应用层。随着这些进步，抽象层出现了，简化了系统连接和通信的方式，这也成为消息传递技术的目标。</p><p>多年来，为不同类型的通信发明了新的通信协议。Java消息服务（JMS）和数据分发服务（DDS）规范协议在90年代末和21世纪初出现。许多应用程序开始使用像HTML和HTTP这样的协议，而不是最初设计的协议。每个人都在寻找一个协议，它可以适用于任何东西，但现实是，永远不会有一个单一的通信方法。数字通信将始终是多种方法和模式的混合体。</p><h3 id="三、各个MQ简介"><a href="#三、各个MQ简介" class="headerlink" title="三、各个MQ简介"></a>三、各个MQ简介</h3><h4 id="1-RabbitMQ"><a href="#1-RabbitMQ" class="headerlink" title="1. RabbitMQ"></a>1. RabbitMQ</h4><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求在其次。RabbitMQ的可靠性是非常好的，数据能够保证百分之百的不丢失。可以使用镜像队列，它的稳定性非常好。在性能不如 Kafka，但也可以做一些性能上的优化。</p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><h6 id="1-所需的技能"><a href="#1-所需的技能" class="headerlink" title="1. 所需的技能"></a>1. 所需的技能</h6><p>了解AMQP协议和规范。</p><h6 id="2-复杂性"><a href="#2-复杂性" class="headerlink" title="2. 复杂性"></a>2. 复杂性</h6><p>API 和协议级别的通用数据交换方法意味着数据分发的选项呈指数级增长。</p><h6 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h6><ul><li>基于AMQP协议，操作行为的定义非常明确</li><li>简易灵活的部署方式</li><li>在低吞吐量的情况下，有着非常低延迟</li><li>文档丰富和社区活跃</li></ul><h6 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h6><ul><li>吞吐量限制，单机峰值约万/s</li><li>维护复杂，在弹性伸缩、高可用性、数据复制等不如 pulsar、kafka</li><li>缺乏本地流处理、消息回溯、消息压缩等</li></ul><h6 id="5-总成本"><a href="#5-总成本" class="headerlink" title="5.总成本"></a>5.总成本</h6><p>RabbitMQ 易于部署和维护。但是由于是Erlang开发的，功能扩展和二次开发代价高。</p><h6 id="6-性能"><a href="#6-性能" class="headerlink" title="6.  性能"></a>6.  性能</h6><ul><li>并发一般，万级别 TPS</li><li>延迟低，微秒级别</li><li>可扩展性一般</li><li>支持分布式，RabbitMQ 是为大规模部署而设计的，但通常需要大规模的服务器基础架构来支持可扩展的环境，以及复杂的路由来支持全球分布式结构</li></ul><h4 id="2-RocketMQ"><a href="#2-RocketMQ" class="headerlink" title="2.RocketMQ"></a>2.RocketMQ</h4><p>RocketMQ 是由阿里巴巴消息中间件团队研发的一款高性能、高吞吐量、低延迟、高可用、高可靠的分布式消息中间件，参考了优秀的开源消息中间件Kafka，天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商领域中，以及业务削峰。开源后并于2016年捐赠给Apache社区孵化，目前已经成为了Apache顶级项目。</p><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><h6 id="1-所需的技能-1"><a href="#1-所需的技能-1" class="headerlink" title="1. 所需的技能"></a>1. 所需的技能</h6><p>需要对消息传递，消息事物，消息重试机制等原理有基本理解。</p><h6 id="2-复杂性-1"><a href="#2-复杂性-1" class="headerlink" title="2. 复杂性"></a>2. 复杂性</h6><p>相对于 kafka，不需要部署额外的 Zookeeper，内置了 nameserver ，部署简单。</p><h6 id="3-优点-1"><a href="#3-优点-1" class="headerlink" title="3. 优点"></a>3. 优点</h6><ul><li>满足多种需求，支持有序消息、延迟消息、消息回溯、消息积压等等</li><li>保证高可用，能够大规模集群化部署</li><li>java 开发，阅读源代码、扩展、二次开发方便</li></ul><h6 id="4-缺点-1"><a href="#4-缺点-1" class="headerlink" title="4. 缺点"></a>4. 缺点</h6><ul><li>消息重复问题，它不能保证不重复</li><li>延迟消息，只支持固定 level</li><li>社区活跃度和文档都相较一般</li></ul><h6 id="5-总成本-1"><a href="#5-总成本-1" class="headerlink" title="5. 总成本"></a>5. 总成本</h6><p>RocketMQ 易于部署和维护，但与任何开源解决方案一样，随着基础设施的扩展，支持和维护它的成本也会增加。</p><h6 id="6-性能-1"><a href="#6-性能-1" class="headerlink" title="6.  性能"></a>6.  性能</h6><ul><li>并发高，十万级别 TPS</li><li>延迟低，毫秒级别</li><li>可扩展性强，集群可以同时进行水平方向和垂直方向的缩放</li><li>支持分布式，原生支持高可用集群，分布式扩展设计</li></ul><h4 id="3-Kafka"><a href="#3-Kafka" class="headerlink" title="3.Kafka"></a>3.Kafka</h4><p>Kafka 是一个分布式、分区的、多副本的，基于 zookeeper 协调的分布式日志系统（也可以当做 MQ 系统），常见可以用于 web/nginx 日志、访问日志，消息服务等。由 Linkedin 公司开发，于2010年贡献给了 Apache 基金会并成为顶级开源项目。</p><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h5><h6 id="1-所需的技能-2"><a href="#1-所需的技能-2" class="headerlink" title="1. 所需的技能"></a>1. 所需的技能</h6><p>了解消息传递和底层操作系统功能，如存储和网络通信。需要学习其他组件，如Zookeeper等。</p><h6 id="2-复杂性-2"><a href="#2-复杂性-2" class="headerlink" title="2. 复杂性"></a>2. 复杂性</h6><p>相对容易开箱即用。当需要诸如安全性、复制和全局分发等功能时，复杂性就会增加。</p><h6 id="3-优点-2"><a href="#3-优点-2" class="headerlink" title="3. 优点"></a>3. 优点</h6><ul><li>性能强大，拥有百万级的吞吐量</li><li>支持数据持久、分布式流处理、跨域复制等功能</li><li>与周边系统的兼容性好，尤其是大数据和流计算领域，几乎所有相关的开源软件都支持Kafka</li><li>文档丰富和社区活跃</li></ul><h6 id="4-缺点-2"><a href="#4-缺点-2" class="headerlink" title="4. 缺点"></a>4. 缺点</h6><ul><li>没有与租户完全隔离的本地多租户</li><li>长期存储数据昂贵，尽管可以长时间存储，但是由于成本问题却很少用到它</li><li>运维困难，必须提前计划和计算 broker、topic、分区和副本的数量（确保计划的未来使用量增长），以避免扩展问题</li><li>在大量 topic 下，吞吐量会大幅下降</li></ul><h6 id="5-总成本-2"><a href="#5-总成本-2" class="headerlink" title="5. 总成本"></a>5. 总成本</h6><p>Kafka 很简单，相对容易启动和运行，特别是对于中小型项目。开源并不意味着免费，Kafka 不断达到企业规模需要专门的支持人员来维护基础设施。</p><h6 id="6-性能-2"><a href="#6-性能-2" class="headerlink" title="6.  性能"></a>6.  性能</h6><ul><li>并发高，百万级别 TPS</li><li>延迟低，毫秒级别</li><li>可扩展性好，集群可以同时进行水平方向和垂直方向的缩放</li><li>支持分布式</li></ul><h4 id="4-ADMQ"><a href="#4-ADMQ" class="headerlink" title="4.ADMQ"></a>4.ADMQ</h4><p>ADMQ 是基于Apache Pulsar 的二次开发消息中间件，是下一代云原生分布式消息流平台。在许多方面，Pulsar 与 Kafka 相似，但在规划部署方面差别很大。Pulsar 最初只是传统的消息传递系统，后面加入了流处理的功能。这对于那些希望部署大规模系统同时要求更少的复杂性的用户来说是非常有吸引力的。Pulsar 企业级的分布式对于多租户和数据复制的功能提供了一个开箱即用的支持，从而简化了随着时间的推移不断增长的资源使用和采用。</p><h5 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h5><h6 id="1-所需的技能-3"><a href="#1-所需的技能-3" class="headerlink" title="1. 所需的技能"></a>1. 所需的技能</h6><p>对消息传递和底层操作系统功能的基本理解，如存储和网络通信。需要学习其他组件，如Zookeeper，Bookkeeper等。</p><h6 id="2-复杂性-3"><a href="#2-复杂性-3" class="headerlink" title="2. 复杂性"></a>2. 复杂性</h6><p>一种简化的封装方法，其中所有功能都可以集中访问，从而降低了扩展到企业级别时的复杂性。</p><h6 id="3-优点-3"><a href="#3-优点-3" class="headerlink" title="3. 优点"></a>3. 优点</h6><ul><li>性能强大，比 kafka 更稳定的低延迟、高吞吐量</li><li>存储与计算分离，无需移动数据即可添加或使用 broker，运维方便</li><li>分层存储，历史数据可以使用其他廉价的存储</li><li>地理复制和内置 Discovery，易于将集群复制到多个区域</li><li>多租户，不同的团队可以使用相同的集群并将其隔离，解决了许多管理难题</li><li>Function，易于部署、轻量级计算过程、对开发人员友好的 API，无需运行自己的流处理引擎</li><li>多协议支持，支持 RocketMQ、AMQP、Kafka 协议等，容易与实现这些协议的中间件进行集成</li><li>社区相对活跃，能够及时反馈。</li></ul><h6 id="4-缺点-3"><a href="#4-缺点-3" class="headerlink" title="4. 缺点"></a>4. 缺点</h6><ul><li>部署比较复杂，除了 Pulsar 还有另外有Zookeeper、Bookkeeper两个组件</li><li>相对缺乏支持、文档和案例</li><li>插件和客户端相对 Kafka 较少</li></ul><h6 id="5-总成本-3"><a href="#5-总成本-3" class="headerlink" title="5. 总成本"></a>5. 总成本</h6><p>Pulsar 需要花费更多的精力来启动和运行，但一旦部署，它就可以很好地扩展到企业级别。开源并不意味着免费的，企业运行 Pulsar 通常需要专门的支持人员来维护基础设施。使用ADMQ商业版，金蝶天燕可以提供完美支持和维护。</p><h6 id="6-性能-3"><a href="#6-性能-3" class="headerlink" title="6.  性能"></a>6.  性能</h6><p>并发高，百万级别 TPS</p><p>延迟低，毫秒级别</p><p>可扩展性强，集群可以同时进行水平方向和垂直方向的缩放</p><p>支持分布式，内置了分布式和数据复制的本地支持</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>如今，在选择消息传递通信产品时，企业比其他任何时候都面临着困难的挑战。虽然单个解决方案的总体拥有成本较低，但没有一个解决方案能够满足所有应用程序的所有需求。消息传递必须更加全面，以满足特定和不同的应用程序需求—包括高性能/低延迟事件处理、流分析的流数据、不同应用程序之间本地集成的微服务等等。</p><p>如今 ADMQ 将流处理和传统消息队列统一，加上跨地域复制、无状态broker、分层存储、多协议支持，让 ADMQ 成为一个全新的消息中间件。提供给不同企业不同需求的对应解决方案。</p><h4 id="对比概览"><a href="#对比概览" class="headerlink" title="对比概览"></a>对比概览</h4><table><thead><tr><th>对比项</th><th>RabbitMQ（AMQP）</th><th>RocketMQ</th><th>Kafka</th><th>ADMQ</th></tr></thead><tbody><tr><td>成熟度</td><td>成熟</td><td>成熟</td><td>成熟</td><td>一般</td></tr><tr><td>时效性</td><td>微秒级别</td><td>毫秒级别</td><td>毫秒级别</td><td>毫秒级别</td></tr><tr><td>请求TPS</td><td>万级别</td><td>十万级别</td><td>百万级别</td><td>百万级别</td></tr><tr><td>可靠性</td><td>一般</td><td>高</td><td>一般</td><td>高</td></tr><tr><td>可用性</td><td>高（主从构架）</td><td>高（主从构架）</td><td>非常高（分布式）</td><td>非常高（分布式）</td></tr><tr><td>定时消息</td><td>支持</td><td>支持（固定level）</td><td>不支持</td><td>支持</td></tr><tr><td>事物</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>副本同步策略</td><td>Master-Slave同步</td><td>Master-Slave同步</td><td>多机异步</td><td>多机异步</td></tr><tr><td>多租户</td><td>支持部分</td><td>支持部分</td><td>支持部分</td><td>支持</td></tr><tr><td>动态扩容</td><td>集群扩容依赖前端</td><td>需同步配置</td><td>需手动执行rebalance</td><td>友好，及时扩容</td></tr><tr><td>故障恢复</td><td>不友好</td><td>不友好</td><td>较友好</td><td>友好</td></tr><tr><td>消息堆积能力</td><td>影响性能</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>消息回溯</td><td>不支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>顺序消息</td><td>不支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>安全防护</td><td>一般</td><td>一般</td><td>一般</td><td>高</td></tr><tr><td>社区活跃度</td><td>高</td><td>中</td><td>高</td><td>高</td></tr><tr><td>文档</td><td>多</td><td>中</td><td>多</td><td>一般</td></tr><tr><td>特点</td><td>erlang语言发开，性能一般，出现比较早，有一定的用户基数</td><td>各个环节分布式扩展设计，主从HA,多种消费模式，性能好</td><td>高吞吐量、持久化数据存储、分布式系统易于扩展，性能极好</td><td>灵活、多租户、云原生架构、跨地域复制，性能极好</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongAdder</title>
      <link href="/2022/10/29/Java%E5%9F%BA%E7%A1%80/java%E6%BA%90%E7%A0%81/LongAdder/"/>
      <url>/2022/10/29/Java%E5%9F%BA%E7%A1%80/java%E6%BA%90%E7%A0%81/LongAdder/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要使用Longadder"><a href="#为什么要使用Longadder" class="headerlink" title="为什么要使用Longadder?"></a>为什么要使用Longadder?</h3><p>传统的原子操作类 <strong>AtomicLong</strong> 。他的原子性是通过 CAS 原理来实现的，但是有一个问题，如果并发大了，所有请求线程只有一个线程会成功，其他的线程都需要自旋等待。而自旋等待的cpu消耗是很大的。所以在并发量大的情况下，Atomiclong的性能是比较低的</p><p><strong>LongAdder</strong> 的原理就是，加入了分段的概念，每个线程都有属于自己的桶位，线程针对自己桶位的值 做cas计算。</p><h5 id="LongAdder流程"><a href="#LongAdder流程" class="headerlink" title="LongAdder流程"></a>LongAdder流程</h5><p>base变量：非竞争条件下，直接累加到该值上</p><p>cell[]数组：竞争条件下，累加到各自线程的槽中cell[i]</p><p>竞争条件下调用get方法获取LongAdder的值，才会去统计所有cell数组中的值</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jstack分析线程运行状态</title>
      <link href="/2022/08/07/pulsar/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/jstack%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/"/>
      <url>/2022/08/07/pulsar/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/jstack%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h5 id="1-通过ps-ef-grep-program-Name-找到程序进程ID"><a href="#1-通过ps-ef-grep-program-Name-找到程序进程ID" class="headerlink" title="1.通过ps -ef|grep {\program*Name} 找到程序进程ID*"></a><strong>1.通过ps -ef|grep {\</strong>program*<em>Name} 找到程序进程ID*</em></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@10 keep_rule_sender]# ps -ef|grep java</span><br><span class="line">root      4896 18614  0 15:52 pts&#x2F;0    00:00:00 grep --color&#x3D;auto java</span><br><span class="line">root     15550 15547  0 5月25 ?       00:24:08 .&#x2F;jre&#x2F;bin&#x2F;java -jar -Dfile.encoding&#x3D;UTF-8 -XX:+UseG1GC -Xms16384M -Xmx16384M -Xmn8192M -Xss2M AuthCenter.jar</span><br></pre></td></tr></table></figure><p><strong>2.top -Hp pid 查看该进程对应的各个线程的运行状态</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@10 keep_rule_sender]# top Hp 15550</span><br><span class="line">top - 15:55:19 up 115 days, 54 min,  1 user,  load average: 0.31, 0.36, 0.40</span><br><span class="line">Threads: 146 total,   0 running, 146 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.2 us,  0.7 sy,  0.0 ni, 96.1 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st</span><br><span class="line">KiB Mem : 13157919+total, 62099732 free, 26188756 used, 43290704 buff&#x2F;cache</span><br><span class="line">KiB Swap:  4194300 total,  4194300 free,        0 used. 10426378+avail Mem</span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                                                      </span><br><span class="line">15937 root      20   0 27.453g 9.252g  13756 S  0.3  7.4   0:16.47 java                                                                                                                                         </span><br><span class="line">15947 root      20   0 27.453g 9.252g  13756 S  0.3  7.4   0:16.73 java</span><br></pre></td></tr></table></figure><p><strong>3.jstack pid &gt; stack.txt 保存该程序各个线程当前的执行状态到本地文件stack.txt中</strong></p><p><strong>4.查看对应线程的状态</strong></p><p>把top看到的线程号（pid）转换成16进制</p><p>在stack.txt文件中查看对应线程的执行状态</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;nioEventLoopGroup-3-52&quot; #78 prio&#x3D;10 os_prio&#x3D;0 tid&#x3D;0x00007fe8b012c000 nid&#x3D;0x3e41 runnable [0x00007fe7eb7fa000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">  at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">  at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">  at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:79)</span><br><span class="line">  at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">  - locked &lt;0x00000003c0056660&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">  - locked &lt;0x00000003c0056608&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">  - locked &lt;0x00000003c0056618&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">  at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">  at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:639)</span><br><span class="line">  at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:325)</span><br><span class="line">  at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)</span><br><span class="line">  at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code_method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pulsar订阅进度同步原理</title>
      <link href="/2021/10/15/pulsar/Pulsar%E8%AE%A2%E9%98%85%E8%BF%9B%E5%BA%A6%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2021/10/15/pulsar/Pulsar%E8%AE%A2%E9%98%85%E8%BF%9B%E5%BA%A6%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>Pulsar自带的跨集群数据复制，可以把一个集群收到的消息复制到其他集群上，这样消费者正在连接的集群挂掉后，可以从其他集群消费消息。</p><p>除了消息的复制，pulsar还支持订阅进度的同步，具体场景如下：</p><p>部署了三个集群A、B、C，并设置集群之间的消息两两复制。消费者A刚开始从集群A消费消息，当集群A挂掉后，消费者A切换到集群B消费消息，这时候消费者A不需要从头开始读取集群B上的消息，而是可以从上一次在集群A上消费失败的位置继续从集群B上消费消息。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>集群间的消息复制是通过内置生产者和消费者实现的，接收消息的集群上会启动一个消息读取进程，读取发送到该集群的消息，然后通过客户端接口发送到其他集群上。</p><p>也就是说消息的复制并不是直接把bookie中的存储文件复制到其他集群上，而是使用内置的订阅名称读取本地消息，然后发送到其他集群。这样的话，两个集群的消息元数据就不是一样的，同一条消息在多个集群的消息ID是不一样的。</p><p>所以如果想实现订阅进度的同步，需要把同一条消息在多个集群的消息ID关联上，然后在各个集群间同步上次消费完毕的消息ID，这样不同集群之间就都知道消费者上次消费确认的位置并能够移动本集群的消费位点了。</p><p>所以实现订阅进度同步的关键点在于</p><ul><li><p>集群间能相互通信</p></li><li><p>同一条消息在多集群间的关联关系</p></li><li><p>消费进度更新时能及时通知到其他集群</p></li></ul><h1 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h1><p>Pulsar本身的消息同步并不是实时的、严格的同步，只是避免大范围的重复消费，还是会有一小段消息的重复。</p><p>Pulsar订阅进度同步的流程</p><ul><li><p>发布快照通知给其他集群。</p></li><li><p>其他集群收到通知后，记录本集群的LAC指针并发送给开启同步流程的集群。</p></li><li><p>开启流程的集群收到其他所有集群的返回消息后，分别建立其他集群LAC和本集群上一次消息ID的关联关系。</p></li><li><p>开启流程的集群建立好消息的ID的关联关系后，生成一个快照消息，并插入到消息队列中。</p></li><li><p>消费者返回确认后，会根据消息ID检测上一个快照，找到后就说明消费位置已经超过快照了，需要通知其他消费者更新消费位置了。</p></li><li><p>其他集群收到位置更新通知后更新本集群的消费位置。</p></li></ul><p>下面以某个场景详细说明下。</p><p>场景描述：</p><p>集群A、B、C三个集群互相同步消息，生产者都发送消息到集群A上。</p><h2 id="集群A发布一个快照通知"><a href="#集群A发布一个快照通知" class="headerlink" title="集群A发布一个快照通知"></a>集群A发布一个快照通知</h2><p>创建Topic时会检测是否需要同步订阅进度，如果需要则通过ReplicatedSubscriptionsController启动一个定时任务，任务的功能就是发送一个通知，代码如下：</p><p><strong>ReplicatedSubscriptionsController</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startNewSnapshot() &#123;</span><br><span class="line">  cleanupTimedOutSnapshots();</span><br><span class="line">  &#x2F;&#x2F; 判断是否有新消息写入了</span><br><span class="line">  if (topic.getLastDataMessagePublishedTimestamp() &lt; lastCompletedSnapshotStartTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; There was no message written since the last snapshot, we can skip creating a new snapshot</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(&quot;[&#123;&#125;] There is no new data in topic. Skipping snapshot creation.&quot;, topic.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MutableBoolean anyReplicatorDisconnected &#x3D; new MutableBoolean();</span><br><span class="line">  topic.getReplicators().forEach((cluster, replicator) -&gt; &#123;</span><br><span class="line">    if (!replicator.isConnected()) &#123;</span><br><span class="line">      anyReplicatorDisconnected.setTrue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当所有集群都正常时才会发送通知。</span><br><span class="line">  if (anyReplicatorDisconnected.isTrue()) &#123;</span><br><span class="line">    &#x2F;&#x2F; Do not attempt to create snapshot when some of the clusters are not reachable</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(&quot;[&#123;&#125;] Do not attempt to create snapshot when some of the clusters are not reachable.&quot;,</span><br><span class="line">          topic.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Starting snapshot creation.&quot;, topic.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pendingSnapshotsMetric.inc();</span><br><span class="line">  ReplicatedSubscriptionsSnapshotBuilder builder &#x3D; new ReplicatedSubscriptionsSnapshotBuilder(this,</span><br><span class="line">      topic.getReplicators().keys(), topic.getBrokerService().pulsar().getConfiguration(), Clock.systemUTC());</span><br><span class="line">  pendingSnapshots.put(builder.getSnapshotId(), builder);</span><br><span class="line">    &#x2F;&#x2F; 这里只是通过往该Topic写入一条消息，消息中包含通知ID。</span><br><span class="line">  builder.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReplicatedSubscriptionsSnapshotBuilder</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void start() &#123;</span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Starting new snapshot &#123;&#125; - Clusters: &#123;&#125;&quot;, controller.topic().getName(), snapshotId,</span><br><span class="line">        missingClusters);</span><br><span class="line">  &#125;</span><br><span class="line">  startTimeMillis &#x3D; clock.millis();</span><br><span class="line">    &#x2F;&#x2F; 设置通知ID（快照ID）和本集群名称。</span><br><span class="line">  controller.writeMarker(</span><br><span class="line">      Markers.newReplicatedSubscriptionsSnapshotRequest(snapshotId, controller.localCluster()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集群B和C收到通知"><a href="#集群B和C收到通知" class="headerlink" title="集群B和C收到通知"></a>集群B和C收到通知</h2><p>集群A写入消息到该Topic后，该条消息会和其他消息一样发送到集群B和集群C上。</p><p>由于集群间是相互复制消息，所以集群B和C的复制模块能够读取到该消息，并作相应的处理。</p><p><strong>PersistentReplicator</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void checkReplicatedSubscriptionMarker(Position position, MessageImpl&lt;?&gt; msg, ByteBuf payload) &#123;</span><br><span class="line">  if (!msg.getMessageBuilder().hasMarkerType()) &#123;</span><br><span class="line">    &#x2F;&#x2F; No marker is defined</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int markerType &#x3D; msg.getMessageBuilder().getMarkerType();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里确保只处理消息发送方集群发送的消息，即只处理集群A发送的消息。</span><br><span class="line">  if (!(msg.getMessageBuilder().hasReplicatedFrom()</span><br><span class="line">      &amp;&amp; remoteCluster.equals(msg.getMessageBuilder().getReplicatedFrom()))) &#123;</span><br><span class="line">    &#x2F;&#x2F; Only consider markers that are coming from the same cluster that this</span><br><span class="line">    &#x2F;&#x2F; replicator instance is assigned to.</span><br><span class="line">    &#x2F;&#x2F; All the replicators will see all the markers, but we need to only process</span><br><span class="line">    &#x2F;&#x2F; it once.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 需要处理的消息包含三类：通知、通知应答、消费位置更新。</span><br><span class="line">  switch (markerType) &#123;</span><br><span class="line">  case MarkerType.REPLICATED_SUBSCRIPTION_SNAPSHOT_REQUEST_VALUE:</span><br><span class="line">  case MarkerType.REPLICATED_SUBSCRIPTION_SNAPSHOT_RESPONSE_VALUE:</span><br><span class="line">  case MarkerType.REPLICATED_SUBSCRIPTION_UPDATE_VALUE:</span><br><span class="line">    topic.receivedReplicatedSubscriptionMarker(position, markerType, payload);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  default:</span><br><span class="line">    &#x2F;&#x2F; Do nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到通知后，会获取LAC，然后封装LAC，写入到该Topic中。</p><p><strong>ReplicatedSubscriptionsController</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void receivedSnapshotRequest(ReplicatedSubscriptionsSnapshotRequest request) &#123;</span><br><span class="line">  &#x2F;&#x2F; if replicator producer is already closed, restart it to send snapshot response</span><br><span class="line">  Replicator replicator &#x3D; topic.getReplicators().get(request.getSourceCluster());</span><br><span class="line">  if (!replicator.isConnected()) &#123;</span><br><span class="line">    topic.startReplProducers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Send response containing the current last written message id. The response</span><br><span class="line">  &#x2F;&#x2F; marker we&#39;re publishing locally and then replicating will have a higher</span><br><span class="line">  &#x2F;&#x2F; message id.</span><br><span class="line">    &#x2F;&#x2F; 得到集群上次写入的消息</span><br><span class="line">  PositionImpl lastMsgId &#x3D; (PositionImpl) topic.getLastPosition();</span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Received snapshot request. Last msg id: &#123;&#125;&quot;, topic.getName(), lastMsgId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 把消息ID连同通知ID一起写入到Topic中。</span><br><span class="line">  ByteBuf marker &#x3D; Markers.newReplicatedSubscriptionsSnapshotResponse(</span><br><span class="line">      request.getSnapshotId(),</span><br><span class="line">      request.getSourceCluster(),</span><br><span class="line">      localCluster,</span><br><span class="line">      lastMsgId.getLedgerId(), lastMsgId.getEntryId());</span><br><span class="line">  writeMarker(marker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集群A建立本集群和集群B、C间消费ID的关联关系"><a href="#集群A建立本集群和集群B、C间消费ID的关联关系" class="headerlink" title="集群A建立本集群和集群B、C间消费ID的关联关系"></a>集群A建立本集群和集群B、C间消费ID的关联关系</h2><p>集群B和C写入的消息会被集群B和C的复制模块发送到集群A，集群A的复制模块会读到该消息并做相应的处理。</p><p><strong>ReplicatedSubscriptionsController</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void receivedSnapshotResponse(Position position, ReplicatedSubscriptionsSnapshotResponse response) &#123;</span><br><span class="line">  String snapshotId &#x3D; response.getSnapshotId();</span><br><span class="line">  ReplicatedSubscriptionsSnapshotBuilder builder &#x3D; pendingSnapshots.get(snapshotId);</span><br><span class="line">  if (builder &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(&quot;[&#123;&#125;] Received late reply for timed-out snapshot &#123;&#125; from &#123;&#125;&quot;, topic.getName(), snapshotId,</span><br><span class="line">          response.getCluster().getCluster());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  builder.receivedSnapshotResponse(position, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReplicatedSubscriptionsSnapshotBuilder</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该Position是集群A和B返回的消息在集群A上的Position。</span><br><span class="line">synchronized void receivedSnapshotResponse(Position position, ReplicatedSubscriptionsSnapshotResponse response) &#123;</span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Received response from &#123;&#125;&quot;, controller.topic().getName(),</span><br><span class="line">        response.getCluster().getCluster());</span><br><span class="line">  &#125;</span><br><span class="line">  String cluster &#x3D; response.getCluster().getCluster();</span><br><span class="line">    &#x2F;&#x2F; Response中包含集群A&#x2F;集群B中的LAC消息。</span><br><span class="line">  responses.putIfAbsent(cluster, new MarkersMessageIdData().copyFrom(response.getCluster().getMessageId()));</span><br><span class="line">  missingClusters.remove(cluster);</span><br><span class="line"></span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Missing clusters &#123;&#125;&quot;, controller.topic().getName(), missingClusters);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!missingClusters.isEmpty()) &#123;</span><br><span class="line">    &#x2F;&#x2F; We&#39;re still waiting for more responses to come back</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; We have now received all responses</span><br><span class="line">  &#x2F;&#x2F; 如果超过两个集群需要两次通知，这里没看懂为啥...</span><br><span class="line">  if (needTwoRounds &amp;&amp; !firstRoundComplete) &#123;</span><br><span class="line">    &#x2F;&#x2F; Mark that 1st round is done and start a 2nd round</span><br><span class="line">    firstRoundComplete &#x3D; true;</span><br><span class="line">    missingClusters.addAll(remoteClusters);</span><br><span class="line"></span><br><span class="line">    controller.writeMarker(</span><br><span class="line">        Markers.newReplicatedSubscriptionsSnapshotRequest(snapshotId, controller.localCluster()));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Snapshot is complete &#123;&#125;&quot;, controller.topic().getName(), snapshotId);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Snapshot is now complete, store it in the local topic</span><br><span class="line">    &#x2F;&#x2F; 这里是建立记录集群B&#x2F;集群C的LAC消息和集群A收到集群B&#x2F;集群C是保存LAC的消息的消息ID间的关联关系，而且是最后边一个消息。</span><br><span class="line">    &#x2F;&#x2F; 所以这里不能实现同一条消息在三个集群间的关联。</span><br><span class="line">  PositionImpl p &#x3D; (PositionImpl) position;</span><br><span class="line">  controller.writeMarker(</span><br><span class="line">      Markers.newReplicatedSubscriptionsSnapshot(snapshotId, controller.localCluster(),</span><br><span class="line">          p.getLedgerId(), p.getEntryId(), responses));</span><br><span class="line">  controller.snapshotCompleted(snapshotId);</span><br><span class="line"></span><br><span class="line">  double latencyMillis &#x3D; clock.millis() - startTimeMillis;</span><br><span class="line">  snapshotMetric.observe(latencyMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群A建立好关联关系后，会生成一个快照，这个快照包含各集群消息ID的关联关系、</p><p>然后写入到该Topic中，之后这条消息就会复制到集群B和集群C上。</p><h2 id="创建快照缓存"><a href="#创建快照缓存" class="headerlink" title="创建快照缓存"></a>创建快照缓存</h2><p>虽然上边的步骤已经生成快照了，但是快照的缓存并不上在上边添加的。当快照被写到Topic中，那么当消费者读取消息时就肯定能读到该快照。</p><p>当消息在Broker端被读到时，通过过滤器处理这些消息。</p><p><strong>AbstractBaseDispatcher</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int filterEntriesForConsumer(Optional&lt;EntryWrapper[]&gt; entryWrapper, int entryWrapperOffset,</span><br><span class="line">     List&lt;Entry&gt; entries, EntryBatchSizes batchSizes, SendMessageInfo sendMessageInfo,</span><br><span class="line">     EntryBatchIndexesAcks indexesAcks, ManagedCursor cursor, boolean isReplayRead) &#123;</span><br><span class="line">  int totalMessages &#x3D; 0;</span><br><span class="line">  long totalBytes &#x3D; 0;</span><br><span class="line">  int totalChunkedMessages &#x3D; 0;</span><br><span class="line">  int totalEntries &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0, entriesSize &#x3D; entries.size(); i &lt; entriesSize; i++) &#123;</span><br><span class="line">    Entry entry &#x3D; entries.get(i);</span><br><span class="line">    if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    totalEntries++;</span><br><span class="line">    ByteBuf metadataAndPayload &#x3D; entry.getDataBuffer();</span><br><span class="line">    int entryWrapperIndex &#x3D; i + entryWrapperOffset;</span><br><span class="line">    MessageMetadata msgMetadata &#x3D; entryWrapper.isPresent() &amp;&amp; entryWrapper.get()[entryWrapperIndex] !&#x3D; null</span><br><span class="line">        ? entryWrapper.get()[entryWrapperIndex].getMetadata()</span><br><span class="line">        : null;</span><br><span class="line">    msgMetadata &#x3D; msgMetadata &#x3D;&#x3D; null</span><br><span class="line">        ? Commands.peekMessageMetadata(metadataAndPayload, subscription.toString(), -1)</span><br><span class="line">        : msgMetadata;</span><br><span class="line">    if (!isReplayRead &amp;&amp; msgMetadata !&#x3D; null &amp;&amp; msgMetadata.hasTxnidMostBits()</span><br><span class="line">        &amp;&amp; msgMetadata.hasTxnidLeastBits()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 省略代码 ...</span><br><span class="line">            </span><br><span class="line">    &#125; else if (msgMetadata &#x3D;&#x3D; null || Markers.isServerOnlyMarker(msgMetadata)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里处理读到的快照消息。</span><br><span class="line">      PositionImpl pos &#x3D; (PositionImpl) entry.getPosition();</span><br><span class="line">      &#x2F;&#x2F; Message metadata was corrupted or the messages was a server-only marker</span><br><span class="line"></span><br><span class="line">      if (Markers.isReplicatedSubscriptionSnapshotMarker(msgMetadata)) &#123;</span><br><span class="line">        processReplicatedSubscriptionSnapshot(pos, metadataAndPayload);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      entries.set(i, null);</span><br><span class="line">      entry.release();</span><br><span class="line">      subscription.acknowledgeMessage(Collections.singletonList(pos), AckType.Individual,</span><br><span class="line">          Collections.emptyMap());</span><br><span class="line">      continue;</span><br><span class="line">    &#125; else if (msgMetadata.hasDeliverAtTime()</span><br><span class="line">        &amp;&amp; trackDelayedDelivery(entry.getLedgerId(), entry.getEntryId(), msgMetadata)) &#123;</span><br><span class="line">      &#x2F;&#x2F; The message is marked for delayed delivery. Ignore for now.</span><br><span class="line">      entries.set(i, null);</span><br><span class="line">      entry.release();</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 省略代码 ...</span><br><span class="line">  &#125;</span><br><span class="line">  sendMessageInfo.setTotalMessages(totalMessages);</span><br><span class="line">  sendMessageInfo.setTotalBytes(totalBytes);</span><br><span class="line">  sendMessageInfo.setTotalChunkedMessages(totalChunkedMessages);</span><br><span class="line">  return totalEntries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void processReplicatedSubscriptionSnapshot(PositionImpl pos, ByteBuf headersAndPayload) &#123;</span><br><span class="line">  &#x2F;&#x2F; Remove the protobuf headers</span><br><span class="line">  Commands.skipMessageMetadata(headersAndPayload);</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    ReplicatedSubscriptionsSnapshot snapshot &#x3D; Markers.parseReplicatedSubscriptionsSnapshot(headersAndPayload);</span><br><span class="line">    subscription.processReplicatedSubscriptionSnapshot(snapshot);</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    log.warn(&quot;Failed to process replicated subscription snapshot at &#123;&#125; -- &#123;&#125;&quot;, pos, t.getMessage(), t);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PersistentSubscription</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void processReplicatedSubscriptionSnapshot(ReplicatedSubscriptionsSnapshot snapshot) &#123;</span><br><span class="line">    ReplicatedSubscriptionSnapshotCache snapshotCache &#x3D; this.replicatedSubscriptionSnapshotCache;</span><br><span class="line">    if (snapshotCache !&#x3D; null) &#123;</span><br><span class="line">        snapshotCache.addNewSnapshot(new ReplicatedSubscriptionsSnapshot().copyFrom(snapshot));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReplicatedSubscriptionSnapshotCache</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void addNewSnapshot(ReplicatedSubscriptionsSnapshot snapshot) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里的本地消息ID，就是保存集群B&#x2F;集群C LAC消息的消息ID，且是最新的一个。</span><br><span class="line">    MarkersMessageIdData msgId &#x3D; snapshot.getLocalMessageId();</span><br><span class="line">    PositionImpl position &#x3D; new PositionImpl(msgId.getLedgerId(), msgId.getEntryId());</span><br><span class="line"></span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(&quot;[&#123;&#125;] Added new replicated-subscription snapshot at &#123;&#125; -- &#123;&#125;&quot;, subscription, position,</span><br><span class="line">                  snapshot.getSnapshotId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    snapshots.put(position, snapshot);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prune the cache</span><br><span class="line">    while (snapshots.size() &gt; maxSnapshotToCache) &#123;</span><br><span class="line">        snapshots.pollFirstEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此快照从存储中被加载到Broker内存中。</p><h2 id="集群A更新进度"><a href="#集群A更新进度" class="headerlink" title="集群A更新进度"></a>集群A更新进度</h2><p>当消费者订阅消息时，快照才会被加载到Broker内存里，然后消费者返回确认消息时，会查找消息ID的上一个快照。</p><p><strong>PersistentSubscription</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void acknowledgeMessage(List&lt;Position&gt; positions, AckType ackType, Map&lt;String, Long&gt; properties) &#123;</span><br><span class="line">  Position previousMarkDeletePosition &#x3D; cursor.getMarkDeletedPosition();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 省略代码 ... </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当可删除位置更新了（注意不能处理单独确认的消息）</span><br><span class="line">  if (!cursor.getMarkDeletedPosition().equals(previousMarkDeletePosition)) &#123;</span><br><span class="line">    this.updateLastMarkDeleteAdvancedTimestamp();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Mark delete position advance</span><br><span class="line">    ReplicatedSubscriptionSnapshotCache snapshotCache  &#x3D; this.replicatedSubscriptionSnapshotCache;</span><br><span class="line">    if (snapshotCache !&#x3D; null) &#123;</span><br><span class="line">      ReplicatedSubscriptionsSnapshot snapshot &#x3D; snapshotCache</span><br><span class="line">          .advancedMarkDeletePosition((PositionImpl) cursor.getMarkDeletedPosition());</span><br><span class="line">      if (snapshot !&#x3D; null) &#123;</span><br><span class="line">        topic.getReplicatedSubscriptionController()</span><br><span class="line">            .ifPresent(c -&gt; c.localSubscriptionUpdated(subName, snapshot));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteTransactionMarker(properties);</span><br><span class="line"></span><br><span class="line">  if (topic.getManagedLedger().isTerminated() &amp;&amp; cursor.getNumberOfEntriesInBacklog(false) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; Notify all consumer that the end of topic was reached</span><br><span class="line">    if (dispatcher !&#x3D; null) &#123;</span><br><span class="line">      dispatcher.getConsumers().forEach(Consumer::reachedEndOfTopic);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能找到快照，则说明需要更新进度了。</p><p>这个进度是上一次的快照进度，不是最新消费的进度。</p><p><strong>ReplicatedSubscriptionsController</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void localSubscriptionUpdated(String subscriptionName, ReplicatedSubscriptionsSnapshot snapshot) &#123;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(&quot;[&#123;&#125;][&#123;&#125;] Updating subscription to snapshot &#123;&#125;&quot;, topic, subscriptionName,</span><br><span class="line">                  snapshot.getClustersList().stream()</span><br><span class="line">                  .map(cmid -&gt; String.format(&quot;%s -&gt; %d:%d&quot;, cmid.getCluster(),</span><br><span class="line">                                             cmid.getMessageId().getLedgerId(), cmid.getMessageId().getEntryId()))</span><br><span class="line">                  .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, MarkersMessageIdData&gt; clusterIds &#x3D; new TreeMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0, size &#x3D; snapshot.getClustersCount(); i &lt; size; i++) &#123;</span><br><span class="line">        ClusterMessageId cmid &#x3D; snapshot.getClusterAt(i);</span><br><span class="line">        clusterIds.put(cmid.getCluster(), cmid.getMessageId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuf subscriptionUpdate &#x3D; Markers.newReplicatedSubscriptionsUpdate(subscriptionName, clusterIds);</span><br><span class="line">    writeMarker(subscriptionUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集群B和C更新进度"><a href="#集群B和C更新进度" class="headerlink" title="集群B和C更新进度"></a>集群B和C更新进度</h2><p>更新进度的消息会被写入到Topic中，这个消息也会被复制到集群B和C。</p><p>集群B和C中的复制模块读到消息后会做如下处理：</p><p><strong>ReplicatedSubscriptionsController</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void receiveSubscriptionUpdated(ReplicatedSubscriptionsUpdate update) &#123;</span><br><span class="line">  MarkersMessageIdData updatedMessageId &#x3D; null;</span><br><span class="line">  for (int i &#x3D; 0, size &#x3D; update.getClustersCount(); i &lt; size; i++) &#123;</span><br><span class="line">    ClusterMessageId cmid &#x3D; update.getClusterAt(i);</span><br><span class="line">    if (localCluster.equals(cmid.getCluster())) &#123;</span><br><span class="line">      updatedMessageId &#x3D; cmid.getMessageId();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (updatedMessageId &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; No updates for this cluster, ignore</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的消息ID是上一次的LAC。</span><br><span class="line">  Position pos &#x3D; new PositionImpl(updatedMessageId.getLedgerId(), updatedMessageId.getEntryId());</span><br><span class="line"></span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;][&#123;&#125;] Received update for subscription to &#123;&#125;&quot;, topic, update.getSubscriptionName(), pos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 更新消费者读取进度为上一次的LAC。</span><br><span class="line">  PersistentSubscription sub &#x3D; topic.getSubscription(update.getSubscriptionName());</span><br><span class="line">  if (sub !&#x3D; null) &#123;</span><br><span class="line">    sub.acknowledgeMessage(Collections.singletonList(pos), AckType.Cumulative, Collections.emptyMap());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; Subscription doesn&#39;t exist. We need to force the creation of the subscription in this cluster, because</span><br><span class="line">    log.info(&quot;[&#123;&#125;][&#123;&#125;] Creating subscription at &#123;&#125;:&#123;&#125; after receiving update from replicated subcription&quot;,</span><br><span class="line">        topic, update.getSubscriptionName(), updatedMessageId.getLedgerId(), pos);</span><br><span class="line">    topic.createSubscription(update.getSubscriptionName(),</span><br><span class="line">        InitialPosition.Latest, true &#x2F;* replicateSubscriptionState *&#x2F;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，消息进度的同步是由延迟的，而且是不是精确的。</p><h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><p>建立不同集群间消息ID的关联关系过程，是一个不精确的过程。集群A只是发送了一个快照通知，集群B和集群C把当前LAC发送给集群A，集群A读到这个LAC时，已经有新的消息写入到集群A了。此时集群A把集群B和集群C上次的LAC和本地集群中相对靠前的消息ID建立了关联关系。</p><p>比如：</p><p>集群A收到1、2、3三条消息，发送通知给集群B和集群C。</p><p>集群B读取到3后，可能有4、5、6又发送到集群B了，此时集群B发送的LAC是6。</p><p>集群C读取到3后，可能有4、5、6、7又发送到集群C了，此时集群C发送的LAC是7。</p><p>集群A读取到6后，记录下来，等待集群C的LAC。</p><p>集群A读取到7后，可能有8、9发送到集群A了，此时存储7的消息ID变成了10。</p><p>集群A建立的关联关系是10 - 6（集群B）- 7（集群C）。</p><p>当集群A的消费者读取到10的时候，把快照缓存到Broker的内存里，读取到11的时候，发现前边有一个快照。然后记录更新通知，写到Topic里。</p><p>集群B和集群C读取到快照时，会把进度分别更新到6和7，但此时消费者其实已经读取到11了。</p><p>按照这种解释，订阅进度永远不可能完全一致，即使集群A长时间都没收到消息了，集群B和集群C的消费进度也不会和集群A一致。</p>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson和jackson冲突造成的数据解析问题</title>
      <link href="/2021/09/14/pulsar/%E3%80%90bug%E3%80%91fastjson%E5%92%8Cjackson%E5%86%B2%E7%AA%81%E9%80%A0%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/"/>
      <url>/2021/09/14/pulsar/%E3%80%90bug%E3%80%91fastjson%E5%92%8Cjackson%E5%86%B2%E7%AA%81%E9%80%A0%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-版本"><a href="#1-版本" class="headerlink" title="1. 版本"></a>1. 版本</h1><p>pulsar：2.8.0</p><p>fastjson：1.2.76</p><h1 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h1><p>在pulsar项目中引入fastjson后，pulsar中某些admin api不能正常使用，会报NPE错误。</p><p>执行命令会报错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mac bin]$ .&#x2F;pulsar-admin namespaces set-backlog-quota --limit 100M --limitTime 1111 --policy producer_request_hold sample&#x2F;ns118:38:54.968 [AsyncHttpClient-7-1] WARN  org.apache.pulsar.client.admin.internal.BaseResource - [http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;admin&#x2F;v2&#x2F;namespaces&#x2F;sample&#x2F;ns1&#x2F;backlogQuota] Failed to perform http post request: javax.ws.rs.InternalServerErrorException: HTTP 500 Internal Server ErrorHTTP 500 Internal Server Error</span><br><span class="line">Reason: HTTP 500 Internal Server Error[mac bin]$</span><br></pre></td></tr></table></figure><p>查看pulsar的日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11:50:05.098 [pulsar-web-63-6] ERROR org.apache.pulsar.broker.admin.impl.NamespacesBase - [null] Failed to update backlog quota map for namespace sample&#x2F;ns1org.apache.pulsar.metadata.api.MetadataStoreException: com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: org.apache.pulsar.common.policies.data.Policies[&quot;backlog_quota_map&quot;]-&gt;java.util.LinkedHashMap[&quot;destination_storage&quot;]-&gt;com.sun.proxy.$Proxy117[&quot;limitSize&quot;])  at org.apache.pulsar.broker.resources.BaseResources.set(BaseResources.java:94) ~[org.apache.pulsar-pulsar-broker-common-2.8.0.jar:2.8.0]  at org.apache.pulsar.broker.admin.impl.NamespacesBase.internalSetBacklogQuota(NamespacesBase.java:1387) ~[pulsar-broker-2.8.0.jar:2.8.0]  at org.apache.pulsar.broker.admin.v2.Namespaces.setBacklogQuota(Namespaces.java:724) ~[pulsar-broker-2.8.0.jar:2.8.0]  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_231]  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_231]  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_231]  at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_231]  at org.glassfish.jersey.server.model.internal.ResourceMethodInvocationHandlerFactory.lambda$static$0(ResourceMethodInvocationHandlerFactory.java:52) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher$1.run(AbstractJavaResourceMethodDispatcher.java:124) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.invoke(AbstractJavaResourceMethodDispatcher.java:167) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.model.internal.JavaResourceMethodDispatcherProvider$VoidOutInvoker.doDispatch(JavaResourceMethodDispatcherProvider.java:159) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.dispatch(AbstractJavaResourceMethodDispatcher.java:79) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.model.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:475) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:397) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:81) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.ServerRuntime$1.run(ServerRuntime.java:255) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.internal.Errors$1.call(Errors.java:248) ~[org.glassfish.jersey.core-jersey-common-2.34.jar:?]  at org.glassfish.jersey.internal.Errors$1.call(Errors.java:244) ~[org.glassfish.jersey.core-jersey-common-2.34.jar:?]  at org.glassfish.jersey.internal.Errors.process(Errors.java:292) ~[org.glassfish.jersey.core-jersey-common-2.34.jar:?]  at org.glassfish.jersey.internal.Errors.process(Errors.java:274) ~[org.glassfish.jersey.core-jersey-common-2.34.jar:?]  at org.glassfish.jersey.internal.Errors.process(Errors.java:244) ~[org.glassfish.jersey.core-jersey-common-2.34.jar:?]  at org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:265) ~[org.glassfish.jersey.core-jersey-common-2.34.jar:?]  at org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:234) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:680) ~[org.glassfish.jersey.core-jersey-server-2.34.jar:?]  at org.glassfish.jersey.servlet.WebComponent.serviceImpl(WebComponent.java:394) ~[org.glassfish.jersey.containers-jersey-container-servlet-core-2.34.jar:?]  at org.glassfish.jersey.servlet.WebComponent.service(WebComponent.java:346) ~[org.glassfish.jersey.containers-jersey-container-servlet-core-2.34.jar:?]  at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:366) ~[org.glassfish.jersey.containers-jersey-container-servlet-core-2.34.jar:?]  at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:319) ~[org.glassfish.jersey.containers-jersey-container-servlet-core-2.34.jar:?]  at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:205) ~[org.glassfish.jersey.containers-jersey-container-servlet-core-2.34.jar:?]  at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:799) ~[org.eclipse.jetty-jetty-servlet-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.servlet.ServletHandler$ChainEnd.doFilter(ServletHandler.java:1626) ~[org.eclipse.jetty-jetty-servlet-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.apache.pulsar.broker.web.ResponseHandlerFilter.doFilter(ResponseHandlerFilter.java:65) ~[pulsar-broker-2.8.0.jar:2.8.0]  at org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:193) ~[org.eclipse.jetty-jetty-servlet-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1601) ~[org.eclipse.jetty-jetty-servlet-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:548) ~[org.eclipse.jetty-jetty-servlet-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1624) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1435) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:501) ~[org.eclipse.jetty-jetty-servlet-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1594) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1350) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:234) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:146) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.StatisticsHandler.handle(StatisticsHandler.java:179) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.Server.handle(Server.java:516) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:388) ~[org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:633) [org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:380) [org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:277) [org.eclipse.jetty-jetty-server-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311) [org.eclipse.jetty-jetty-io-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105) [org.eclipse.jetty-jetty-io-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104) [org.eclipse.jetty-jetty-io-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:338) [org.eclipse.jetty-jetty-util-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:315) [org.eclipse.jetty-jetty-util-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:173) [org.eclipse.jetty-jetty-util-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:131) [org.eclipse.jetty-jetty-util-9.4.42.v20210604.jar:9.4.42.v20210604]  at org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:383) [org.eclipse.jetty-jetty-util-9.4.42.v20210604.jar:9.4.42.v20210604]  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_231]  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_231]  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [io.netty-netty-common-4.1.63.Final.jar:4.1.63.Final]  at java.lang.Thread.run(Thread.java:748) [?:1.8.0_231]</span><br></pre></td></tr></table></figure><p>虽然能明显看出来是json解析报错引起的空指针问题，但是不知道是哪一个步骤造成解析失败。</p><h1 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3. 问题解决"></a>3. 问题解决</h1><p>经过一系列的排查后，发现是fastjson自动注册provider引起的。</p><p>pulsar使用jersey框架作为restful接口的处理，同时使用jackson作为json解析框架，但是项目引入fastjson后，解析框架就会被替换成fast接送。</p><p>所以解决方法就是找到注册相关的代码，设置不自动注册。</p><p>查看fastjson中注册的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里继承jersey的AutoDiscoverable接口，并设置注册优先权高于jersey的默认权限，是为了优先注册fastjson的解析框架。</span></span><br><span class="line"><span class="meta">@Priority</span>(AutoDiscoverable.DEFAULT_PRIORITY - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonAutoDiscoverable</span> <span class="keyword">implements</span> <span class="title">AutoDiscoverable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FASTJSON_AUTO_DISCOVERABLE = <span class="string">"fastjson.auto.discoverable"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> autoDiscover = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;        </span><br><span class="line">      <span class="comment">// 获取系统属性        </span></span><br><span class="line">      <span class="keyword">try</span> &#123;            </span><br><span class="line">        autoDiscover = Boolean.parseBoolean(System.getProperty(FASTJSON_AUTO_DISCOVERABLE, String.valueOf(autoDiscover)));        </span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">//skip        </span></span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(<span class="keyword">final</span> FeatureContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Configuration config = context.getConfiguration();</span><br><span class="line">        <span class="comment">// Register FastJson. 如果设置了自动注册，且还没有注册过，则进行注册。        </span></span><br><span class="line">      <span class="keyword">if</span> (!config.isRegistered(FastJsonFeature<span class="class">.<span class="keyword">class</span>) &amp;&amp; <span class="title">autoDiscover</span>) </span>&#123;</span><br><span class="line">            context.register(FastJsonFeature<span class="class">.<span class="keyword">class</span>)</span>;        </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以如果不想用fastjson，则需要设置自动注册为false：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.setProperty(FastJsonAutoDiscoverable.FASTJSON_AUTO_DISCOVERABLE, &quot;false&quot;);</span><br></pre></td></tr></table></figure><p><strong>这个是全局变量，所以需要在程序启动的时候设置，如果在jersey加载完之后在设置就没有效果了。</strong></p><h1 id="4-问题排查"><a href="#4-问题排查" class="headerlink" title="4. 问题排查"></a>4. 问题排查</h1><p>解决办法虽然很简单，一行代码就可以了，但是找问题却耗费了很长时间，下面记录下查找问题做的一些工作。</p><h2 id="4-1-问题确认"><a href="#4-1-问题确认" class="headerlink" title="4.1 问题确认"></a>4.1 问题确认</h2><p>出现问题的原因是我们添加了自己的业务逻辑，那么就要确认这个问题是新增代码引起的还是以前就有的bug。</p><p>所以首先需要把环境恢复成修改之前的环境，然后测试。</p><p>结果发现之前的环境没问题，所以确认出现问题的原因就是最近新加的代码。</p><h2 id="4-2-在问题出现的地方找原因"><a href="#4-2-在问题出现的地方找原因" class="headerlink" title="4.2 在问题出现的地方找原因"></a>4.2 在问题出现的地方找原因</h2><p>通常情况下，对于新出现的问题，我们不可能马上明白原因是啥，不知道是之前哪一块逻辑修改造成的，尤其是代码可能不是自己写的。</p><p>所以，最简单的就是在问题出现地方的前后打日志，理清前后逻辑。</p><p>该问题出现在</p><p>org.apache.pulsar.metadata.cache.impl.MetadataCacheImpl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">readModifyUpdate</span><span class="params">(String path, Function&lt;T, T&gt; modifyFunction)</span> </span>&#123;</span><br><span class="line">  log.info(<span class="string">"vvv method &#123;&#125;, path &#123;&#125;"</span>, <span class="string">"readModifyUpdate0"</span>, path);</span><br><span class="line">  <span class="keyword">return</span> executeWithRetry(() -&gt; objCache.get(path)</span><br><span class="line">      .thenCompose(optEntry -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!optEntry.isPresent()) &#123;</span><br><span class="line">          <span class="keyword">return</span> FutureUtils.exception(<span class="keyword">new</span> NotFoundException(<span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CacheGetResult&lt;T&gt; entry = optEntry.get();</span><br><span class="line">        T currentValue = entry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> expectedVersion = optEntry.get().getStat().getVersion();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"vvv method &#123;&#125;, path: &#123;&#125;, class: &#123;&#125;, value: &#123;&#125;, hash: &#123;&#125;, expectedVersion: &#123;&#125;, p: &#123;&#125;"</span>,</span><br><span class="line">            <span class="string">"readModifyUpdate"</span>, path, currentValue.getClass(), currentValue, currentValue.hashCode(),</span><br><span class="line">            expectedVersion, <span class="keyword">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentValue <span class="keyword">instanceof</span> Policies) &#123;</span><br><span class="line">          Policies p = (Policies) currentValue;</span><br><span class="line">          <span class="keyword">if</span> (p.backlog_quota_map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p.backlog_quota_map.forEach((key, value) -&gt; &#123;</span><br><span class="line">              log.info(<span class="string">"vvv method &#123;&#125;, path &#123;&#125;, key &#123;&#125;, value &#123;&#125; &#123;&#125;"</span>, <span class="string">"readModifyUpdate"</span>, path, key,</span><br><span class="line">                  value.getClass(), value);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        T newValueObj;</span><br><span class="line">        <span class="keyword">byte</span>[] newValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// Use clone and CAS zk to ensure thread safety</span></span><br><span class="line">                    <span class="comment">// 问题出现在这里</span></span><br><span class="line">          currentValue = serde.deserialize(serde.serialize(currentValue));</span><br><span class="line">                    <span class="comment">// apply方法可以拿到之前方法的值。</span></span><br><span class="line">          newValueObj = modifyFunction.apply(currentValue);</span><br><span class="line">          log.info(<span class="string">"vvv method &#123;&#125;, path: &#123;&#125;, class: &#123;&#125;, newValue: &#123;&#125;"</span>, <span class="string">"readModifyUpdate"</span>, path,</span><br><span class="line">              newValueObj.getClass(), newValueObj);</span><br><span class="line"></span><br><span class="line">          newValue = serde.serialize(newValueObj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          <span class="keyword">return</span> FutureUtils.exception(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> store.put(path, newValue, Optional.of(expectedVersion)).thenAccept(stat -&gt; &#123;</span><br><span class="line">          <span class="comment">// Make sure we have the value cached before the operation is completed</span></span><br><span class="line">          log.info(<span class="string">"vvv method &#123;&#125;, path &#123;&#125;"</span>, <span class="string">"readModifyUpdate-put"</span>, path);</span><br><span class="line">          objCache.put(path,</span><br><span class="line">              FutureUtils.value(Optional.of(<span class="keyword">new</span> CacheGetResult&lt;&gt;(newValueObj, stat))));</span><br><span class="line">        &#125;).thenApply(__ -&gt; newValueObj);</span><br><span class="line">      &#125;), path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读该类的代码，可以发现：</p><ul><li><p>该类缓存了一些从zookeeper中查询的数据，缓存使用的框架是Caffeine。</p></li><li><p>缓存中的数据会定时老化。</p></li><li><p>该类提供了数据修改方法，接收到修改指令后会更新到zookeeper中，然后更新缓存数据。</p></li><li><p>在上述方法中，接收到更新指令后，首先根据path查找缓存中是否存在，如果不存在则直接返回；如果存在，则获取数据和数据版本（对应zookeeper中的版本），把旧数据序列化后再反序列化（不知道意义是啥），然后把新数据保存到zookeeper中，保存成功后更新缓存数据。</p></li><li><p>缓存初始化的方法是readValueFromStore用于从zookeeper中查询数据。</p></li></ul><p><strong>打包后替换线上环境，并看下打印的日志：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11:50:05.095 [pulsar-web-63-6] INFO  org.apache.pulsar.metadata.cache.impl.MetadataCacheImpl - vvv method readModifyUpdate, path: &#x2F;admin&#x2F;policies&#x2F;sample&#x2F;ns1, class: class org.apache.pulsar.common.policies.data.Policies, value: Policies(auth_policies&#x3D;AuthPoliciesImpl(namespaceAuthentication&#x3D;&#123;&#125;, topicAuthentication&#x3D;&#123;&#125;, subscriptionAuthentication&#x3D;&#123;&#125;), replication_clusters&#x3D;[standalone], bundles&#x3D;BundlesDataImpl(boundaries&#x3D;[0x00000000, 0x40000000, 0x80000000, 0xc0000000, 0xffffffff], numBundles&#x3D;4), backlog_quota_map&#x3D;&#123;destination_storage&#x3D;&#123;&#125;&#125;, clusterDispatchRate&#x3D;&#123;&#125;, topicDispatchRate&#x3D;&#123;&#125;, subscriptionDispatchRate&#x3D;&#123;&#125;, replicatorDispatchRate&#x3D;&#123;&#125;, clusterSubscribeRate&#x3D;&#123;&#125;, persistence&#x3D;null, deduplicationEnabled&#x3D;null, autoTopicCreationOverride&#x3D;null, autoSubscriptionCreationOverride&#x3D;null, publishMaxMessageRate&#x3D;&#123;&#125;, latency_stats_sample_rate&#x3D;&#123;&#125;, message_ttl_in_seconds&#x3D;null, subscription_expiration_time_minutes&#x3D;0, retention_policies&#x3D;null, deleted&#x3D;false, encryption_required&#x3D;false, delayed_delivery_policies&#x3D;null, inactive_topic_policies&#x3D;null, subscription_auth_mode&#x3D;None, max_producers_per_topic&#x3D;null, max_consumers_per_topic&#x3D;null, max_consumers_per_subscription&#x3D;null, max_unacked_messages_per_consumer&#x3D;null, max_unacked_messages_per_subscription&#x3D;null, max_subscriptions_per_topic&#x3D;null, compaction_threshold&#x3D;null, offload_threshold&#x3D;-1, offload_deletion_lag_ms&#x3D;null, max_topics_per_namespace&#x3D;null, schema_auto_update_compatibility_strategy&#x3D;Full, schema_compatibility_strategy&#x3D;UNDEFINED, is_allow_auto_update_schema&#x3D;true, schema_validation_enforced&#x3D;false, offload_policies&#x3D;null, deduplicationSnapshotIntervalSeconds&#x3D;null, subscription_types_enabled&#x3D;[], properties&#x3D;&#123;&#125;, resource_group_name&#x3D;null), hash: -2056889852, expectedVersion: 0, p: 1890262240</span><br></pre></td></tr></table></figure><p>可以看到backlog_quota_map={destination_storage={}}中destination_storage是一个空值，所以当序列化的时候会抛出NPE异常。</p><p>正常情况下的日志应该是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10:49:44.719 [metadata-store-32-1] INFO  org.apache.pulsar.metadata.cache.impl.MetadataCacheImpl - vvv method readValueFromStore, path &#x2F;admin&#x2F;policies&#x2F;sample&#x2F;ns1, class class org.apache.pulsar.common.policies.data.Policies, value Policies(auth_policies&#x3D;AuthPoliciesImpl(namespaceAuthentication&#x3D;&#123;&#125;, topicAuthentication&#x3D;&#123;&#125;, subscriptionAuthentication&#x3D;&#123;&#125;), replication_clusters&#x3D;[standalone], bundles&#x3D;BundlesDataImpl(boundaries&#x3D;[0x00000000, 0x40000000, 0x80000000, 0xc0000000, 0xffffffff], numBundles&#x3D;4), backlog_quota_map&#x3D;&#123;destination_storage&#x3D;BacklogQuotaImpl(limitSize&#x3D;104857600, limitTime&#x3D;1111, policy&#x3D;producer_request_hold)&#125;, clusterDispatchRate&#x3D;&#123;&#125;, topicDispatchRate&#x3D;&#123;&#125;, subscriptionDispatchRate&#x3D;&#123;&#125;, replicatorDispatchRate&#x3D;&#123;&#125;, clusterSubscribeRate&#x3D;&#123;&#125;, persistence&#x3D;null, deduplicationEnabled&#x3D;null, autoTopicCreationOverride&#x3D;null, autoSubscriptionCreationOverride&#x3D;null, publishMaxMessageRate&#x3D;&#123;&#125;, latency_stats_sample_rate&#x3D;&#123;&#125;, message_ttl_in_seconds&#x3D;null, subscription_expiration_time_minutes&#x3D;0, retention_policies&#x3D;null, deleted&#x3D;false, encryption_required&#x3D;false, delayed_delivery_policies&#x3D;null, inactive_topic_policies&#x3D;null, subscription_auth_mode&#x3D;None, max_producers_per_topic&#x3D;null, max_consumers_per_topic&#x3D;null, max_consumers_per_subscription&#x3D;null, max_unacked_messages_per_consumer&#x3D;null, max_unacked_messages_per_subscription&#x3D;null, max_subscriptions_per_topic&#x3D;null, compaction_threshold&#x3D;null, offload_threshold&#x3D;-1, offload_deletion_lag_ms&#x3D;null, max_topics_per_namespace&#x3D;null, schema_auto_update_compatibility_strategy&#x3D;Full, schema_compatibility_strategy&#x3D;UNDEFINED, is_allow_auto_update_schema&#x3D;true, schema_validation_enforced&#x3D;false, offload_policies&#x3D;null, deduplicationSnapshotIntervalSeconds&#x3D;null, subscription_types_enabled&#x3D;[], properties&#x3D;&#123;&#125;, resource_group_name&#x3D;null), hash 1614905576, version: 1, p: 1843660571</span><br></pre></td></tr></table></figure><p>destination_storage是有内容的，内容是：</p><p>BacklogQuotaImpl(limitSize=104857600, limitTime=1111, policy=producer_request_hold)。</p><p>由于这里的数据是从缓存中获取的，所以怀疑从缓存中拿到数据就是空，但是在readValueFromStore方法中打印日志后，发现这里的数据并不是空，而且内容和readModifyUpdate中不一样。<strong>所以就能确认在其他地方修改了缓存中的数据</strong>。</p><h2 id="4-3-查看调用链"><a href="#4-3-查看调用链" class="headerlink" title="4.3 查看调用链"></a>4.3 查看调用链</h2><p>通过debug可以确认调用链是：</p><ul><li><p>org.apache.pursar.broker.admin.v2.Namespaces -&gt; setBacklogQuota</p></li><li><p>org.apache.pursar.broker.admin.impl.NamespaceBase -&gt; internalSetBacklogQuota</p></li><li><p>org.apache.pulsar.broker.resources -&gt; set</p></li><li><p>org.apache.pulsar.broker.resources -&gt; setAsync</p></li><li><p>org.apache.pulsar.metadata.cache.impl -&gt; readModifyUpdate</p></li></ul><p>第一个方法就是提供了http接口，接收客户端传递的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBacklogQuota</span><span class="params">(@PathParam(<span class="string">"tenant"</span>)</span> String tenant, @<span class="title">PathParam</span><span class="params">(<span class="string">"namespace"</span>)</span> String namespace,</span></span><br><span class="line"><span class="function">    @<span class="title">QueryParam</span><span class="params">(<span class="string">"backlogQuotaType"</span>)</span> BacklogQuotaType backlogQuotaType,</span></span><br><span class="line"><span class="function">    @<span class="title">ApiParam</span><span class="params">(value = <span class="string">"Backlog quota for all topics of the specified namespace"</span>)</span></span></span><br><span class="line"><span class="function">        BacklogQuota backlogQuota) </span>&#123;</span><br><span class="line">  validateNamespaceName(tenant, namespace);</span><br><span class="line">  log.info(<span class="string">"vvv method &#123;&#125;, backlogQuota &#123;&#125;, class &#123;&#125;"</span>, <span class="string">"setBacklogQuota"</span>, backlogQuota, backlogQuota.getClass());</span><br><span class="line">  internalSetBacklogQuota(backlogQuotaType, backlogQuota);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处打印的日志如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11:50:05.094 [pulsar-web-63-6] INFO  org.apache.pulsar.broker.admin.v2.Namespaces - vvv method setBacklogQuota, backlogQuota &#123;&#125;, class com.sun.proxy.$Proxy117 &#123;&#125;</span><br></pre></td></tr></table></figure><p>第二个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">internalSetBacklogQuota</span><span class="params">(BacklogQuotaType backlogQuotaType, BacklogQuota backlogQuota)</span> </span>&#123;</span><br><span class="line">  validateNamespacePolicyOperation(namespaceName, PolicyName.BACKLOG, PolicyOperation.WRITE);</span><br><span class="line">  validatePoliciesReadOnlyAccess();</span><br><span class="line">  <span class="keyword">final</span> BacklogQuotaType quotaType = backlogQuotaType != <span class="keyword">null</span> ? backlogQuotaType</span><br><span class="line">      : BacklogQuotaType.destination_storage;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> String path = path(POLICIES, namespaceName.toString());</span><br><span class="line">        <span class="comment">// 从MetaCacheImpl中获取缓存中的数据。</span></span><br><span class="line">    Policies policies = namespaceResources().get(path)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> RestException(Status.NOT_FOUND, <span class="string">"Namespace policies does not exist"</span>));</span><br><span class="line">    RetentionPolicies r = policies.retention_policies;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Policies p = <span class="keyword">new</span> Policies();</span><br><span class="line">      p.backlog_quota_map.put(quotaType, backlogQuota);</span><br><span class="line">      <span class="keyword">if</span> (!checkQuotas(p, r)) &#123;</span><br><span class="line">        log.warn(</span><br><span class="line">            <span class="string">"[&#123;&#125;] Failed to update backlog configuration"</span></span><br><span class="line">                + <span class="string">" for namespace &#123;&#125;: conflicts with retention quota"</span>,</span><br><span class="line">            clientAppId(), namespaceName);</span><br><span class="line">        <span class="keyword">new</span> RestException(Status.PRECONDITION_FAILED,</span><br><span class="line">            <span class="string">"Backlog Quota exceeds configured retention quota for namespace."</span></span><br><span class="line">                + <span class="string">" Please increase retention quota and retry"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 修改缓存中的数据（这里是直接修改缓存中的数据，所以在之前的日志中,</span></span><br><span class="line">        <span class="comment">// 我们发现readModifyUpdate方法中拿到的缓存对象的内容和缓存加载方法readValueFromStore中的不一致）。</span></span><br><span class="line">    policies.backlog_quota_map.put(quotaType, backlogQuota);</span><br><span class="line">    log.info(<span class="string">"vvv method &#123;&#125;, path &#123;&#125;, policies &#123;&#125;"</span>, <span class="string">"internalSetBacklogQuota"</span>, path, policies);</span><br><span class="line">    namespaceResources().set(path, p -&gt; policies);</span><br><span class="line">    log.info(<span class="string">"[&#123;&#125;] Successfully updated backlog quota map: namespace=&#123;&#125;, map=&#123;&#125;"</span>, clientAppId(), namespaceName,</span><br><span class="line">        jsonMapper().writeValueAsString(backlogQuota));</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (RestException pfe) &#123;</span><br><span class="line">    <span class="keyword">throw</span> pfe;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">"[&#123;&#125;] Failed to update backlog quota map for namespace &#123;&#125;"</span>, clientAppId(), namespaceName, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RestException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中，先是从MetaCacheImple对象中根据path拿到缓存中的policies，然后更新该policies，然后再通过MetaCacheImpl的update方法更新zookeeper中的数据。</p><p><strong>通过上述流程，我们可以确定的是，缓存从zookeeper中加载的数据是正确的，客户端调用命令后传递的数据是错误的，所以定位到问题出现在调用链的第一个方法中。</strong></p><h2 id="4-4-问题分析"><a href="#4-4-问题分析" class="headerlink" title="4.4 问题分析"></a>4.4 问题分析</h2><p>从前面的过程中，我们就能大致确认问题是客户端传递的参数没有被正常解析或者客户端传递的参数为空，然后pulsar本身使用jersey作为restful框架，使用jackson解析请求中的json数据，并对请求参数进行赋值。</p><p>首先通过tcpdump捕获交互过程中的数据包，确定客户端发送的数据中是有内容的：</p><p><img src="assets/image-20231007103138364.png" alt="image-20231007103138364"></p><p>可以看到传递的内容不为空，然后看不报错情况下的数据报文：</p><p><img src="assets/image-20231007103221655.png" alt="image-20231007103221655"></p><p>由此就可以确定不是客户端的问题，而是broker端接收到数据后的解析问题。</p><p>结合以往经验，推测是不同的json处理框架有冲突，导致数据解析失败。把fastjson去掉后，果然问题不再出现！</p><h2 id="4-5-问题解决"><a href="#4-5-问题解决" class="headerlink" title="4.5 问题解决"></a>4.5 问题解决</h2><p>既然是fastjson的问题，那么推测是加载fastjson包后，会在某些情况下替换jackson进行json数据的解析，导致解析出错。</p><p>pulsar是基于jersey作为restful框架的，而jersey遵循了javax-ws规范，规范中定义了加载哪些数据解析类，即定义了加载哪一个json框架作为解析框架。</p><p>搜索关键词：fastjson和jersey冲突，发现fastjson项目中的一个issue：</p><p><a href="https://github.com/alibaba/fastjson/issues/1392" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/issues/1392</a></p><p>有人遇到了相似的问题，fastjson进行了修复。</p><p>我们的问题与上述问题还是有些不同的，但本质一样，都是由于fastjson默认加载了自己的作为java-ws的provider，导致jersey不能加载jackson。</p><p>而fastjson又不够强大，如果参数中的变量类型是interface，fastjson不能找到该interface的实现类并赋值，所以我们看到setBacklogQuota方法中backlogQuota是空的，而且class是com.sun.proxy.$Proxy117。</p><p><strong>如果我们把BacklogQuota换成backlogQuotaImpl或者我们自己写的一个包含三个参数的类，则能成功赋值，例如这样：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VVData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> limitSize;</span><br><span class="line">    <span class="comment">// backlog quota by time in second</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limitTime;</span><br><span class="line">    <span class="keyword">private</span> BacklogQuota.RetentionPolicy policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12:14:01.371 [pulsar-web-63-12] INFO  org.apache.pulsar.broker.admin.v2.Namespaces - vvv method setBacklogQuota, backlogQuota VVData(limitSize&#x3D;104857600, limitTime&#x3D;1111, policy&#x3D;producer_request_hold</span><br></pre></td></tr></table></figure><h1 id="5-疑问"><a href="#5-疑问" class="headerlink" title="5. 疑问"></a>5. 疑问</h1><p>上边问题已经解决了，但是在找问题的过程中，发现可以通过其他地方修改Caffeine缓存中的数据。</p><p><strong>这里在多线程同时操作情况下有出现数据不一致的问题吧</strong></p><p>fastjson不会自动把自己设置为java-ws的provider，应该是jersey在启动的时候查找AutoDiscoverable接口的所有实现类，然后根据实现类里面设置的优先级加载优先级最高的provider，或者按照优先级顺序加载所有的provider。AutoDiscoverable的代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.glassfish.jersey.internal.spi;</span><br><span class="line">import javax.ws.rs.core.FeatureContext;</span><br><span class="line">&#x2F;** * A service provider contract for JAX-RS and Jersey components that need to be automatically discovered and registered in * &#123;@link javax.ws.rs.core.Configuration runtime configurations&#125;. * &lt;p&#x2F;&gt; * A component implementing this contract becomes auto-discoverable by adding a new entry with fully qualified name of its * implementation class name to a &#123;@code org.glassfish.jersey.internal.spi.AutoDiscoverable&#125; file in the &#123;@code * META-INF&#x2F;services&#125; directory. * &lt;p&#x2F;&gt; * Almost all Jersey &#123;@code AutoDiscoverable&#125; implementations have * &#123;@link #DEFAULT_PRIORITY&#125; &#123;@link javax.annotation.Priority priority&#125; set. * * @author Michal Gajdos *&#x2F;public interface AutoDiscoverable &#123;</span><br><span class="line">    &#x2F;**     * Default common priority of Jersey build-in auto-discoverables.     * Use lower number on your &#123;@code AutoDiscoverable&#125; implementation to run it before Jersey auto-discoverables     * and vice versa.     * 优先级，在fastjson中设置的优先级是 (DEFAULT_PRIORITY - 1)，所以会优先加载。     *&#x2F;    public static final int DEFAULT_PRIORITY &#x3D; 2000;</span><br><span class="line">    &#x2F;**     * A call-back method called when an auto-discoverable component is to be configured in a given runtime configuration scope.     * &lt;p&gt;     * Note that as with &#123;@link javax.ws.rs.core.Feature JAX-RS features&#125;, before registering new JAX-RS components in a     * given configurable context, an auto-discoverable component should verify that newly registered components are not     * already registered in the configurable context.     * &lt;&#x2F;p&gt;     *     * @param context configurable context in which the auto-discoverable should be configured.     *&#x2F;    public void configure(FeatureContext context);&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只读broker设计（一）</title>
      <link href="/2021/09/02/pulsar/%E5%8F%AA%E8%AF%BBbroker%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/09/02/pulsar/%E5%8F%AA%E8%AF%BBbroker%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-初衷"><a href="#1-初衷" class="headerlink" title="1. 初衷"></a>1. 初衷</h1><p>pulsar中每一个topic必须由唯一的一个broker负责读和写，这样在保证消息的顺序和事务方面就很方便。但是如果出现如下场景：</p><ul><li>消费业务分布在多个地区</li><li>某一个topic的消费业务特别多</li></ul><p>单个broker处理请求就显得不能满足需求了。</p><p>因此，就可以设计一种只读broker，类似zookeeper中的observer，该种角色的broker只负责消息的读，不负责消息的写入。这样既能满足异地消费时从本地存储中拉取数据，又能横向扩展单topic多业务消费能力。</p><h1 id="2-解析"><a href="#2-解析" class="headerlink" title="2. 解析"></a>2. 解析</h1><p>在pulsar的架构中，消息的处理和存储是分离的，producer和consumer和broker进行数据的交互，broker收到数据后选择对应的bookie节点进行读写。如下图：</p><p><img src="assets/image-20231008234840919.png" alt="image-20231008234840919"></p><p>这种计算和存储分离的结构，虽然一定程度上会增大消息延迟，但是对于系统的整体可用性以及资源的平均分配有很大好处。</p><p>也因此在pulsar中，broker是无状态的，broker之间不需要进行信息的同步，不需要感知其他broker的状态。当一个consumer/producer连接到broker后，broker只需要通过zk判断是否应该由自己负责topic消息的读写即可（pulsar正常工作的前提也是zk是正常的）。</p><p>pulsar中每一个topic消息的读写都是由唯一的一个broker负责的（虽然有分区topic，但本质上还是拆分成独立的topic了），这样在保证消息顺序、事务、消息消费进度等方面都会变得很方便。但是就像开头说的那样，如果一个topic的消息成千上万的订阅者都需要，这样就会因broker单点造成性能的问题。</p><p>在开始实现只读功能之前，根据以往的经验，可以想到有以下几个问题需要关注：</p><ul><li><p>只读broker怎么获取到某个topic写的进度，怎么能实时感知。</p></li><li><p>只读broker怎么保存某个subscription的消费进度。</p></li><li><p>只读broker之间是否需要同步消费进度，即是否支持一个subscription从多个broker订阅。</p></li><li><p>写broker是否需要消息消费进度。</p></li><li><p>怎么删除已消费完的消息（之前是有写broker判断如果所有的subscription都消费完成了，则删除消息，现在写broker不知道各个只读broker的消费进度）。</p></li><li><p>只读broker是单独部署还是说通过消费者发送的标识判断是否是以只读方式读取。</p></li><li><p>consumer连接到一个只读broker消费一定量消息后断开连接，连接到其他的只读broker，那么其他只读broker怎么获取到上次消费进度。</p></li></ul><p>针对上述问题去pulsar源码中找答案，然后找一个折中的方案实现只读broker功能，首先我们先看消息订阅涉及到的几个阶段。</p><h2 id="2-1-lookup"><a href="#2-1-lookup" class="headerlink" title="2.1 lookup"></a>2.1 lookup</h2><p>该阶段是为了查找topic属于哪一个broker负责，consumer传递的信息只有topic名称。</p><p>broker收到请求后，会依次执行以下逻辑：</p><ul><li><p>校验topic是否合法</p></li><li><p>是否超过了设置的同时进行lookup的数量</p></li><li><p>是否通过代理方式连接（代理方式连接需要单独校验权限）</p></li><li><p>topic操作是否被授权</p></li><li><p>校验集群信息、权限信息</p></li><li><p>计算topic属于的bundle，然后根据bundle判断属于哪一个broker，并返回broker的地址</p></li></ul><p><strong>如果实现只读broker，我们就需要在这里添加判断逻辑，返回我们给定的broker地址。</strong></p><h2 id="2-2-subscribe"><a href="#2-2-subscribe" class="headerlink" title="2.2 subscribe"></a>2.2 subscribe</h2><p>该阶段是发送订阅请求，broker可以拿到subName。</p><p>收到订阅请求后会执行以下逻辑：</p><ul><li><p>权限验证</p></li><li><p>客户端信息是否已被保存（broker是通过客户端生成的id来区分不同的consumer的），如果有则直接返回</p></li><li><p>到BrokerService中查找该subName的topic信息，如果有则复用（topic信息由单一实例存储，例如PersistentTopic）；如果没有则创建，然后会依次打开topic对应的ledger、ledger下的cursor。在这个过程中会进行topic归属broker的校验。</p></li><li><p>进行schema的处理</p></li><li><p>创建Subscription实例，保存订阅信息，并建立Consumer和Subscription之间的关系</p></li><li><p>返回订阅成功给consumer</p></li></ul><p><strong>在此阶段中，由于在创建Topic实例的同时会打开ledger和cursor，而ledger是默认以写的方式打开新的ledger的，所以在只读broker中，需要在这个阶段添加判断逻辑，以只读的方式打卡ledger，并且不会创建新的写ledger。</strong></p><h2 id="2-3-ledger和cursor恢复"><a href="#2-3-ledger和cursor恢复" class="headerlink" title="2.3 ledger和cursor恢复"></a>2.3 ledger和cursor恢复</h2><p>该阶段是通过zk中记录的数据进行topic以往ledger和cursor进度的恢复。分别对应zk中的path节点：</p><p>/managed-ledgers/tenant_c/ns1/persistent/topic01</p><p>/managed-ledgers/tenant_c/ns1/persistent/topic01/consumer_00</p><p><strong>这里需要注意的就是怎么同步ledger的LAC到cursor中，并实时感知topic下新的data ledger的创建以及获取最新的LAC信息并同步给cursor。</strong></p><h2 id="2-4-客户端断开连接"><a href="#2-4-客户端断开连接" class="headerlink" title="2.4 客户端断开连接"></a>2.4 客户端断开连接</h2><p>该阶段会进行资源的清理，包括取消订阅信息、关闭consumer等。</p><p><strong>这里需要关注的就是要把消费进度持久化到zk中（默认不是实时刷新到zk的，断开连接后也不会及时持久化，虽然会实时写入bk中）。然后就是需要等一个topic下所有的sub都断开连接了，才进行消费进度的保存。</strong></p><h1 id="3-思路"><a href="#3-思路" class="headerlink" title="3. 思路"></a>3. 思路</h1><p>通过不断尝试，最终确定实现方式如下</p><ul><li><p>设置指定的broker为只读broker，只读broker不提供写功能，并且不会启动写的功能，比如创建topic。</p></li><li><p>一个subscription只能从唯一的一个broker读取消息，之间的关系会写到zk上，broker收到subscribe请求后会进行判断；连接断开后会删除zk中的关系。</p></li><li><p>broker在consumer发送subscribe后会从zk/bk中拉取最新的消费进度，consumer断开连接后会把进度回写到zk中。这样就避免了只读broker之间同步进度。</p></li><li><p>只读broker在定时器中获取data ledger的LAC（对于closed状态的ledger，通过getLastAddConfirmed获取；对于open状态的ledger，通过readLastAddConfirmed）。当获取的LAC比记录的大时，会通过notifyCursors和notifyWaitingEntryCallBacks方法触发读操作。这种方式会造成一定的延迟，但也是可接受的。。。</p></li><li><p>当一个topic的所有subscription都断开时，会关闭cursor，触发进度的持久化。</p></li><li><p>当cursor恢复时，会查询zk中是否存在记录，如果存在则通过zk中的数据恢复进度（由于默认情况下cursor的进度都是在ManagedLedger实例第一次创建的时候恢复的，中间有新的cursor创建就不会有恢复流程了）。</p></li><li><p>只读broker和读写broker共用一套zk环境，但是只是往里面写入subscription的消费进度。</p></li></ul><p>通过上述方式，可以实现一个简单的只读broker。</p><p>后续需要改进的地方包括</p><ul><li><p>消费进度实时感知（当前情况下不能感知到最新一条消息，可能存在刷新延迟）。</p></li><li><p>支持多topic（目前没有测试这个，估计会有问题）。</p></li><li><p>支持分区topic（同上）。</p></li><li><p>延迟消息（目前测试有问题）。</p></li><li><p>只读broker模式下ManagedLedger的一些逻辑被注释掉了，没看懂具体功能，后续还需要继续研究。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次CompletableFuture引起的死锁问题</title>
      <link href="/2021/09/01/pulsar/%E3%80%90bug%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1CompletableFuture%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%7B%7D/"/>
      <url>/2021/09/01/pulsar/%E3%80%90bug%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1CompletableFuture%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%7B%7D/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>在pulsar中添加只读broker功能的支持，所以修改了pulsar-broker的代码，在创建cursor时添加了zk查询代码。</p><p>然后测试的时候发现，每一次重新创建topic，consumer开始订阅消息后，broker就会出现阻塞，导致subscribe阶段一直不成功。</p><h1 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h1><p>consumer和pulsar之间进行交互的阶段有：</p><ul><li><p>CONNECT</p></li><li><p>PARTITIONED_METADATA</p></li><li><p>LOOKUP</p></li><li><p>SUBSCRIBE</p></li></ul><p>然后当consumer发送SUBSCRIBE后，一直收不到broker的应答，由此确认broker处理SUBSCRIBE出现问题。</p><h2 id="2-1-定位代码"><a href="#2-1-定位代码" class="headerlink" title="2.1 定位代码"></a>2.1 定位代码</h2><p>通过查看pulsar的源码，可以看到对于zk数据的查询都是异步执行的，而且共用的一个线程，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AbstractMetadataStore 构造方法</span><br><span class="line">protected AbstractMetadataStore() &#123;</span><br><span class="line">        this.executor &#x3D; Executors</span><br><span class="line">                .newSingleThreadExecutor(new DefaultThreadFactory(&quot;metadata-store&quot;));</span><br><span class="line">        registerListener(this);</span><br><span class="line"> &#x2F;&#x2F; other code   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行查询或者回调函数</span><br><span class="line">&#x2F;**</span><br><span class="line">  * Run the task in the executor thread and fail the future if the executor is shutting down</span><br><span class="line">  *&#x2F;</span><br><span class="line">protected void execute(Runnable task, CompletableFuture&lt;?&gt; future) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        executor.execute(task);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        future.completeExceptionally(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以猜测是由于回调函数没有执行完毕导致的阻塞，因此在所有的回调函数出打印日志，定位到如下代码出现阻塞：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public CompletableFuture&lt;Stat&gt; storePut(String path, byte[] value, Optional&lt;Long&gt; optExpectedVersion,</span><br><span class="line">    EnumSet&lt;CreateOption&gt; options) &#123;</span><br><span class="line">  boolean hasVersion &#x3D; optExpectedVersion.isPresent();</span><br><span class="line">  int expectedVersion &#x3D; optExpectedVersion.orElse(-1L).intValue();</span><br><span class="line"></span><br><span class="line">  CompletableFuture&lt;Stat&gt; future &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    if (hasVersion &amp;&amp; expectedVersion &#x3D;&#x3D; -1) &#123;</span><br><span class="line">      CreateMode createMode &#x3D; getCreateMode(options);</span><br><span class="line">      ZkUtils.asyncCreateFullPathOptimistic(zkc, path, value, ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">          createMode, (rc, path1, ctx, name) -&gt; &#123;</span><br><span class="line">            execute(() -&gt; &#123;</span><br><span class="line">              Code code &#x3D; Code.get(rc);</span><br><span class="line">              if (code &#x3D;&#x3D; Code.OK) &#123;</span><br><span class="line">                                &#x2F;&#x2F; 运行到此处时出现阻塞。</span><br><span class="line">                future.complete(new Stat(name, 0, 0, 0, createMode.isEphemeral(), true));</span><br><span class="line">              &#125; else if (code &#x3D;&#x3D; Code.NODEEXISTS) &#123;</span><br><span class="line">                &#x2F;&#x2F; We&#39;re emulating a request to create node, so the version is invalid</span><br><span class="line">                future.completeExceptionally(getException(Code.BADVERSION, path));</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                future.completeExceptionally(getException(code, path));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, future);</span><br><span class="line">          &#125;, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; other code...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    future.completeExceptionally(new MetadataStoreException(t));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-查看进程和cpu使用情况"><a href="#2-2-查看进程和cpu使用情况" class="headerlink" title="2.2 查看进程和cpu使用情况"></a>2.2 查看进程和cpu使用情况</h2><p>然后查询进程和cpu使用情况：</p><p># 找到进程ID</p><p>ps -ef |grep broker</p><p># 查询进程cpu</p><p>top -Hp 16704</p><p><img src="assets/640-20231008234310085.png" alt="图片"></p><p>看到cpu使用的并不多，再10%以下，由此可推断不是gc或者其他死循环造成的阻塞。</p><h2 id="2-3-查看堆栈信息"><a href="#2-3-查看堆栈信息" class="headerlink" title="2.3 查看堆栈信息"></a>2.3 查看堆栈信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;metadata-store-7-1&quot; #84 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00007f1560004800 nid&#x3D;0x1ca1 waiting on condition [0x00007f1506a2c000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">  at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">  - parking to wait for  &lt;0x00000000fd0c3d18&gt; (a java.util.concurrent.CompletableFuture$Signaller)</span><br><span class="line">  at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">  at java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1693)</span><br><span class="line">  at java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3323)</span><br><span class="line">  at java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1729)</span><br><span class="line">  at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)</span><br><span class="line">  at org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl.recoverCursorFromZK(ManagedLedgerImpl.java:1072)</span><br><span class="line">  at org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl.asyncOpenCursor(ManagedLedgerImpl.java:1019)</span><br><span class="line">    &#x2F;&#x2F; 阻塞原因</span><br><span class="line">  - locked &lt;0x00000000f5841ce8&gt; (a org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl)</span><br><span class="line">  at org.apache.pulsar.broker.service.persistent.PersistentTopic.getDurableSubscription(PersistentTopic.java:857)</span><br><span class="line">  at org.apache.pulsar.broker.service.persistent.PersistentTopic.subscribe(PersistentTopic.java:747)</span><br><span class="line">  at org.apache.pulsar.broker.service.ServerCnx.lambda$null$12(ServerCnx.java:1050)</span><br><span class="line">  at org.apache.pulsar.broker.service.ServerCnx$$Lambda$277&#x2F;1382611823.apply(Unknown Source)</span><br><span class="line">  at java.util.concurrent.CompletableFuture.uniCompose(CompletableFuture.java:952)</span><br><span class="line">  at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:926)</span><br><span class="line">  at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474)</span><br><span class="line">  at java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1962)</span><br><span class="line">  at org.apache.pulsar.broker.service.schema.BookkeeperSchemaStorage$$Lambda$295&#x2F;640790180.accept(Unknown Source)</span><br><span class="line">  at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656)</span><br><span class="line">  at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632)</span><br><span class="line">  at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474)</span><br><span class="line">  at java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1962)</span><br><span class="line">    &#x2F;&#x2F; 阻塞代码</span><br><span class="line">  at org.apache.pulsar.metadata.impl.ZKMetadataStore.lambda$null$15(ZKMetadataStore.java:234)</span><br><span class="line">  at org.apache.pulsar.metadata.impl.ZKMetadataStore$$Lambda$127&#x2F;153703270.run(Unknown Source)</span><br><span class="line">  at org.apache.pulsar.metadata.impl.AbstractMetadataStore.lambda$execute$8(AbstractMetadataStore.java:261)</span><br><span class="line">  at org.apache.pulsar.metadata.impl.AbstractMetadataStore$$Lambda$128&#x2F;1782705605.run(Unknown Source)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;main-EventThread&quot; #82 daemon prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00007f15edd8e800 nid&#x3D;0x1ca0 waiting on condition [0x00007f150692c000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">  at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">  - parking to wait for  &lt;0x00000000f5840660&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">  at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQue</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:559)</span><br><span class="line"></span><br><span class="line">&quot;main-SendThread(172.20.140.23:2181)&quot; #81 daemon prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00007f15edd8a800 nid&#x3D;0x1c9f runnable [0x00007f150672a000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)</span><br><span class="line">at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">- locked &lt;0x00000000f571b3e8&gt; (a sun.nio.ch.Util$3)</span><br><span class="line">- locked &lt;0x00000000f571b3f8&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">- locked &lt;0x00000000f571b3a0&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">at org.apache.zookeeper.ClientCnxnSocketNIO.doTransport(ClientCnxnSocketNIO.java:332)</span><br><span class="line">at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1290)</span><br></pre></td></tr></table></figure><p>可以看到zk中代码出现阻塞的原因是和ManagedLedgerImpl中的代码出现了资源竞争，涉及到的代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean recoverCursorFromZK(String cursorName, final OpenCursorCallback callback, final Object ctx) &#123;</span><br><span class="line">  CompletableFuture&lt;Boolean&gt; existsFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line">  store.asyncGetCursorInfo(name, cursorName, new MetaStoreCallback&lt;MLDataFormats.ManagedCursorInfo&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(MLDataFormats.ManagedCursorInfo info, Stat stat) &#123;</span><br><span class="line">      existsFuture.complete(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operationFailed(MetaStoreException e) &#123;</span><br><span class="line">      log.info(&quot;vvv method &#123;&#125; open failed&quot;, &quot;recoverCursorFromZK&quot;);</span><br><span class="line">      existsFuture.complete(false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">    </span><br><span class="line">  try &#123;</span><br><span class="line">        &#x2F;&#x2F; 阻塞的原因是因为这条语句</span><br><span class="line">    if (!existsFuture.get()) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    log.error(&quot;vvv method recoverCursorFromZK error&quot;, e);</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; other code</span><br><span class="line">  </span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3. 问题解决"></a>3. 问题解决</h1><p>修改recoverCursorFromZK方法，把通过get进行任务执行完毕的判断改为confuture.thenAccept()。</p><h1 id="4-问题总结"><a href="#4-问题总结" class="headerlink" title="4. 问题总结"></a>4. 问题总结</h1><p>其实最后也没发现为什么出现资源竞争，好像就是在一个线程中使用CompletableFuture就出现了问题。</p><p>整个代码的逻辑是：</p><ul><li><p>通过zk查询数据，设置回调方法等待zk查询完成后执行。</p></li><li><p>zk查询完成后，通过唯一的线程执行回调方法，回调方法中就是future.complete()。</p></li><li><p>另外的线程开始执行同样的查询，回调方法同样是future.complete()，只不过还有其他线程调用了future.get()。</p></li></ul><p>流程就像下面这种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void testFuture() throws Exception &#123;</span><br><span class="line">  ExecutorService executor &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">  CompletableFuture&lt;Boolean&gt; f1 &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  new Thread(() -&gt; &#123;</span><br><span class="line">    CompletableFuture&lt;Boolean&gt; f2 &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">      sleep(1000);</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;f2 start&quot;);</span><br><span class="line">      f2.complete(true);</span><br><span class="line">      System.out.println(&quot;f2 done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">      sleep(1000);</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;f1 start&quot;);</span><br><span class="line">      f1.complete(true);</span><br><span class="line">      System.out.println(&quot;f1 done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).start();</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;init done&quot;);</span><br><span class="line">  f1.get();</span><br><span class="line">  System.out.println(&quot;run done&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sleep(int i) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar消费进度保存（二）</title>
      <link href="/2021/08/23/pulsar/pulsar%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E4%BF%9D%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/08/23/pulsar/pulsar%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E4%BF%9D%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文只针对persistent topic进行说明。</p></blockquote><h1 id="1-消息消费流程"><a href="#1-消息消费流程" class="headerlink" title="1. 消息消费流程"></a>1. 消息消费流程</h1><p>consumer和broker之间是通过TCP进行数据交互的，通信框架基于netty，数据格式是TLV结构，分为不包含负载的简单消息和包含负载的消息。</p><p>具体参考：<a href="https://pulsar.apache.org/docs/en/develop-binary-protocol/" target="_blank" rel="noopener">https://pulsar.apache.org/docs/en/develop-binary-protocol/</a></p><h2 id="1-1-简单消息（Simple-commands）"><a href="#1-1-简单消息（Simple-commands）" class="headerlink" title="1.1 简单消息（Simple commands）"></a>1.1 简单消息（Simple commands）</h2><table><thead><tr><th>名称</th><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>totalSize</td><td>4字节</td><td>消息总长度，不包含该字段。（单个消息的长度最长为5M）</td></tr><tr><td>commandSize</td><td>4字节</td><td>序列化消息的长度</td></tr><tr><td>message</td><td></td><td>序列化消息</td></tr></tbody></table><h2 id="1-2-内容消息（Payload-Message）"><a href="#1-2-内容消息（Payload-Message）" class="headerlink" title="1.2 内容消息（Payload Message）"></a>1.2 内容消息（Payload Message）</h2><p>这种类型的消息主要用于发布和传输消息。</p><p>其中message字段并不是用户自定义的消息内容，而是pulsar进行通信时内定的各种消息，已有的消息类型参考：</p><p><a href="https://github.com/apache/pulsar/blob/master/pulsar-common/src/main/proto/PulsarApi.proto" target="_blank" rel="noopener">https://github.com/apache/pulsar/blob/master/pulsar-common/src/main/proto/PulsarApi.proto</a></p><p>pulsar中的消息以前是基于google protobuf进行序列化的，之后为了节约空间和减少代码量（protobuf会生成很多代码…）使用lightproto（<a href="https://github.com/splunk/lightproto）进行序列化和反序列化。" target="_blank" rel="noopener">https://github.com/splunk/lightproto）进行序列化和反序列化。</a></p><table><thead><tr><th>名称</th><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>totalSize</td><td>4字节</td><td>消息总长度，不包含该字段。（单个消息的长度最长为5M）</td></tr><tr><td>commandSize</td><td>4字节</td><td>序列化消息的长度</td></tr><tr><td>message</td><td></td><td>序列化消息</td></tr><tr><td>magicNumber</td><td>2字节</td><td>用于校验消息，固定为0x0e01。有此标识的话就会进行CRC校验。</td></tr><tr><td>checksum</td><td>4字节</td><td>用于校验消息完整性。对该字段后边的消息进行CRC32-C计算。具体参考：1.2.1 CRC校验</td></tr><tr><td>metadataSize</td><td>4字节</td><td>元数据大小</td></tr><tr><td>metaData</td><td></td><td>元数据内容</td></tr><tr><td>payload</td><td></td><td>其他内容（用户消息）</td></tr></tbody></table><h3 id="1-2-1-CRC校验"><a href="#1-2-1-CRC校验" class="headerlink" title="1.2.1 CRC校验"></a>1.2.1 CRC校验</h3><p>从netty接收到类型为Message的消息后，会调用handleMessage方法，然后调用consumer的messageReceived方法，在此处进行CRC校验。</p><p>调用过程如下（只是列举了方法内的主要逻辑，代码并不完整）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PulsarDecoder -&gt; channelRead</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HAProxyMessage) &#123;</span><br><span class="line">        HAProxyMessage proxyMessage = (HAProxyMessage) msg;</span><br><span class="line">        <span class="keyword">this</span>.proxyMessage = proxyMessage;</span><br><span class="line">        proxyMessage.release();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get a buffer that contains the full frame</span></span><br><span class="line">    ByteBuf buffer = (ByteBuf) msg;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// De-serialize the command</span></span><br><span class="line">        <span class="keyword">int</span> cmdSize = (<span class="keyword">int</span>) buffer.readUnsignedInt();</span><br><span class="line">        cmd.parseFrom(buffer, cmdSize);</span><br><span class="line">        log.info(<span class="string">"vvv_msg_type "</span> + cmd.getType());</span><br><span class="line">        <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE: &#123;</span><br><span class="line">                checkArgument(cmd.hasMessage());</span><br><span class="line">                handleMessage(cmd.getMessage(), buffer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ClientCnx -&gt; handleMessage</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(CommandMessage cmdMessage, ByteBuf headersAndPayload)</span> </span>&#123;</span><br><span class="line">    checkArgument(state == State.Ready);</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"&#123;&#125; Received a message from the server: &#123;&#125;"</span>, ctx.channel(), cmdMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    ConsumerImpl&lt;?&gt; consumer = consumers.get(cmdMessage.getConsumerId());</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;Long&gt; ackSets = Collections.emptyList();</span><br><span class="line">        <span class="keyword">if</span> (cmdMessage.getAckSetsCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ackSets = <span class="keyword">new</span> ArrayList&lt;&gt;(cmdMessage.getAckSetsCount());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cmdMessage.getAckSetsCount(); i++) &#123;</span><br><span class="line">                ackSets.add(cmdMessage.getAckSetAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.messageReceived(cmdMessage.getMessageId(), cmdMessage.getRedeliveryCount(), ackSets, headersAndPayload, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConsumerImpl -&gt; messageReceived</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(MessageIdData messageId, <span class="keyword">int</span> redeliveryCount, List&lt;Long&gt; ackSet, ByteBuf headersAndPayload, ClientCnx cnx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"[&#123;&#125;][&#123;&#125;] Received message: &#123;&#125;/&#123;&#125;"</span>, topic, subscription, messageId.getLedgerId(),</span><br><span class="line">                  messageId.getEntryId());</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"headersAndPayload="</span> + headersAndPayload.readableBytes());</span><br><span class="line">    <span class="keyword">if</span> (!verifyChecksum(headersAndPayload, messageId)) &#123;</span><br><span class="line">        <span class="comment">// discard message with checksum error</span></span><br><span class="line">        discardCorruptedMessage(messageId, cnx, ValidationError.ChecksumMismatch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MessageMetadata msgMetadata;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msgMetadata = Commands.parseMessageMetadata(headersAndPayload);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        discardCorruptedMessage(messageId, cnx, ValidationError.ChecksumMismatch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConsumerImpl -&gt; verifyChecksum</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifyChecksum</span><span class="params">(ByteBuf headersAndPayload, MessageIdData messageId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasChecksum(headersAndPayload)) &#123;</span><br><span class="line">        <span class="keyword">int</span> checksum = Commands.readChecksum(headersAndPayload);</span><br><span class="line">        <span class="keyword">int</span> computedChecksum = Crc32cIntChecksum.computeChecksum(headersAndPayload);</span><br><span class="line">        <span class="keyword">if</span> (checksum != computedChecksum) &#123;</span><br><span class="line">            log.error(</span><br><span class="line">                <span class="string">"[&#123;&#125;][&#123;&#125;] Checksum mismatch for message at &#123;&#125;:&#123;&#125;. Received checksum: 0x&#123;&#125;, Computed checksum: 0x&#123;&#125;"</span>,</span><br><span class="line">                topic, subscription, messageId.getLedgerId(), messageId.getEntryId(),</span><br><span class="line">                Long.toHexString(checksum), Integer.toHexString(computedChecksum));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Commands -&gt; hasChecksum</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasChecksum</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// magicCrc32c == 0x0e01</span></span><br><span class="line">    <span class="keyword">return</span> buffer.getShort(buffer.readerIndex()) == magicCrc32c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-消息订阅和确认过程"><a href="#1-3-消息订阅和确认过程" class="headerlink" title="1.3 消息订阅和确认过程"></a>1.3 消息订阅和确认过程</h2><p>consumer和broker的交互是基于netty进行的，业务处理handler分别是ClientCnx和ServerCnx。</p><p>通过查看代码可以了解到consumer连接到broker，消费消息并返回确认的过程中会依次发送以下几种类型的消息：</p><p><img src="assets/640-20231008232701854.png" alt="图片"></p><p><strong>CONNECT</strong>：建立TCP连接，broker端确认client的权限，确认成功后返回CONNECTED。</p><p><strong>PATITIONED_METADATA</strong>：获取分区数据。由于分区实际上是通过虚拟topic实现的，所有在此阶段可以获取分区topic信息。</p><p><strong>LOOKUP</strong>：通过topic名称查找消息是哪一个broker处理的，返回broker的地址。</p><p><strong>SUBSCRIBE</strong>：consumer向返回的broker地址建立连接，发送topic、subscriptionName等信息，开始订阅消息。</p><p><strong>FLOW</strong>：consumer端发送消息获取请求，并告知broker自己可以接收的最大消息数量。</p><p><strong>MESSAGE</strong>：broker收到flow请求后，会从缓存或者bk中拉取最新的消息，在消息完成封装后发送给consumer。</p><p><strong>ACK</strong>：consumer接收并处理完消息后，发送消息消费确认通知（已消费消息的messageId）。</p><p><strong>CLOSE_CONSUMER</strong>：发送连接断开请求。</p><h1 id="2-订阅进度持久化"><a href="#2-订阅进度持久化" class="headerlink" title="2. 订阅进度持久化"></a>2. 订阅进度持久化</h1><ul><li>每一个topic的消息都是由唯一的一个broker负责写入的，所以能比较容易保证每条消息的ID是唯一的，这个ID也是pulsar消息的消费和确认标识。</li></ul><p>一个ID包含如下内容：</p><p>ledgerId：bk中每一个文件对应一个ledgerId，由bk维护。</p><p>entryId：在每一个ledger中递增，由bk维护。</p><p>partitionId：分区ID，由broker维护。</p><ul><li><p>在pulsar中，ManagedLedgerImpl用于用户消息的写入和读取，ManagedCursorImpl用于topic下每一个subscription的消费进度维护。</p></li><li><p>consumer收到broker发送的消息后，发送确认信息（messageId）给broker，broker收到后查找该subscription对应的ledger，如果存在则通过ledger写入到bk中；</p><p>如果不存在，则创建一个ledger并把ledger信息写入到zk中，然后通过创建后的ledger写入bk中。</p></li><li><p>zk中写入的数据包含cursorLedgerId、deletedLedgerId、deletedEntryId等信息，如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cursorsLedgerId&#x3D;-1, markDeleteLedgerId&#x3D;603, markDeleteEntryId&#x3D;15, lastActive&#x3D;1629692232349</span><br><span class="line">upper ledgerId&#x3D;603, upper entryId&#x3D;18, lower ledgerId&#x3D;603, lower entryId&#x3D;16</span><br><span class="line">upper ledgerId&#x3D;37740, upper entryId&#x3D;2, lower ledgerId&#x3D;37740, lower entryId&#x3D;1</span><br><span class="line">upper ledgerId&#x3D;37740, upper entryId&#x3D;4, lower ledgerId&#x3D;37740, lower entryId&#x3D;3</span><br></pre></td></tr></table></figure><p>uppper和lower用于处理不连续确认的情况。</p><p>而且，只有最新一个ledger的最新一个entry信息是有效的，broker初始化cursor信息时只会加载最新ledger的最近一条确认消息的entry中最新一条数据。</p><ul><li>bk中存储的数据内容：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lowLedgerId&#x3D;603, lowEntryId&#x3D;16, upperLedgerId&#x3D;603, upperEntryId&#x3D;18</span><br><span class="line">lowLedgerId&#x3D;37740, lowEntryId&#x3D;1, upperLedgerId&#x3D;37740, upperEntryId&#x3D;2</span><br><span class="line">lowLedgerId&#x3D;37740, lowEntryId&#x3D;3, upperLedgerId&#x3D;37740, upperEntryId&#x3D;4</span><br><span class="line">lowLedgerId&#x3D;37740, lowEntryId&#x3D;5, upperLedgerId&#x3D;37740, upperEntryId&#x3D;6</span><br></pre></td></tr></table></figure><p><strong>可以看到bk中数据主要记录确认情况，zk中记录确认情况在哪一个ledger以及哪些数据被标记为可删除了（被成功消费了）。</strong></p><ul><li><p>对于不连续确认的消息，会记录消息确认范围信息。从low - upper之前的所有消息都被消费成功了（左开右闭）。</p></li><li><p>因broker停掉或者其他原因导致cursor被关闭后，会把进度持久化到zk或者bk中。满足以下条件会保存到bk中：</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private boolean shouldPersistUnackRangesToLedger() &#123;</span><br><span class="line">    return cursorLedger !&#x3D; null</span><br><span class="line">        &amp;&amp; !isCursorLedgerReadOnly</span><br><span class="line">        &amp;&amp; config.getMaxUnackedRangesToPersist() &gt; 0</span><br><span class="line">        &amp;&amp; individualDeletedMessages.size() &gt; config.getMaxUnackedRangesToPersistInZk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-zk中消费进度解析"><a href="#2-1-zk中消费进度解析" class="headerlink" title="2.1 zk中消费进度解析"></a>2.1 zk中消费进度解析</h2><p>当客户端连接后，要获取该subscription的cursor信息，先从zk中查询，path如下：</p><p>/managed-ledgers/{tenant}/{namespace}/persistent/{topic}/{subscriptionName}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testZKMetaDataCursorInfo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/managed-ledgers/tenant_c/ns1/persistent/topic_cursor/consumer_002"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = getValue(path);</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"bytes is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MLDataFormats.ManagedCursorInfo info = MLDataFormats.ManagedCursorInfo.parseFrom(bytes);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.setLength(<span class="number">0</span>);</span><br><span class="line">    sb.append(<span class="string">"cursorsLedgerId="</span>).append(info.getCursorsLedgerId());</span><br><span class="line">    sb.append(<span class="string">", markDeleteLedgerId="</span>).append(info.getMarkDeleteLedgerId());</span><br><span class="line">    sb.append(<span class="string">", markDeleteEntryId="</span>).append(info.getMarkDeleteEntryId());</span><br><span class="line">    sb.append(<span class="string">", lastActive="</span>).append(info.getLastActive());</span><br><span class="line">    <span class="keyword">if</span> (info.getIndividualDeletedMessagesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MLDataFormats.MessageRange range : info.getIndividualDeletedMessagesList()) &#123;</span><br><span class="line">            sb.append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">" upper ledgerId="</span>).append(range.getUpperEndpoint().getLedgerId());</span><br><span class="line">            sb.append(<span class="string">", upper entryId="</span>).append(range.getUpperEndpoint().getEntryId());</span><br><span class="line">            sb.append(<span class="string">", lower ledgerId="</span>).append(range.getLowerEndpoint().getLedgerId());</span><br><span class="line">            sb.append(<span class="string">", lower entryId="</span>).append(range.getLowerEndpoint().getEntryId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"debug vv "</span> + sb);</span><br><span class="line">    System.out.println(<span class="string">"done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-bk中消费进度解析"><a href="#2-2-bk中消费进度解析" class="headerlink" title="2.2 bk中消费进度解析"></a>2.2 bk中消费进度解析</h2><p>如果从zk中查询的数据中，cursorLedger不等于-1，则会从bk中查询该ledger的数据，恢复进度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePulsarCursor</span><span class="params">(StringBuilder sb, LedgerEntry entry)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MLDataFormats.PositionInfo positionInfo = MLDataFormats.PositionInfo.parseFrom(entry.getEntryBytes());</span><br><span class="line">    <span class="comment">//        sb.append(", ledgerId=").append(positionInfo.getLedgerId());</span></span><br><span class="line">    <span class="comment">//        sb.append(", entryId=").append(positionInfo.getEntryId());</span></span><br><span class="line">    PositionImpl position = <span class="keyword">new</span> PositionImpl(positionInfo);</span><br><span class="line">    <span class="keyword">if</span> (positionInfo.getIndividualDeletedMessagesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        positionInfo.getIndividualDeletedMessagesList().forEach(messageRange -&gt; &#123;</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">            MLDataFormats.NestedPositionInfo point = messageRange.getLowerEndpoint();</span><br><span class="line">            sb.append(<span class="string">", lowLedgerId="</span>).append(point.getLedgerId());</span><br><span class="line">            sb.append(<span class="string">", lowEntryId="</span>).append(point.getEntryId());</span><br><span class="line">            point = messageRange.getUpperEndpoint();</span><br><span class="line">            sb.append(<span class="string">", upperLedgerId="</span>).append(point.getLedgerId());</span><br><span class="line">            sb.append(<span class="string">", upperEntryId="</span>).append(point.getEntryId());</span><br><span class="line">            log.info(sb.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"-----------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (positionInfo.getBatchedEntryDeletionIndexInfoCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        positionInfo.getBatchedEntryDeletionIndexInfoList().forEach(batchDeletedIndexInfo -&gt; &#123;</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (batchDeletedIndexInfo.getDeleteSetCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchDeletedIndexInfo.getDeleteSetList().size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">long</span> indexId = batchDeletedIndexInfo.getDeleteSetList().get(i);</span><br><span class="line">                    sb.append(<span class="string">", indexId="</span>).append(indexId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(sb.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"================="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-订阅进度恢复流程"><a href="#3-订阅进度恢复流程" class="headerlink" title="3. 订阅进度恢复流程"></a>3. 订阅进度恢复流程</h1><p>订阅进度保存在zk和bk中，这些信息会在broker加载topic信息的时候被恢复。</p><p>当producer和consumer连接到broker时，都会调用BrokerService的getTopic方法（分别在ServerCnx的handleProducer和handleSubscribe方法）。</p><p>由于brokerService是单例的，所以consumer和producer共用一组topic信息，然后通过topic实例关联ledger、cursor等信息。</p><p>在BrokerService中，topic实例创建过程：</p><ul><li>是否已经创建，如果是则直接返回。</li><li>该broker是否有topic的拥有权，如果没有则返回异常。</li><li>对创建过程进行加锁，获取到锁后开始创建topic实例（同一时刻，一个topic仅有一个创建任务），由如下参数控制并发创建数量：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return topics.computeIfAbsent(topic, (topicName) -&gt; &#123;</span><br><span class="line">        return this.loadOrCreatePersistentTopic(topicName, createIfMissing);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Max number of concurrent topic loading request broker allows to control number of zk-operations</span><br><span class="line"># 限制获取topic信息时，zk并发操作数量</span><br><span class="line">maxConcurrentTopicLoadRequest&#x3D;5000</span><br></pre></td></tr></table></figure><ul><li>在后续每一个流程中都会校验该topic是否由该broker负责。</li><li>判断ns中topic数量是否超过最大值，如果是则返回。</li><li>打开ledger。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; BrokerService -&gt; createPersistentTopic</span><br><span class="line">&#x2F;&#x2F; Once we have the configuration, we can proceed with the async open operation</span><br><span class="line">managedLedgerFactory.asyncOpen(topicName.getPersistenceNamingEncoding(), managedLedgerConfig, new OpenLedgerCallback())...</span><br></pre></td></tr></table></figure><ul><li>初始化ledger、bookeeper、cursor。</li><li>从zk中获取ledger信息。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ManagedLedgerImpl -&gt; synchronized void initialize(final ManagedLedgerInitializeLedgerCallback callback, final Object ctx)</span><br><span class="line">store.getManagedLedgerInfo(name, config.isCreateIfMissing(), new MetaStoreCallback&lt;ManagedLedgerInfo&gt;() &#123;</span><br></pre></td></tr></table></figure><p>从zk中获取cursor信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ManagedLedgerImpl -&gt; private void initializeCursors(final ManagedLedgerInitializeLedgerCallback callback)store.getCursors(name, new MetaStoreCallback&lt;List&lt;String&gt;&gt;() &#123;...</span><br></pre></td></tr></table></figure><p>恢复cursor内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">final</span> VoidCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Read the meta-data ledgerId from the store</span></span><br><span class="line">    log.info(<span class="string">"[&#123;&#125;] Recovering from bookkeeper ledger cursor: &#123;&#125;"</span>, ledger.getName(), name);</span><br><span class="line">    ledger.getStore().asyncGetCursorInfo(ledger.getName(), name, <span class="keyword">new</span> MetaStoreCallback&lt;ManagedCursorInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ManagedCursorInfo info, Stat stat)</span> </span>&#123;</span><br><span class="line">            cursorLedgerStat = stat;</span><br><span class="line">            lastActive = info.getLastActive() != <span class="number">0</span> ? info.getLastActive() : lastActive;</span><br><span class="line">            <span class="comment">// 如果zk中的cursorLedger是-1，则说明不需要从ledger中查询订阅进度，直接从zk中加载进度信息即可。</span></span><br><span class="line">            <span class="keyword">if</span> (info.getCursorsLedgerId() == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="comment">// There is no cursor ledger to read the last position from. It means the cursor has been properly</span></span><br><span class="line">                <span class="comment">// closed and the last mark-delete position is stored in the ManagedCursorInfo itself.</span></span><br><span class="line">                PositionImpl recoveredPosition = <span class="keyword">new</span> PositionImpl(info.getMarkDeleteLedgerId(),</span><br><span class="line">                                                                  info.getMarkDeleteEntryId());</span><br><span class="line">                <span class="keyword">if</span> (info.getIndividualDeletedMessagesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    recoverIndividualDeletedMessages(info.getIndividualDeletedMessagesList());</span><br><span class="line">                &#125;</span><br><span class="line">                Map&lt;String, Long&gt; recoveredProperties = Collections.emptyMap();</span><br><span class="line">                <span class="keyword">if</span> (info.getPropertiesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Recover properties map</span></span><br><span class="line">                    recoveredProperties = Maps.newHashMap();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info.getPropertiesCount(); i++) &#123;</span><br><span class="line">                        LongProperty property = info.getProperties(i);</span><br><span class="line">                        recoveredProperties.put(property.getName(), property.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                recoveredCursor(recoveredPosition, recoveredProperties, <span class="keyword">null</span>);</span><br><span class="line">                callback.operationComplete();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 需要从bk中加载消费进度信息。</span></span><br><span class="line">                <span class="comment">// Need to proceed and read the last entry in the specified ledger to find out the last position</span></span><br><span class="line">                log.info(<span class="string">"[&#123;&#125;] Consumer &#123;&#125; meta-data recover from ledger &#123;&#125;"</span>, ledger.getName(), name,</span><br><span class="line">                         info.getCursorsLedgerId());</span><br><span class="line">                recoverFromLedger(info, callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationFailed</span><span class="params">(MetaStoreException e)</span> </span>&#123;</span><br><span class="line">            callback.operationFailed(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从ledger中加载进度信息。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recoverFromLedger</span><span class="params">(<span class="keyword">final</span> ManagedCursorInfo info, <span class="keyword">final</span> VoidCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Read the acknowledged position from the metadata ledger, then create</span></span><br><span class="line">    <span class="comment">// a new ledger and write the position into it</span></span><br><span class="line">    ledger.mbean.startCursorLedgerOpenOp();</span><br><span class="line">    <span class="keyword">long</span> ledgerId = info.getCursorsLedgerId();</span><br><span class="line">    OpenCallback openCallback = (rc, lh, ctx) -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Read the last entry in the ledger</span></span><br><span class="line">        <span class="comment">// 读取最新一个位置</span></span><br><span class="line">        <span class="keyword">long</span> lastEntryInLedger = lh.getLastAddConfirmed();</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        lh.asyncReadEntries(lastEntryInLedger, lastEntryInLedger, (rc1, lh1, seq, ctx1) -&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 读取最后写入ledger的entry</span></span><br><span class="line">            LedgerEntry entry = seq.nextElement();</span><br><span class="line">            PositionInfo positionInfo;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                positionInfo = PositionInfo.parseFrom(entry.getEntry());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">                callback.operationFailed(<span class="keyword">new</span> ManagedLedgerException(e));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加载属性信息</span></span><br><span class="line">            Map&lt;String, Long&gt; recoveredProperties = Collections.emptyMap();</span><br><span class="line">            <span class="keyword">if</span> (positionInfo.getPropertiesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Recover properties map</span></span><br><span class="line">                recoveredProperties = Maps.newHashMap();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; positionInfo.getPropertiesCount(); i++) &#123;</span><br><span class="line">                    LongProperty property = positionInfo.getProperties(i);</span><br><span class="line">                    recoveredProperties.put(property.getName(), property.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            PositionImpl position = <span class="keyword">new</span> PositionImpl(positionInfo);</span><br><span class="line">            <span class="comment">// 如果有单独确认的消息（为了应对不是连续确认的情况）。</span></span><br><span class="line">            <span class="keyword">if</span> (positionInfo.getIndividualDeletedMessagesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                recoverIndividualDeletedMessages(positionInfo.getIndividualDeletedMessagesList());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (config.isDeletionAtBatchIndexLevelEnabled() &amp;&amp; batchDeletedIndexes != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; positionInfo.getBatchedEntryDeletionIndexInfoCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                recoverBatchDeletedIndexes(positionInfo.getBatchedEntryDeletionIndexInfoList());</span><br><span class="line">            &#125;</span><br><span class="line">            recoveredCursor(position, recoveredProperties, lh);</span><br><span class="line">            callback.operationComplete();</span><br><span class="line">        &#125;, <span class="keyword">null</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 打开一个新的ledger，并把进度信息写入新ledger中。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bookkeeper.asyncOpenLedger(ledgerId, digestType, config.getPassword(), openCallback, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">"[&#123;&#125;] Encountered error on opening cursor ledger &#123;&#125; for cursor &#123;&#125;"</span>,</span><br><span class="line">                  ledger.getName(), ledgerId, name, t);</span><br><span class="line">        openCallback.openComplete(BKException.Code.UnexpectedConditionException, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从ledger中加载单独确认的消息。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recoverIndividualDeletedMessages</span><span class="params">(List&lt;MLDataFormats.MessageRange&gt; individualDeletedMessagesList)</span> </span>&#123;</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        individualDeletedMessages.clear();</span><br><span class="line">        individualDeletedMessagesList.forEach(messageRange -&gt; &#123;</span><br><span class="line">            MLDataFormats.NestedPositionInfo lowerEndpoint = messageRange.getLowerEndpoint();</span><br><span class="line">            MLDataFormats.NestedPositionInfo upperEndpoint = messageRange.getUpperEndpoint();</span><br><span class="line">            <span class="comment">// 已确认的消息都在一个ledger内。</span></span><br><span class="line">            <span class="keyword">if</span> (lowerEndpoint.getLedgerId() == upperEndpoint.getLedgerId()) &#123;</span><br><span class="line">                individualDeletedMessages.addOpenClosed(lowerEndpoint.getLedgerId(), lowerEndpoint.getEntryId(),</span><br><span class="line">                                                        upperEndpoint.getLedgerId(), upperEndpoint.getEntryId());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已确认的消息在不同的ledger内，这时候需要加载每个ledger中已确认的消息。</span></span><br><span class="line">                <span class="comment">// Store message ranges after splitting them by ledger ID</span></span><br><span class="line">                LedgerInfo lowerEndpointLedgerInfo = ledger.getLedgersInfo().get(lowerEndpoint.getLedgerId());</span><br><span class="line">                <span class="keyword">if</span> (lowerEndpointLedgerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    individualDeletedMessages.addOpenClosed(lowerEndpoint.getLedgerId(), lowerEndpoint.getEntryId(),</span><br><span class="line">                                                            lowerEndpoint.getLedgerId(), lowerEndpointLedgerInfo.getEntries() - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">"[&#123;&#125;][&#123;&#125;] No ledger info of lower endpoint &#123;&#125;:&#123;&#125;"</span>, ledger.getName(), name,</span><br><span class="line">                             lowerEndpoint.getLedgerId(), lowerEndpoint.getEntryId());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 加载顺序是：</span></span><br><span class="line">                <span class="comment">// (lowerLedgerId, lowerEntryId) -&gt; (lowerLedgerId, -1)   第一条</span></span><br><span class="line">                <span class="comment">// (lowerLedgerId, -1) -&gt; (lowerLedgerId, -1)             中间部分</span></span><br><span class="line">                <span class="comment">// (upperLedgerId, -1) -&gt; (upperLedgerId, upperEntryId)   最后一条</span></span><br><span class="line">                <span class="keyword">for</span> (LedgerInfo li : ledger.getLedgersInfo()</span><br><span class="line">                     .subMap(lowerEndpoint.getLedgerId(), <span class="keyword">false</span>, upperEndpoint.getLedgerId(), <span class="keyword">false</span>).values()) &#123;</span><br><span class="line">                    individualDeletedMessages.addOpenClosed(li.getLedgerId(), -<span class="number">1</span>, li.getLedgerId(),</span><br><span class="line">                                                            li.getEntries() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                individualDeletedMessages.addOpenClosed(upperEndpoint.getLedgerId(), -<span class="number">1</span>,</span><br><span class="line">                                                        upperEndpoint.getLedgerId(), upperEndpoint.getEntryId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进度恢复完毕。</li></ul>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar消费进度研究（一）</title>
      <link href="/2021/08/20/pulsar/pulsar%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E7%A0%94%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/08/20/pulsar/pulsar%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E7%A0%94%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在pulsar中，使用ManagedCursorImpl来记录每个订阅的消息消费进度信息，每个cursor对应一个subscription。cursor的信息会记录到zookeeper中，同时pulsar也会把ack信息持久化到bookkeeper中。</p><p>通过阅读代码，了解到以下内容：</p><blockquote><p>1.从zk中/managed-ledgers/tenant_c/ns1/persistent/storeV3/consumer_002中查询cursor信息，保存在对象ManagedCursorInfo中，主要包含字段：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">message ManagedCursorInfo &#123;</span><br><span class="line">    &#x2F;&#x2F; If the ledger id is -1, then the mark-delete position is</span><br><span class="line">    &#x2F;&#x2F; the one from the (ledgerId, entryId) snapshot below</span><br><span class="line">    required int64 cursorsLedgerId &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; Last snapshot of the mark-delete position</span><br><span class="line">    optional int64 markDeleteLedgerId &#x3D; 2;</span><br><span class="line">    optional int64 markDeleteEntryId &#x3D; 3;</span><br><span class="line">    repeated MessageRange individualDeletedMessages &#x3D; 4;</span><br><span class="line">    &#x2F;&#x2F; Additional custom properties associated with</span><br><span class="line">    &#x2F;&#x2F; the current cursor position</span><br><span class="line">    repeated LongProperty properties &#x3D; 5;</span><br><span class="line">    optional int64 lastActive &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; Store which index in the batch message has been deleted</span><br><span class="line">    repeated BatchedEntryDeletionIndexInfo batchedEntryDeletionIndexInfo &#x3D; 7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.如果cursorsLedgerId字段为-1，表示记录确认信息的ledger已经被关闭，消费进度是markDeleteLedgerId和markDeleteEntryId字段。</p><p>3.如果cursorsLedgerId存在，则从记录确认消息的ledger中读取内容。</p></blockquote><blockquote><p>4.从ledger中获取最开始一次添加并确认的消息ID。bk中存储的内容格式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message PositionInfo &#123;</span><br><span class="line">    required int64 ledgerId &#x3D; 1;</span><br><span class="line">    required int64 entryId &#x3D; 2;</span><br><span class="line">    repeated MessageRange individualDeletedMessages &#x3D; 3;</span><br><span class="line">    &#x2F;&#x2F; Additional custom properties associated with</span><br><span class="line">    &#x2F;&#x2F; the current cursor position</span><br><span class="line">    repeated LongProperty properties &#x3D; 4;</span><br><span class="line">    &#x2F;&#x2F; Store which index in the batch message has been deleted</span><br><span class="line">    repeated BatchedEntryDeletionIndexInfo batchedEntryDeletionIndexInfo &#x3D; 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>5.如果有单独确认的消息，会读取内容并保存到individualDeletedMessages中。</p></blockquote><h3 id="broker重启后，消费者发送订阅请求，ledger和cursor恢复过程"><a href="#broker重启后，消费者发送订阅请求，ledger和cursor恢复过程" class="headerlink" title="broker重启后，消费者发送订阅请求，ledger和cursor恢复过程"></a>broker重启后，消费者发送订阅请求，ledger和cursor恢复过程</h3><p>ServerCnx：handleSubscribe</p><p>校验topic、认证</p><p>BrokerService：getTopic</p><p>如果topic存在，则从缓存中返回topic对象</p><p>如果topic不存在，且是持久化的topic，则调用loadOrCreatePersistentTopic加载或者创建一个topic对象</p><p>BrokerService：createPersistentTopic</p><p>获取该topic的ledger配置信息，并创建一个ledger</p><p>ManagedLedgerFactoryImpl：asyncOpen</p><p>如果ledger没有打开过，则创建一个新的ledger，并调用该ledger的initialize方法</p><p>ManagedLedgerImpl：initialize</p><p>从zk中获取ledger信息，初始化bk信息，初始化cursor信息。</p><p>ManagedLedgerImpl：initializeCursors</p><p>从zk中获取topic下有哪些订阅（/managed-ledgers/tenant_c/ns1/persistent/topic_cursor的children），然后依次初始化每一个sub。</p><p>针对每一个subscription创建一个cursor对象，同时对该cursor进行恢复。</p><p>从zk中获取cursor的信息，如果cursor的ledgerId为-1，则记录MarkDeletedLedgerId和MarkDeletedEntryId为订阅进度；</p><p>如果cursor的ledgerId不是-1，则开始读取bk中的进度数据，读取最新一条消息的entry，保存该entry的信息为订阅进度。</p><h3 id="broker打印日志如下"><a href="#broker打印日志如下" class="headerlink" title="broker打印日志如下"></a>broker打印日志如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 权限验证</span><br><span class="line">14:47:56.559 [pulsar-io-4-1] INFO  auth.server.VVPulsarAuthorizationProvider - vv_auth_v2 allowTopicOperationAsync, topicName persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor, role vv-role</span><br><span class="line"># 执行lookup阶段</span><br><span class="line">14:47:56.561 [pulsar-io-4-1] INFO  org.apache.pulsar.broker.service.ServerCnx - vvv_try_to_lookup,topicName: persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor, requestId: 2</span><br><span class="line"># 权限验证</span><br><span class="line">14:47:56.563 [pulsar-io-4-1] INFO  auth.server.VVPulsarAuthorizationProvider - vv_auth_v2 allowTopicOperationAsync, topicName persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor, role vv-role</span><br><span class="line"># 权限验证</span><br><span class="line">14:47:56.644 [pulsar-io-4-1] INFO  auth.server.VVPulsarAuthorizationProvider - vv_auth_v2 allowTopicOperationAsync, topicName persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor, role vv-role</span><br><span class="line"># consumer发送subscribe消息（注意的是创建ledger在subscribe之后，）</span><br><span class="line">14:47:56.644 [pulsar-io-4-1] INFO  org.apache.pulsar.broker.service.ServerCnx - vvv_subscribe, consumer_002 Subscribing on topic persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor</span><br><span class="line">14:47:56.646 [pulsar-io-4-1] INFO  org.apache.pulsar.broker.service.ServerCnx - [&#x2F;172.21.32.64:59676] Subscribing on topic persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor &#x2F; consumer_002</span><br><span class="line"># 这里由于broker刚重启，没有加载ledger信息，所以在consumer连接后才创建ledger对象</span><br><span class="line">14:47:56.640 [pulsar-ordered-OrderedExecutor-7-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerFactoryImpl - vv_cc asyncOpen, name&#x3D;tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor</span><br><span class="line"># 创建ledger</span><br><span class="line">14:47:56.667 [pulsar-ordered-OrderedExecutor-7-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - Opening managed ledger tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor</span><br><span class="line"># 从zk中获取ledger信息</span><br><span class="line">14:47:56.668 [pulsar-ordered-OrderedExecutor-7-0] INFO  org.apache.bookkeeper.mledger.impl.MetaStoreImpl - vvv_debug &#x2F;managed-ledgers&#x2F;tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor</span><br><span class="line">14:47:56.722 [BookKeeperClientWorker-OrderedExecutor-0-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Creating ledger, metadata: &#123;component&#x3D;[109, 97, 110, 97, 103, 101, 100, 45, 108, 101, 100, 103, 101, 114], pulsar&#x2F;managed-ledger&#x3D;[116, 101, 110, 97, 110, 116, 95, 99, 47, 110, 115, 49, 47, 112, 101, 114, 115, 105, 115, 116, 101, 110, 116, 47, 116, 111, 112, 105, 99, 95, 99, 117, 114, 115, 111, 114], application&#x3D;[112, 117, 108, 115, 97, 114]&#125; - metadata ops timeout : 60 seconds</span><br><span class="line"># ledger创建成功</span><br><span class="line">14:47:56.761 [BookKeeperClientWorker-OrderedExecutor-0-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Created ledger 603</span><br><span class="line"># 开始加载cursor信息</span><br><span class="line">14:47:56.778 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Loading cursor consumer_002</span><br><span class="line">14:47:56.792 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedCursorImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Recovering from bookkeeper ledger cursor: consumer_002</span><br><span class="line"># 从zk中获取之前保存的cursor信息，主要包含cursorLedgerId、markDeletedLedgerId和markDeletedEntryId</span><br><span class="line">14:47:56.792 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.MetaStoreImpl - vv_cc asyncGetCursorInfo, ledgerName&#x3D;tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor, cursorName&#x3D;consumer_002, path&#x3D;&#x2F;managed-ledgers&#x2F;tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor&#x2F;consumer_002</span><br><span class="line"># 开始恢复cursor</span><br><span class="line">14:47:56.798 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedCursorImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Cursor consumer_002 recovered to position 56:9</span><br><span class="line">14:47:56.800 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Recovery for cursor consumer_002 completed. pos&#x3D;56:9 -- todo&#x3D;0</span><br><span class="line"># cursor的恢复是在创建ledger的过程中进行的，cursor恢复后则ledger创建过程结束。</span><br><span class="line">14:47:56.801 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerFactoryImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Successfully initialize managed ledger</span><br><span class="line">14:47:56.808 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.pulsar.broker.service.AbstractTopic - Disabling publish throttling for persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor</span><br><span class="line">14:47:56.828 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.pulsar.broker.service.persistent.PersistentTopic - [persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor] There are no replicated subscriptions on the topic</span><br><span class="line">14:47:56.837 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.pulsar.broker.service.BrokerService - Created topic persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor - dedup is disabled</span><br><span class="line">14:47:56.843 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - Reset cursor:ManagedCursorImpl&#123;ledger&#x3D;tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor, name&#x3D;consumer_002, ackPos&#x3D;56:9, readPos&#x3D;56:10&#125; to 603:-1 since ledger consumed completely</span><br><span class="line">14:47:56.847 [BookKeeperClientWorker-OrderedExecutor-0-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Ledger 56 contains the current last confirmed entry 56:9, and it is going to be deleted</span><br><span class="line">14:47:56.858 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] End TrimConsumedLedgers. ledgers&#x3D;1 totalSize&#x3D;0</span><br><span class="line">14:47:56.858 [bookkeeper-ml-scheduler-OrderedScheduler-2-0] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor] Removing ledger 56 - size: 673</span><br><span class="line">14:47:57.251 [ForkJoinPool.commonPool-worker-5] INFO  org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl - vv_cc asyncOpenCursor, cursorName&#x3D;consumer_002</span><br><span class="line">14:47:57.262 [ForkJoinPool.commonPool-worker-5] INFO  org.apache.bookkeeper.mledger.impl.ManagedCursorImpl - [tenant_c&#x2F;ns1&#x2F;persistent&#x2F;topic_cursor-consumer_002] Rewind from 56:10 to 56:10</span><br><span class="line">14:47:57.263 [ForkJoinPool.commonPool-worker-5] INFO  org.apache.pulsar.broker.service.persistent.PersistentTopic - [persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor] There are no replicated subscriptions on the topic</span><br><span class="line">14:47:57.263 [ForkJoinPool.commonPool-worker-5] INFO  org.apache.pulsar.broker.service.persistent.PersistentTopic - [persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor][consumer_002] Created new subscription for 0</span><br><span class="line">14:47:57.264 [ForkJoinPool.commonPool-worker-5] INFO  org.apache.pulsar.broker.service.ServerCnx - [&#x2F;172.21.32.64:59676] Created subscription on topic persistent:&#x2F;&#x2F;tenant_c&#x2F;ns1&#x2F;topic_cursor &#x2F; consumer_002</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim命令</title>
      <link href="/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/Vim%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/Vim%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>文本信息配置</strong></p><p>set nu（写入配置文件.vimrc中） 显示行号。</p><p>ctrl-g（正常模式下使用命令） 显示文件信息和当前行。</p><p>statusline.vim（插件） 增加底部状态栏。</p><hr><p><strong>代码缩进配置</strong></p><p>filetype on（写入配置文件.vimrc中） 使vim对文件类型敏感。</p><p>autocmd FileType c,cpp,h :setlocal cindent cinoptions=:0,g0,t0（写入配置文件.vimrc中） 设置c缩进风格，具体详情参见:h cinoptions-values。</p><p>autocmd FileType c,cpp,h :setlocal et sta sw=4 sts=4 tabstop=4（写入配置文件.vimrc中） 设置一次缩进的距离是4个空格。</p><p>=（正常模式或者可视模式下使用命令） 按照缩进风格排版代码。</p><p>&lt;（可视模式下使用命令） 向左缩进一级。</p><p>&gt;（可视模式下使用命令） 向右缩进一级。</p><hr><p><strong>语法高亮</strong></p><p>filetype plugin on（写入配置文件.vimrc中） 通常安装的vim中已经加入了各种语言的语法高亮插件，我们只需要打开文件类型相关的插件就可以了。</p><hr><p><strong>快速定位</strong></p><p>gd（正常模式下使用命令） 跳转到局部变量定义处。</p><p>gD（正常模式下使用命令） 跳转到全局标量定义处。</p><p>*（正常模式下使用命令） 搜索并跳到下一个光标所在的单词。</p><p>g<em>（正常模式下使用命令） 功能接近</em>，但是查找的目标不带&lt;和&gt;单词分界符号。</p><p>#（正常模式下使用命令） 搜索并跳到上一个光标所在的单词。</p><p>g#（正常模式下使用命令） 功能接近#，但是查找的目标不带&lt;和&gt;单词分界符号。</p><hr><p><strong>标记位置</strong></p><p>m{a-zA-Z0-9} （正常模式下使用命令） 在当前位置制作一个标记，标记名字可以使用a-z或者A-Z之间的任意字符，例如输入ma，就是将当前位置标记为a标记。注意a-z为单文件标记，不可跨文件使用，而A-Z0-9为全局标记，可以跨文件使用。</p><p>‘{a-zA-Z0-9} （正常模式下使用命令） 跳转到本文件的标记上。</p><p>:marks [{a-zA-z0-9}] （正常模式下使用命令） 查看指定标记的内容，不写标记号则查看所有。</p><p>:delm {a-zA-z0-9} （正常模式下使用命令） 删除一个标记。</p><hr><p><strong>全文搜索</strong></p><p>:vimgrep（正常模式下使用命令） 全文搜索，功能同grep命令，但是支持在vim进行多文件跳转定位。</p><p>使用方法:vimgrep 正则表达式 文件。文件支持通配符，例如<em>.c代表所有的.c文件。如果希望递归搜索，可以使用*</em>/*，表示搜索所有的文件。</p><p>:cl 列举结果</p><p>:cc（正常模式下使用命令） 当前结果</p><p>:cn（正常模式下使用命令） 下一个结果</p><p>:cp（正常模式下使用命令） 上一个结果</p><p>:cw（正常模式下使用命令） 重新打开搜索结果窗口</p><hr><p><strong>多文件编辑</strong></p><p>vim f1 f2 …… fn（在shell下使用命令） 打开多个文件。</p><p>:e 文件名（正常模式下使用命令） 在vim中打开新文件。</p><p>:ls（正常模式下使用命令） 所有打开文件列表。</p><p>:bn（正常模式下使用命令） 到下一个文件。</p><p>:bp（正常模式下使用命令） 到上一个文件。</p><p>:b# 或 ctrl-6（正常模式下使用命令） 到最近的前一个文件。</p><p>set  autowriteall（写入配置文件.vimrc中） 如果讨厌每次打开新文件，vim喋喋不休的要求你保存，那么可以设置自动保存。</p><hr><p><strong>多窗口编辑</strong></p><p>:sp  文件名（正常模式下使用命令） 横向拆分窗口（多行窗口）。</p><p>:vsp 文件名（正常模式下使用命令） 纵向拆分窗口（多列窗口）。</p><p>ctrl-w h（正常模式下使用命令） 将光标移动到左一个窗口。</p><p>ctrl-w j（正常模式下使用命令） 将光标移动到下一个窗口。</p><p>ctrl-w k（正常模式下使用命令） 将光标移动到上一个窗口。</p><p>ctrl-w l（正常模式下使用命令） 将光标移动到右一个窗口。</p><p>ctrl-w +（正常模式下使用命令） 当前窗口尺寸变大。</p><p>ctrl-w -（正常模式下使用命令） 当前窗口尺寸变小。</p><p>ctrl-w o（正常模式下使用命令） 只显示当前窗口。</p><hr><p><strong>函数列表</strong></p><p>taglist.vim（插件） 列表插件。</p><p>let Tlist_Use_Right_Window = 1（写入配置文件.vimrc中） 如果希望列表在右侧显示，则加入这个配置，默认是左侧。</p><p>:Tlist（正常模式下使用命令） 显示函数列表。</p><p>d（在taglist窗口下使用） 从列表中删除文件。</p><p>+（在taglist窗口下使用） 展开文件。</p><p>-（在taglist窗口下使用） 折叠文件。</p><p>=（在taglist窗口下使用） 折叠所有文件。</p><p>x（在taglist窗口下使用） 显示或隐藏正常窗口。</p><hr><p><strong>文件列表</strong></p><p>NERD_tree.vim（插件） 横向拆分窗口（多行窗口）。</p><p>let NERDTreeWinPos = ‘right’（写入配置文件.vimrc中） 如果希望文件树在右侧显示，则加入这个配置，默认是左侧。</p><p>:NERDTree（正常模式下使用命令） 显示文件列表。</p><hr><p><strong>函数跳转</strong></p><p>ctags（软件，需要另外安装） 生成多种语言tag文件的软件。</p><p>Ctags –R *.c（在shell下使用命令） 生成当前路径所有.c文件的tag，-R代表递归。</p><p>:ta 标记 或 [g] ctrl-] 列举标签（多个标签）或者跳转到标签（单个标签）。</p><p>ctrl-t 返回上一级。</p><p>:tags 列出标签栈。</p><hr><p><strong>语法错误</strong></p><p>:make（正常模式下使用命令） 执行外部make命令，并且显示所有的编译警告和错误，并且可以在vim中定位。</p><p>:cl 列举结果</p><p>:cc（正常模式下使用命令） 当前结果</p><p>:cn（正常模式下使用命令） 下一个结果</p><p>:cp（正常模式下使用命令） 上一个结果</p><p>:cw（正常模式下使用命令） 重新打开搜索结果窗口</p><hr><p><strong>二进制文件查看 （鉴于有同学理解出现分歧 将二进制查看更新为二进制文件查看）</strong></p><p>:范围!xxd（正常模式下使用命令） 把指定范围的部分转化为二进制文件阅读方式。</p><p>:范围!xxd -r（正常模式下使用命令） 把指定范围的部分转回字符阅读方式。</p><hr><p><strong>字符集的编码</strong></p><p>let &amp;termencoding=&amp;encoding</p><p>set fileencodings=utf-8,gbk,cp936（写入配置文件.vimrc中）</p><p> 加入多种字符编码支持。</p><p>:set fileencoding（正常模式下使用命令） 设定文件字符编码。</p><hr><p><strong>补充</strong></p><p>ctrl-p（插入模式下使用命令） 跳出补全菜单。</p><p>ctrl-n（在跳出补全菜单后） 下一个结果。</p><p>ctrl-p（在跳出补全菜单后） 上一个结果。</p><p>ctrl-y（在跳出补全菜单后） 选择当前结果。</p><p>ctrl-x ctrl-f（插入模式下使用命令） 文件名补全。</p><p>ctrl-x ctrl-i（插入模式下使用命令） 包含的头文件。</p><p>ctrl-x ctrl-]（插入模式下使用命令） ctags（将在下文中介绍）符号补全。</p><p>ctrl-x ctrl-o（插入模式下使用命令） omni补全，需要设置omnifunc变量。</p><hr><p><strong>vim其他命令 （参考vi(vim)教程）</strong></p><p>打开文件、保存、关闭文件：</p><p>vi filename    //打开filename文件</p><p>:w    　　   //保存文件</p><p>:w vpser.net //保存至vpser.net文件</p><p>:q    　　  //退出编辑器，如果文件已修改请使用下面的命令</p><p>:q!    　　  //退出编辑器，且不保存</p><p>:wq         //退出编辑器，且保存文件</p><p>插入文本或行：</p><p>a    //在当前光标位置的右边添加文本</p><p>i    //在当前光标位置的左边添加文本</p><p>A   //在当前行的末尾位置添加文本</p><p>I    //在当前行的开始处添加文本(非空字符的行首)</p><p>O   //在当前行的上面新建一行</p><p>o   //在当前行的下面新建一行</p><p>R   //替换(覆盖)当前光标位置及后面的若干文本</p><p>J   //合并光标所在行及下一行为一行(依然在命令模式)</p><p>移动光标：</p><p>使用上下左右方向键</p><p>命令模式下：h  向左、j  向下 、k  向上、l  向右。</p><p>空格键 向右、Backspace  向左、Enter  移动到下一行首、- 移动到上一行首。</p><p>删除：</p><p>x     //删除当前字符</p><p>nx    //删除从光标开始的n个字符</p><p>dd    //删除当前行</p><p>ndd  //向下删除当前行在内的n行</p><p>u    //撤销上一步操作</p><p>U    //撤销对当前行的所有操作</p><p>搜索：</p><p>/vpser   //向光标下搜索vpser字符串</p><p>?vpser  //向光标上搜索vpser字符串</p><p>n      //向下搜索前一个搜素动作</p><p>N       //向上搜索前一个搜索动作</p><p>跳转：</p><p>n+     //向下跳n行</p><p>n-     //向上跳n行</p><p>nG     //跳到行号为n的行</p><p>G      //跳至文件的底部</p><p>设置行号：</p><p>:set  nu   //显示行号</p><p>:set nonu   //取消显示行号</p><p>复制：</p><p>yy   //将当前行复制到缓存区，也可以用 “ayy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。</p><p>nyy  //将当前行向下n行复制到缓冲区，也可以用 “anyy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。</p><p>yw   //复制从光标开始到词尾的字符。</p><p>nyw  //复制从光标开始的n个单词。</p><p>y^    //复制从光标到行首的内容。 </p><p>y$    //复制从光标到行尾的内容。</p><p>p     //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用”ap 进行粘贴。</p><p>P     //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用”aP 进行粘贴。</p><p>替换：</p><p>:s/old/new    //用new替换行中首次出现的old</p><p>:s/old/new/g     //用new替换行中所有的old</p><p>:n,m s/old/new/g   //用new替换从n到m行里所有的old</p><p>:%s/old/new/g    //用new替换当前文件里所有的old</p><p>编辑其他资源:</p><p>:e otherfilename   //编辑文件名为otherfilename的文件。</p><p>修改文件格式：</p><p>:set fileformat=unix  //将文件修改为unix格式，如win下面的文本文件在linux下会出现^M。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar负载均衡</title>
      <link href="/2021/08/10/pulsar/pulsar%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2021/08/10/pulsar/pulsar%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、动态分配"><a href="#一、动态分配" class="headerlink" title="一、动态分配"></a>一、动态分配</h3><p>pulsar本身是集群部署的，每个集群包含多个broker。当创建新的topic时，会根据各个broker的负载情况，选择一个相对空闲的broker节点负责新topic的消息发布和订阅。如果某个broker的负载过高或者broker挂掉，也会重新进行topic的分配。从而确保整个集群在一个相对均衡稳定的情况下运行。</p><p>整个分配过程是自动的，不需要外部干预。</p><p>而且，由于broker只负责接收和发送消息，不负责消息持久化，所有broker本身是无状态的，使得broker的管理和topic分配都变得相对简单。</p><h3 id="二、bundle"><a href="#二、bundle" class="headerlink" title="二、bundle"></a>二、bundle</h3><p>topic是消息发布订阅的最小粒度，在某些情况下会被频繁的创建、销毁，所有如果按照topic的粒度进行负载均衡会增加难度。因此，pulsar选择在namespace和topic之间虚构一层bundle，然后把topic分配到各个bundle中，以bunlde为粒度进行负载均衡。</p><p>默认情况下，一个namespace创建后会分配4个bunlde，每个bundle负责一个数字区间范围（0 - 0xFFFFFFFF），当有新的topic创建后，会对topic取hash，然后根据hash值把topic分配到某一个bundle下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 当命名空间创建时没有指定 bundle 数量时，将使用这个默认的值。defaultNumberOfNamespaceBundles&#x3D;4</span><br></pre></td></tr></table></figure><p>每个bunlde会被分配到一个broker上，需要重新分配时，会对整个bunlde进行移动。</p><p>bunlde的设置方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建ns2，设置bundle个数为16</span><br><span class="line">.&#x2F;pulsar-admin namespaces create tenant_vv&#x2F;ns2 --bundles 16</span><br><span class="line"># 查看bundle个数</span><br><span class="line">.&#x2F;pulsar-admin namespaces bundles tenant_vv&#x2F;ns2&#123;  &quot;boundaries&quot; : [ &quot;0x00000000&quot;, &quot;0x10000000&quot;, &quot;0x20000000&quot;, &quot;0x30000000&quot;, &quot;0x40000000&quot;, &quot;0x50000000&quot;, &quot;0x60000000&quot;, &quot;0x70000000&quot;, &quot;0x80000000&quot;, &quot;0x90000000&quot;, &quot;0xa0000000&quot;, &quot;0xb0000000&quot;, &quot;0xc0000000&quot;, &quot;0xd0000000&quot;, &quot;0xe0000000&quot;, &quot;0xf0000000&quot;, &quot;0xffffffff&quot; ],  &quot;numBundles&quot; : 16&#125;</span><br></pre></td></tr></table></figure><h3 id="三、bundle拆分"><a href="#三、bundle拆分" class="headerlink" title="三、bundle拆分"></a>三、bundle拆分</h3><p>通过hash方式可以把topic分配到某一个bundle上，通过增加bundle个数可以尽可能的让topic分配到不同的bundle上，从而让整个负载结果相对均衡。但如果topic的hash都很接近，或者一个bundle上topic的消息量特别大， 就会造成这个bundle压力过大，从而也造成处理该bundle的broker压力过大。</p><p>所以，pulsar支持对bundle进行拆分，拆分后的bundle会被重新分配。可以在conf/broker.conf中设置bundle拆分策略，具体如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启用&#x2F;禁用 自动拆分命名空间中的bundleloadBalancerAutoBundleSplitEnabled&#x3D;true# 启用&#x2F;禁用 自动卸载切分的bundleloadBalancerAutoUnloadSplitBundlesEnabled&#x3D;true# bundle 中最大的主题数, 一旦超过这个值，将触发拆分操作。loadBalancerNamespaceBundleMaxTopics&#x3D;1000# bundle 最大的session数量(生产 + 消费), 一旦超过这个值，将触发拆分操作。loadBalancerNamespaceBundleMaxSessions&#x3D;1000# bundle 最大的msgRate(进+出)的值, 一旦超过这个值，将触发拆分操作。loadBalancerNamespaceBundleMaxMsgRate&#x3D;30000# bundle 最大的带宽(进+出)的值, 一旦超过这个值，将触发拆分操作loadBalancerNamespaceBundleMaxBandwidthMbytes&#x3D;100# 命名空间中最大的 bundle 数量 (用于自动拆分bundle时)loadBalancerNamespaceMaximumBundles&#x3D;128</span><br></pre></td></tr></table></figure><h3 id="四、broker过载检测"><a href="#四、broker过载检测" class="headerlink" title="四、broker过载检测"></a>四、broker过载检测</h3><p>broker会根据cpu、网卡流量和内存判断是否过载，如果broker过载了，则会卸载上边的一些bundle。关于自动卸载的配置项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启用&#x2F;禁用自动负载拆分</span><br><span class="line">loadBalancerSheddingEnabled&#x3D;true</span><br><span class="line"># 负载切分时间间隔。Broker 定期检查，是否有一些流量需要从一些负载比较高的 broker，转移到负载较低的 broker 上。</span><br><span class="line">loadBalancerSheddingIntervalMinutes&#x3D;1</span><br><span class="line"># 防止同一个主题，在同一个时间窗口，被多次迁移的时间间隔。</span><br><span class="line">loadBalancerSheddingGracePeriodMinutes&#x3D;30</span><br><span class="line"># 使用阈值确定 broker 是否过载</span><br><span class="line">loadBalancerBrokerOverloadedThresholdPercentage&#x3D;85</span><br><span class="line"># 覆盖自动获取的网卡最大速度</span><br><span class="line"># 此选项在某些环境中是有用的(例如：EC2 VMs) ，因为Linux报告的网卡最大速度不是 broker 真实的值。</span><br><span class="line"># 因为负载管理器是根据网络使用情况来判断 broker 是否负载，为了确保信息是正确的，你可以通过这个参数来指定正确的值。这个配置值可以是一个 double 类型的值(比如: 0.8)。</span><br><span class="line"># 能够通过这个配置项在网卡带宽使用完之前，触发负载切分操作。</span><br><span class="line">loadBalancerOverrideBrokerNicSpeedGbps&#x3D;</span><br></pre></td></tr></table></figure><h3 id="五、相关代码处理逻辑"><a href="#五、相关代码处理逻辑" class="headerlink" title="五、相关代码处理逻辑"></a>五、相关代码处理逻辑</h3><p>关于负载均衡的代码在com.apache.pulsar.broker.loadbalance包下。</p><h4 id="1-PulsarService服务启动后，会初始化负载均衡的模块"><a href="#1-PulsarService服务启动后，会初始化负载均衡的模块" class="headerlink" title="1. PulsarService服务启动后，会初始化负载均衡的模块"></a>1. PulsarService服务启动后，会初始化负载均衡的模块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void startLeaderElectionService() &#123;</span><br><span class="line">    this.leaderElectionService &#x3D; new LeaderElectionService(coordinationService, getSafeWebServiceAddress(),</span><br><span class="line">        state -&gt; &#123;</span><br><span class="line">            if (state &#x3D;&#x3D; LeaderElectionState.Leading) &#123;</span><br><span class="line">                LOG.info(&quot;This broker was elected leader&quot;);</span><br><span class="line">                if (getConfiguration().isLoadBalancerEnabled()) &#123;</span><br><span class="line">                    long loadSheddingInterval &#x3D; TimeUnit.MINUTES</span><br><span class="line">                        .toMillis(getConfiguration().getLoadBalancerSheddingIntervalMinutes());</span><br><span class="line">                    long resourceQuotaUpdateInterval &#x3D; TimeUnit.MINUTES</span><br><span class="line">                        .toMillis(getConfiguration().getLoadBalancerResourceQuotaUpdateIntervalMinutes());</span><br><span class="line">                    if (loadSheddingTask !&#x3D; null) &#123;</span><br><span class="line">                        loadSheddingTask.cancel(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (loadResourceQuotaTask !&#x3D; null) &#123;</span><br><span class="line">                        loadResourceQuotaTask.cancel(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 启动两个定时任务</span><br><span class="line">                    loadSheddingTask &#x3D; loadManagerExecutor.scheduleAtFixedRate(</span><br><span class="line">                        new LoadSheddingTask(loadManager),</span><br><span class="line">                        loadSheddingInterval, loadSheddingInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">                    loadResourceQuotaTask &#x3D; loadManagerExecutor.scheduleAtFixedRate(</span><br><span class="line">                        new LoadResourceQuotaUpdaterTask(loadManager), resourceQuotaUpdateInterval,</span><br><span class="line">                        resourceQuotaUpdateInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (leaderElectionService !&#x3D; null) &#123;</span><br><span class="line">                    LOG.info(&quot;This broker is a follower. Current leader is &#123;&#125;&quot;,</span><br><span class="line">                        leaderElectionService.getCurrentLeader());</span><br><span class="line">                &#125;</span><br><span class="line">                if (loadSheddingTask !&#x3D; null) &#123;</span><br><span class="line">                    loadSheddingTask.cancel(false);</span><br><span class="line">                    loadSheddingTask &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (loadResourceQuotaTask !&#x3D; null) &#123;</span><br><span class="line">                    loadResourceQuotaTask.cancel(false);</span><br><span class="line">                    loadResourceQuotaTask &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    leaderElectionService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-负载均衡管理器选择"><a href="#2-负载均衡管理器选择" class="headerlink" title="2. 负载均衡管理器选择"></a>2. 负载均衡管理器选择</h4><p>pulsar提供了默认的负载均衡器，同时也支持自定义负载均衡策略。负载均衡管理模块LoadManager的初始化代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static LoadManager create(final PulsarService pulsar) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果配置文件中指定了自定义的均衡管理器，则使用自定义的。</span><br><span class="line">        final ServiceConfiguration conf &#x3D; pulsar.getConfiguration();</span><br><span class="line">        final Class&lt;?&gt; loadManagerClass &#x3D; Class.forName(conf.getLoadManagerClassName());</span><br><span class="line">        &#x2F;&#x2F; Assume there is a constructor with one argument of PulsarService.</span><br><span class="line">        final Object loadManagerInstance &#x3D; loadManagerClass.newInstance();</span><br><span class="line">        if (loadManagerInstance instanceof LoadManager) &#123;</span><br><span class="line">            final LoadManager casted &#x3D; (LoadManager) loadManagerInstance;</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            return casted;</span><br><span class="line">        &#125; else if (loadManagerInstance instanceof ModularLoadManager) &#123;</span><br><span class="line">            final LoadManager casted &#x3D; new ModularLoadManagerWrapper((ModularLoadManager) loadManagerInstance);</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            return casted;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.warn(&quot;Error when trying to create load manager: &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 使用内置的负载均衡器。</span><br><span class="line">    &#x2F;&#x2F; If we failed to create a load manager, default to SimpleLoadManagerImpl.</span><br><span class="line">    return new SimpleLoadManagerImpl(pulsar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果我们在配置文件中提供了自定义的加载管理器，则优先使用自定义的，否则使用默认的SimpleLoadManagerImpl类。</p><p>然后我们看下LoadManager提供的API：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LoadManager runs though set of load reports collected from different brokers and generates a recommendation of</span><br><span class="line"> * namespace&#x2F;ServiceUnit placement on machines&#x2F;ResourceUnit. Each Concrete Load Manager will use different algorithms to</span><br><span class="line"> * generate this mapping.</span><br><span class="line"> *</span><br><span class="line"> * Concrete Load Manager is also return the least loaded broker that should own the new namespace.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface LoadManager &#123;</span><br><span class="line">    Logger LOG &#x3D; LoggerFactory.getLogger(LoadManager.class);</span><br><span class="line">    String LOADBALANCE_BROKERS_ROOT &#x3D; &quot;&#x2F;loadbalance&#x2F;brokers&quot;;</span><br><span class="line">    void start() throws PulsarServerException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Is centralized decision making to assign a new bundle.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean isCentralized();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the Least Loaded Resource Unit decided by some algorithm or criteria which is implementation specific.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Optional&lt;ResourceUnit&gt; getLeastLoaded(ServiceUnitId su) throws Exception;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Generate the load report.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    LoadManagerReport generateLoadReport() throws Exception;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Set flag to force load report update.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setLoadReportForceUpdateFlag();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Publish the current load report on ZK.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void writeLoadReportOnZookeeper() throws Exception;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Publish the current load report on ZK, forced or not.</span><br><span class="line">     * By default rely on method writeLoadReportOnZookeeper().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default void writeLoadReportOnZookeeper(boolean force) throws Exception &#123;</span><br><span class="line">        writeLoadReportOnZookeeper();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Update namespace bundle resource quota on ZK.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void writeResourceQuotasToZooKeeper() throws Exception;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Generate load balancing stats metrics.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Metrics&gt; getLoadBalancingMetrics();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Unload a candidate service unit to balance the load.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void doLoadShedding();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Namespace bundle split.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void doNamespaceBundleSplit() throws Exception;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Removes visibility of current broker from loadbalancer list so, other brokers can&#39;t redirect any request to this</span><br><span class="line">     * broker and this broker won&#39;t accept new connection requests.</span><br><span class="line">     *</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void disableBroker() throws Exception;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get list of available brokers in cluster.</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Set&lt;String&gt; getAvailableBrokers() throws Exception;</span><br><span class="line">    void stop() throws PulsarServerException;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Initialize this LoadManager.</span><br><span class="line">     *</span><br><span class="line">     * @param pulsar</span><br><span class="line">     *            The service to initialize this with.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void initialize(PulsarService pulsar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，LoadManager提供了关于加载状态汇报、保存状态到zk、卸载服务以平衡加载、bundle拆分、停止broker和获取可用broker等api，方便我们对整个集群的加载进行管理和控制。</p><p>我们自己实现的加载管理器，需要采集各个broker节点的状态，然后根据topic和bundle信息，平均分配bundle到不同的broker上，确保各个broker的负载相对均衡。</p><h4 id="3-LoadSheddingTask（加载移除）"><a href="#3-LoadSheddingTask（加载移除）" class="headerlink" title="3. LoadSheddingTask（加载移除）"></a>3. LoadSheddingTask（加载移除）</h4><p>这个定时任务就是调用加载管理器的doLoadShedding方法，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        loadManager.get().doLoadShedding();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.warn(&quot;Error during the load shedding&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SimpleLoadManagerImpl中，是通过遍历所有broker汇报的bundle状态，找到其中过载的bundle，然后卸载掉。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pulsar.getAdminClient().namespaces().unloadNamespaceBundle(</span><br><span class="line">         LoadManagerShared.getNamespaceNameFromBundleName(bundleName),</span><br><span class="line">        LoadManagerShared.getBundleRangeFromBundleName(bundleName));</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="4-LoadResourceQuotaUpdaterTask"><a href="#4-LoadResourceQuotaUpdaterTask" class="headerlink" title="4. LoadResourceQuotaUpdaterTask"></a>4. LoadResourceQuotaUpdaterTask</h4><p>这个定时任务就是调用资源管理器的writeResourceQuatosToZookeeper把资源使用情况写入zk，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.loadManager.get().writeResourceQuotasToZooKeeper();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.warn(&quot;Error write resource quota&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、待研究问题"><a href="#六、待研究问题" class="headerlink" title="六、待研究问题"></a>六、待研究问题</h3><p>自定义均衡管理器需要注意哪些内容。</p><p>如何管理topic和bundle的分配策略。</p><p>是否可实现一个topic分配到多个bundle上，多个bundle分配到不同的broker上，数据存储不变，这样实现通过多个broker读取一个topic的数据。</p><h3 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h3><p><a href="https://pulsar.apache.org/docs/en/administration-load-balance/" target="_blank" rel="noopener">https://pulsar.apache.org/docs/en/administration-load-balance/</a></p><p><a href="https://pulsar.apache.org/docs/en/develop-load-manager/" target="_blank" rel="noopener">https://pulsar.apache.org/docs/en/develop-load-manager/</a></p>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读取和解析pulsar保存在bookkeeper上的消息</title>
      <link href="/2021/08/10/pulsar/%E8%AF%BB%E5%8F%96%E5%92%8C%E8%A7%A3%E6%9E%90pulsar%E4%BF%9D%E5%AD%98%E5%9C%A8bookkeeper%E4%B8%8A%E7%9A%84%E6%B6%88%E6%81%AF/"/>
      <url>/2021/08/10/pulsar/%E8%AF%BB%E5%8F%96%E5%92%8C%E8%A7%A3%E6%9E%90pulsar%E4%BF%9D%E5%AD%98%E5%9C%A8bookkeeper%E4%B8%8A%E7%9A%84%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>pulsar使用bk对消息进行持久化，为了实现只读broker，需要跨过pulsar直接连接bk读取消息。在bk中ledger是一个日志段，bk以ledger为粒度进行数据的多地备份，ledger包含多个entry，每个entry对应pulsar中的一条或者多条消息。</p><p>而pulsar每个topic在bk中的存储信息保存在zk中。即我们可以通过zk中获取特定topic的ledger信息，然后连接到bk，读取ledger下的每个entry的消息。具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tmp;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.BookKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.api.DigestType;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.api.LedgerEntries;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.api.LedgerEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.api.ReadHandle;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.common.api.proto.MessageMetadata;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.common.protocol.Commands;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/10 16:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BKMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(BKMain<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BKMain main = <span class="keyword">new</span> BKMain();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        load01();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">load01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// zookeeper地址</span></span><br><span class="line">        <span class="comment">// bk的信息保存在zk的/ledger路径</span></span><br><span class="line">        String connectionString = <span class="string">"x.x.x.x:2181"</span>;</span><br><span class="line">        BookKeeper bkClient = <span class="keyword">new</span> BookKeeper(connectionString);</span><br><span class="line">        <span class="comment">// 通过zk上/managed-ledgers/tenant_c/ns1/persistent/storeV2获取topic storeV2的ledgerId</span></span><br><span class="line">        <span class="keyword">long</span> ledgerId = <span class="number">56990</span>;</span><br><span class="line">        <span class="comment">// 设置加密方式和密码（同pulsar一样）</span></span><br><span class="line">        ReadHandle handle = bkClient.newOpenLedgerOp().withRecovery(<span class="keyword">false</span>).withLedgerId(ledgerId)</span><br><span class="line">                .withDigestType(DigestType.CRC32C).withPassword(<span class="string">""</span>.getBytes(Charsets.UTF_8)).execute().get();</span><br><span class="line">        <span class="comment">// 获取上一次被添加确认的entryId。则这个entryId之前的数据对外是可见的</span></span><br><span class="line">        <span class="keyword">long</span> id = handle.readLastAddConfirmed();</span><br><span class="line">        log.info(<span class="string">"id="</span> + id);</span><br><span class="line">        <span class="keyword">long</span> firstEntry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> lastEntry = id;</span><br><span class="line">        LedgerEntries entries = handle.read(firstEntry, lastEntry);</span><br><span class="line">        <span class="keyword">if</span> (entries != <span class="keyword">null</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="keyword">for</span> (LedgerEntry entry : entries) &#123;</span><br><span class="line">                ByteBuf buf = entry.getEntryBuffer();</span><br><span class="line">                <span class="comment">// 解析每一条消息（因为我们本身没有采用批量的方式发送消息，没有压缩，没有加密，而且指定的schema也是string，所以解析部分也很简单）</span></span><br><span class="line">                Commands.skipBrokerEntryMetadataIfExist(buf);</span><br><span class="line">                Commands.skipChecksumIfPresent(buf);</span><br><span class="line">                sb.setLength(<span class="number">0</span>);</span><br><span class="line">                sb.append(<span class="string">"ledgerId="</span>).append(entry.getLedgerId());</span><br><span class="line">                sb.append(<span class="string">", entryId="</span>).append(entry.getEntryId());</span><br><span class="line">                sb.append(<span class="string">", dataLen="</span>).append(entry.getLength() + buf.readableBytes());</span><br><span class="line">                MessageMetadata msgMetadata = Commands.parseMessageMetadata(buf);</span><br><span class="line">                sb.append(<span class="string">", numMessages="</span>).append(msgMetadata.getNumMessagesInBatch());</span><br><span class="line">                sb.append(<span class="string">", publishTime="</span>).append(msgMetadata.getPublishTime());</span><br><span class="line">                sb.append(<span class="string">", sequenceId="</span>).append(msgMetadata.getSequenceId());</span><br><span class="line">                <span class="comment">// 如果有些字段不是必须的，则需要先判断是否有该字段，否则解析会报错。</span></span><br><span class="line">                sb.append(<span class="string">", numChunks="</span>).append(msgMetadata.hasNumChunksFromMsg() ? msgMetadata.getNumChunksFromMsg() : <span class="number">0</span>);</span><br><span class="line">                sb.append(<span class="string">", replicateFrom="</span>).append(msgMetadata.hasReplicatedFrom() ? msgMetadata.getReplicatedFrom() : <span class="string">"none"</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] dataBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">                buf.readBytes(dataBytes);</span><br><span class="line">                sb.append(<span class="string">", data="</span>).append(<span class="keyword">new</span> String(dataBytes));</span><br><span class="line">                log.info(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            entries.close();</span><br><span class="line">        &#125;</span><br><span class="line">        handle.close();</span><br><span class="line">        bkClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ledgerId&#x3D;56990, entryId&#x3D;0, dataLen&#x3D;90, numMessages&#x3D;1, publishTime&#x3D;1628583539500, sequenceId&#x3D;0, numChunks&#x3D;0, replicateFrom&#x3D;none, data&#x3D;value 0</span><br><span class="line">ledgerId&#x3D;56990, entryId&#x3D;1, dataLen&#x3D;138, numMessages&#x3D;1, publishTime&#x3D;1628583539504, sequenceId&#x3D;1, numChunks&#x3D;0, replicateFrom&#x3D;none, data&#x3D;value 1</span><br><span class="line">ledgerId&#x3D;56990, entryId&#x3D;2, dataLen&#x3D;186, numMessages&#x3D;1, publishTime&#x3D;1628583539504, sequenceId&#x3D;2, numChunks&#x3D;0, replicateFrom&#x3D;none, data&#x3D;value 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar消息读流程（一</title>
      <link href="/2021/08/09/pulsar/pulsar%E6%B6%88%E6%81%AF%E8%AF%BB%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/08/09/pulsar/pulsar%E6%B6%88%E6%81%AF%E8%AF%BB%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大致介绍下pulsar的消息读的过程</p><p>consumer通过lookup命令查找到负责消费topic的broker地址，然后连接到该broker。broker接收到请求后，首先查找内存中有没有该订阅名称的consumer信息，如果有，则找到对应的subscription信息，然后建立和consumer的关系。之后从zk和bk中获取消息处理的ledger和对应的cursor。</p><p>然后consumer可以定时发送通知（sendFlowPermitsToBroker），broker接收到通知后就从ledger读消息返回给consumer。消息的发送是异步的，在handleFlow中处理consumer的通知，然后读取数据，读取完成后就发送给consumer。</p><h1 id="1-consumer端的处理流程"><a href="#1-consumer端的处理流程" class="headerlink" title="1. consumer端的处理流程"></a>1. consumer端的处理流程</h1><p>consumer的创建代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Consumer&lt;String&gt; c &#x3D; client.newConsumer(Schema.STRING)</span><br><span class="line">    .topic(topic)</span><br><span class="line">    .subscriptionName(&quot;subscription_001&quot;)</span><br><span class="line">    .receiverQueueSize(4)</span><br><span class="line">    .subscribe();</span><br><span class="line">Message&lt;String&gt; msg &#x3D; c.receive(5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>在subscribe后，会创建一个consumer对象，然后调用该对象的receive方法获取消息。</p><p><strong>ConsumerBase</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Message&lt;T&gt; receive(int timeout, TimeUnit unit) throws PulsarClientException &#123;</span><br><span class="line">    if (conf.getReceiverQueueSize() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        throw new PulsarClientException.InvalidConfigurationException(</span><br><span class="line">            &quot;Can&#39;t use receive with timeout, if the queue size is 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (listener !&#x3D; null) &#123;</span><br><span class="line">        throw new PulsarClientException.InvalidConfigurationException(</span><br><span class="line">            &quot;Cannot use receive() when a listener has been set&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    verifyConsumerState();</span><br><span class="line">    return internalReceive(timeout, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ConsumerImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Message&lt;T&gt; <span class="title">internalReceive</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> PulsarClientException </span>&#123;</span><br><span class="line">    Message&lt;T&gt; message;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先从缓存队列中获取，如果获取不到则直接返回。</span></span><br><span class="line">        message = incomingMessages.poll(timeout, unit);</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂时不返回消息，而是给broker发送通知，表示自己可以接收更多的消息了。</span></span><br><span class="line">        messageProcessed(message);</span><br><span class="line">        <span class="keyword">return</span> beforeConsume(message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        State state = getState();</span><br><span class="line">        <span class="keyword">if</span> (state != State.Closing &amp;&amp; state != State.Closed) &#123;</span><br><span class="line">            stats.incrementNumReceiveFailed();</span><br><span class="line">            <span class="keyword">throw</span> PulsarClientException.unwrap(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">messageProcessed</span><span class="params">(Message&lt;?&gt; msg)</span> </span>&#123;</span><br><span class="line">    ClientCnx currentCnx = cnx();</span><br><span class="line">    ClientCnx msgCnx = ((MessageImpl&lt;?&gt;) msg).getCnx();</span><br><span class="line">    lastDequeuedMessageId = msg.getMessageId();</span><br><span class="line">    <span class="keyword">if</span> (msgCnx != currentCnx) &#123;</span><br><span class="line">        <span class="comment">// The processed message did belong to the old queue that was cleared after reconnection.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        increaseAvailablePermits(currentCnx);</span><br><span class="line">        stats.updateNumMsgsReceived(msg);</span><br><span class="line">        trackMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    decreaseIncomingMessageSize(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx)</span> </span>&#123;</span><br><span class="line">    increaseAvailablePermits(currentCnx, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> available = AVAILABLE_PERMITS_UPDATER.addAndGet(<span class="keyword">this</span>, delta);</span><br><span class="line">    <span class="keyword">while</span> (available &gt;= receiverQueueRefillThreshold &amp;&amp; !paused) &#123;</span><br><span class="line">        <span class="comment">// 确保能发送一次通知</span></span><br><span class="line">        <span class="keyword">if</span> (AVAILABLE_PERMITS_UPDATER.compareAndSet(<span class="keyword">this</span>, available, <span class="number">0</span>)) &#123;</span><br><span class="line">            sendFlowPermitsToBroker(currentCnx, available);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            available = AVAILABLE_PERMITS_UPDATER.get(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * send the flow command to have the broker start pushing messages</span></span><br><span class="line"><span class="comment"> * 发送flow通知给broker，异步获取更多消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendFlowPermitsToBroker</span><span class="params">(ClientCnx cnx, <span class="keyword">int</span> numMessages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnx != <span class="keyword">null</span> &amp;&amp; numMessages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"[&#123;&#125;] [&#123;&#125;] Adding &#123;&#125; additional permits"</span>, topic, subscription, numMessages);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            cnx.ctx().writeAndFlush(Commands.newFlow(consumerId, numMessages))</span><br><span class="line">                .addListener(writeFuture -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!writeFuture.isSuccess()) &#123;</span><br><span class="line">                        log.debug(<span class="string">"Consumer &#123;&#125; failed to send &#123;&#125; permits to broker: &#123;&#125;"</span>, consumerId, numMessages,</span><br><span class="line">                                  writeFuture.cause().getMessage());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.debug(<span class="string">"Consumer &#123;&#125; sent &#123;&#125; permits to broker"</span>, consumerId, numMessages);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnx.ctx().writeAndFlush(Commands.newFlow(consumerId, numMessages), cnx.ctx().voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-broker端的处理流程"><a href="#2-broker端的处理流程" class="headerlink" title="2. broker端的处理流程"></a>2. broker端的处理流程</h1><p>和consumer交互的主要是ServerCnx中的handleConnect、handleSubscribe、handleFlow、handleAck四个方法，connect中处理认证信息，subscribe中获取订阅名称，保存订阅关系，flow中接收消息接收通知，触发从ledger中读取消息，ack中处理消息消费确认信息。</p><p>在broker中，每一个topic对应一个处理实例（PersistentTopic或者NonPersistentTopic），这个实例中保存topic信息和相关订阅信息（subscriptions）。</p><p>subscription本身是一个map变量，以SubscriptionName作为key，保存详细的订阅信息（即每一个订阅名称的所有客户端共享一组订阅信息，用于处理消息订阅的四种类型）。</p><p>在Subscription中有一个dispatcher变量，该变量直接存储所有的consumer信息。</p><p>所以，上述信息的存储关系链是：</p><p>topic -&gt; subscription -&gt; dispatcher -&gt; consumer</p><h2 id="2-1-zookeeper中存储的信息"><a href="#2-1-zookeeper中存储的信息" class="headerlink" title="2.1 zookeeper中存储的信息"></a>2.1 zookeeper中存储的信息</h2><p>消息订阅信息保存在zookeeper中的/managed_ledgers路径下，其中有两个重要的信息：ledger信息和cursor信息。</p><p>ledger存储topic消息在bk中的信息，cursor存储消费者读取进度，在zk中的路径分别是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;managed_ledgers&#x2F;&#123;tenant&#125;&#x2F;&#123;namespace&#125;&#x2F;persistent&#x2F;&#123;topic&#125;</span><br><span class="line">&#x2F;managed_ledgers&#x2F;&#123;tenant&#125;&#x2F;&#123;namespace&#125;&#x2F;persistent&#x2F;&#123;topic&#125;&#x2F;&#123;subscription_name&#125;</span><br></pre></td></tr></table></figure><p>在zk中的这部分信息可以直接解析出来，测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testZKMetaData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/managed-ledgers/tenant_c/ns1/persistent/topic_name"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = getValue(path);</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"bytes is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MLDataFormats.ManagedLedgerInfo info = MLDataFormats.ManagedLedgerInfo.parseFrom(bytes);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (MLDataFormats.ManagedLedgerInfo.LedgerInfo ls : info.getLedgerInfoList()) &#123;</span><br><span class="line">        sb.setLength(<span class="number">0</span>);</span><br><span class="line">        sb.append(<span class="string">"ledgerId="</span>).append(ls.getLedgerId());</span><br><span class="line">        sb.append(<span class="string">", entries="</span>).append(ls.getEntries());</span><br><span class="line">        sb.append(<span class="string">", size="</span>).append(ls.getSize());</span><br><span class="line">        sb.append(<span class="string">", timestamp="</span>).append(ls.getTimestamp());</span><br><span class="line">        System.out.println(<span class="string">"debug vv "</span> + sb);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testZKMetaDataCursorInfo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/managed-ledgers/tenant_c/ns1/persistent/topic_name/subscription_name_0"</span>;</span><br><span class="line">    path = <span class="string">"/managed-ledgers/tenant_c/ns1/persistent/topic_name/subscription_name_1"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = getValue(path);</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"bytes is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MLDataFormats.ManagedCursorInfo info = MLDataFormats.ManagedCursorInfo.parseFrom(bytes);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.setLength(<span class="number">0</span>);</span><br><span class="line">    sb.append(<span class="string">"markDeleteLedgerId="</span>).append(info.getMarkDeleteLedgerId());</span><br><span class="line">    sb.append(<span class="string">", markDeleteEntryId="</span>).append(info.getMarkDeleteEntryId());</span><br><span class="line">    sb.append(<span class="string">", lastActive="</span>).append(info.getLastActive());</span><br><span class="line">    System.out.println(<span class="string">"debug vv "</span> + sb);</span><br><span class="line">    System.out.println(<span class="string">"done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] getValue(String path) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    ZooKeeper zoo = <span class="keyword">new</span> ZooKeeper(<span class="string">"x.x.x.x:2181"</span>, <span class="number">10000</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"state "</span> + event.getState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = zoo.getData(path, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    zoo.close();</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testZKMetaData输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug vv ledgerId&#x3D;56929, entries&#x3D;10, size&#x3D;710, timestamp&#x3D;1628234384802</span><br><span class="line">debug vv ledgerId&#x3D;56933, entries&#x3D;10, size&#x3D;720, timestamp&#x3D;1628235295486</span><br><span class="line">debug vv ledgerId&#x3D;56937, entries&#x3D;10, size&#x3D;710, timestamp&#x3D;1628240968389</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug vv markDeleteLedgerId&#x3D;56933, markDeleteEntryId&#x3D;9, lastActive&#x3D;1628236717415</span><br><span class="line">debug vv markDeleteLedgerId&#x3D;56937, markDeleteEntryId&#x3D;2, lastActive&#x3D;1628240766897</span><br></pre></td></tr></table></figure><h2 id="2-2-ManagedLedgerInfo和ManagedCursorInfo结构"><a href="#2-2-ManagedLedgerInfo和ManagedCursorInfo结构" class="headerlink" title="2.2 ManagedLedgerInfo和ManagedCursorInfo结构"></a>2.2 ManagedLedgerInfo和ManagedCursorInfo结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * &quot;License&quot;); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *   http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing,</span><br><span class="line"> * software distributed under the License is distributed on an</span><br><span class="line"> * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span><br><span class="line"> * KIND, either express or implied.  See the License for the</span><br><span class="line"> * specific language governing permissions and limitations</span><br><span class="line"> * under the License.</span><br><span class="line"> *&#x2F;</span><br><span class="line">syntax &#x3D; &quot;proto2&quot;;</span><br><span class="line">option java_package &#x3D; &quot;org.apache.bookkeeper.mledger.proto&quot;;</span><br><span class="line">option optimize_for &#x3D; SPEED;</span><br><span class="line">message KeyValue &#123;</span><br><span class="line">    required string key &#x3D; 1;</span><br><span class="line">    required string value &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">message OffloadDriverMetadata &#123;</span><br><span class="line">    required string name &#x3D; 1;</span><br><span class="line">    repeated KeyValue properties &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">message OffloadContext &#123;</span><br><span class="line">    optional int64 uidMsb &#x3D; 1;</span><br><span class="line">    optional int64 uidLsb &#x3D; 2;</span><br><span class="line">    optional bool complete &#x3D; 3;</span><br><span class="line">    optional bool bookkeeperDeleted &#x3D; 4;</span><br><span class="line">    optional int64 timestamp &#x3D; 5;</span><br><span class="line">    optional OffloadDriverMetadata driverMetadata &#x3D; 6;</span><br><span class="line">    repeated OffloadSegment offloadSegment &#x3D; 7;</span><br><span class="line">&#125;</span><br><span class="line">message OffloadSegment &#123;</span><br><span class="line">    optional int64 uidMsb &#x3D; 1;</span><br><span class="line">    optional int64 uidLsb &#x3D; 2;</span><br><span class="line">    optional bool complete &#x3D; 3;</span><br><span class="line">    optional int64 assignedTimestamp &#x3D; 4; &#x2F;&#x2F;timestamp in millisecond</span><br><span class="line">    optional int64 offloadedTimestamp &#x3D; 5; &#x2F;&#x2F;timestamp in millisecond</span><br><span class="line">    optional int64 endEntryId &#x3D; 6;</span><br><span class="line">    optional OffloadDriverMetadata driverMetadata &#x3D; 7;</span><br><span class="line">&#125;</span><br><span class="line">message ManagedLedgerInfo &#123;</span><br><span class="line">    message LedgerInfo &#123;</span><br><span class="line">        required int64 ledgerId &#x3D; 1;</span><br><span class="line">        optional int64 entries &#x3D; 2;</span><br><span class="line">        optional int64 size &#x3D; 3;</span><br><span class="line">        optional int64 timestamp &#x3D; 4;</span><br><span class="line">        optional OffloadContext offloadContext &#x3D; 5;</span><br><span class="line">    &#125;</span><br><span class="line">  repeated LedgerInfo ledgerInfo &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; If present, it signals the managed ledger has been</span><br><span class="line">    &#x2F;&#x2F; terminated and this was the position of the last</span><br><span class="line">    &#x2F;&#x2F; committed entry.</span><br><span class="line">    &#x2F;&#x2F; No more entries can be written.</span><br><span class="line">    optional NestedPositionInfo terminatedPosition &#x3D; 2;</span><br><span class="line">    repeated KeyValue properties &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line">message PositionInfo &#123;</span><br><span class="line">    required int64 ledgerId &#x3D; 1;</span><br><span class="line">    required int64 entryId &#x3D; 2;</span><br><span class="line">    repeated MessageRange individualDeletedMessages &#x3D; 3;</span><br><span class="line">    &#x2F;&#x2F; Additional custom properties associated with</span><br><span class="line">    &#x2F;&#x2F; the current cursor position</span><br><span class="line">    repeated LongProperty properties &#x3D; 4;</span><br><span class="line">    &#x2F;&#x2F; Store which index in the batch message has been deleted</span><br><span class="line">    repeated BatchedEntryDeletionIndexInfo batchedEntryDeletionIndexInfo &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">message NestedPositionInfo &#123;</span><br><span class="line">    required int64 ledgerId &#x3D; 1;</span><br><span class="line">    required int64 entryId  &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">message MessageRange &#123;</span><br><span class="line">    required NestedPositionInfo lowerEndpoint &#x3D; 1;</span><br><span class="line">    required NestedPositionInfo upperEndpoint &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">message BatchedEntryDeletionIndexInfo &#123;</span><br><span class="line">    required NestedPositionInfo position &#x3D; 1;</span><br><span class="line">    repeated int64 deleteSet &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Generic string and long tuple</span><br><span class="line">message LongProperty &#123;</span><br><span class="line">    required string name &#x3D; 1;</span><br><span class="line">    required int64 value  &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">message ManagedCursorInfo &#123;</span><br><span class="line">    &#x2F;&#x2F; If the ledger id is -1, then the mark-delete position is</span><br><span class="line">    &#x2F;&#x2F; the one from the (ledgerId, entryId) snapshot below</span><br><span class="line">    required int64 cursorsLedgerId &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; Last snapshot of the mark-delete position</span><br><span class="line">    optional int64 markDeleteLedgerId &#x3D; 2;</span><br><span class="line">    optional int64 markDeleteEntryId &#x3D; 3;</span><br><span class="line">    repeated MessageRange individualDeletedMessages &#x3D; 4;</span><br><span class="line">    &#x2F;&#x2F; Additional custom properties associated with</span><br><span class="line">    &#x2F;&#x2F; the current cursor position</span><br><span class="line">    repeated LongProperty properties &#x3D; 5;</span><br><span class="line">    optional int64 lastActive &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; Store which index in the batch message has been deleted</span><br><span class="line">    repeated BatchedEntryDeletionIndexInfo batchedEntryDeletionIndexInfo &#x3D; 7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-判断topic是属于哪一个broker"><a href="#2-3-判断topic是属于哪一个broker" class="headerlink" title="2.3 判断topic是属于哪一个broker"></a>2.3 判断topic是属于哪一个broker</h2><p>通过topic查找bundle，然后判断bundle是否属于broker。</p><p>OwnershipCache中的ownershipReadOnlyCache：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private CompletableFuture&lt;Optional&lt;Map.Entry&lt;NamespaceEphemeralData, Stat&gt;&gt;&gt; resolveOwnership(String path) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过缓存的zk信息，找到该path(topic全路径)对应的的bundle信息</span><br><span class="line">    return ownershipReadOnlyCache.getWithStatAsync(path).thenApply(optionalOwnerDataWithStat -&gt; &#123;</span><br><span class="line">        if (optionalOwnerDataWithStat.isPresent()) &#123;</span><br><span class="line">            Map.Entry&lt;NamespaceEphemeralData, Stat&gt; ownerDataWithStat &#x3D; optionalOwnerDataWithStat.get();</span><br><span class="line">            Stat stat &#x3D; ownerDataWithStat.getValue();</span><br><span class="line">            if (stat.getEphemeralOwner() &#x3D;&#x3D; localZkCache.getZooKeeper().getSessionId()) &#123;</span><br><span class="line">                LOG.info(&quot;Successfully reestablish ownership of &#123;&#125;&quot;, path);</span><br><span class="line">                OwnedBundle ownedBundle &#x3D; new OwnedBundle(ServiceUnitUtils.suBundleFromPath(path, bundleFactory));</span><br><span class="line">                if (selfOwnerInfo.getNativeUrl().equals(ownerDataWithStat.getKey().getNativeUrl())) &#123;</span><br><span class="line">                    ownedBundlesCache.put(path, CompletableFuture.completedFuture(ownedBundle));</span><br><span class="line">                &#125;</span><br><span class="line">                ownershipReadOnlyCache.invalidate(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return optionalOwnerDataWithStat;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ul><li>consumer可以随机连上一个broker，通过发送lookup命令可以最终找到一个处理所需topic的broker地址，然后连接到该broker。</li><li>broker接收到consumer连接后，建立好topic - subscription - dispatcher - consumer的关系，同时打开ledger和cursor，准备消息的读写。</li><li>consumer建立好连接后，不定时的发送flow命令，通知broker可以发送更多的消息了，broker接收到命令后，通过ledger读取消息并异步发送给consumer。</li></ul>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar对消息进行加密</title>
      <link href="/2021/08/06/pulsar/pulsar%E5%AF%B9%E6%B6%88%E6%81%AF%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/"/>
      <url>/2021/08/06/pulsar/pulsar%E5%AF%B9%E6%B6%88%E6%81%AF%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pular支持对消息的传输过程进行加密，加密方式有两种：一种是直接使用TLS，一种是基于加密算法进行数据加密。</p><p>本文主要是记录下基于加密算法进行加密的方法。</p></blockquote><h1 id="1-加解密的流程"><a href="#1-加解密的流程" class="headerlink" title="1. 加解密的流程"></a>1. 加解密的流程</h1><p>pulsar使用AES对数据进行加密，AES的密钥和消息一起转发，并且AES密钥使用ECDSA/RSA进行加密。</p><p>如果使用pulsar的加密功能，需要先生成一对密钥：公钥、私钥。生产者使用公钥对AES密钥进行加密，消费者使用私钥对AES密钥进行解密。</p><p>由于pulsar本身是不存储密钥的，所以如果生产者和消费者丢失了密钥，则数据就永远不能解密了。</p><p>下面分别是生产者加密流程和消费者解密流程：</p><p><img src="assets/640-20231008224629933.png" alt="图片"></p><p><img src="assets/640-20231008224629923.png" alt="图片"></p><h1 id="2-具体实现方式"><a href="#2-具体实现方式" class="headerlink" title="2. 具体实现方式"></a>2. 具体实现方式</h1><h2 id="2-1-使用openssl生成密钥对"><a href="#2-1-使用openssl生成密钥对" class="headerlink" title="2.1 使用openssl生成密钥对"></a>2.1 使用openssl生成密钥对</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ecparam -name secp521r1 -genkey -param_enc explicit -out test_ecdsa_privkey.pem</span><br><span class="line">openssl ec -in test_ecdsa_privkey.pem -pubout -outform pkcs8 -out test_ecdsa_pubkey.pem</span><br></pre></td></tr></table></figure><p>2.2 实现CryptoKeyReader接口，用于pulsar获取密钥</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> encrypt;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.CryptoKeyReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.EncryptionKeyInfo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 9:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RawFileKeyReader</span> <span class="keyword">implements</span> <span class="title">CryptoKeyReader</span> </span>&#123;</span><br><span class="line">    String publicKeyFile = <span class="string">"F:\\download\\test_ecdsa_pubkey.pem"</span>;</span><br><span class="line">    String privateKeyFile = <span class="string">"F:\\download\\test_ecdsa_privkey.pem"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EncryptionKeyInfo <span class="title">getPublicKey</span><span class="params">(String keyName, Map&lt;String, String&gt; metadata)</span> </span>&#123;</span><br><span class="line">        EncryptionKeyInfo info = <span class="keyword">new</span> EncryptionKeyInfo();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"getPublicKey"</span>);</span><br><span class="line">            info.setKey(Files.readAllBytes(<span class="keyword">new</span> File(publicKeyFile).toPath()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EncryptionKeyInfo <span class="title">getPrivateKey</span><span class="params">(String keyName, Map&lt;String, String&gt; metadata)</span> </span>&#123;</span><br><span class="line">        EncryptionKeyInfo info = <span class="keyword">new</span> EncryptionKeyInfo();</span><br><span class="line">        System.out.println(<span class="string">"getPrivateKey"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            info.setKey(Files.readAllBytes(<span class="keyword">new</span> File(privateKeyFile).toPath()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-编写生产者和消费者进行测试"><a href="#2-3-编写生产者和消费者进行测试" class="headerlink" title="2.3 编写生产者和消费者进行测试"></a>2.3 编写生产者和消费者进行测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> encrypt;</span><br><span class="line"><span class="keyword">import</span> auth.client.VVAuthentication;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 8:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(EncryptTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EncryptTest main = <span class="keyword">new</span> EncryptTest();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line">    String topic = <span class="string">"persistent://tenant_c/ns1/topic1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PulsarClient client = PulsarClient.builder()</span><br><span class="line">                .authentication(<span class="keyword">new</span> VVAuthentication())</span><br><span class="line">                .serviceUrl(<span class="string">"pulsar://172.20.140.11:6650"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        produce(client);</span><br><span class="line">        consume(client);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Producer p = client.newProducer()</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .producerName(<span class="string">"pro_encrypt"</span>)</span><br><span class="line">                <span class="comment">// 设置AES密钥，如果不设置则不会对消息加密</span></span><br><span class="line">                .addEncryptionKey(<span class="string">"vv_01"</span>)</span><br><span class="line">                <span class="comment">// 设置从哪获取公钥/私钥</span></span><br><span class="line">                .cryptoKeyReader(<span class="keyword">new</span> RawFileKeyReader())</span><br><span class="line">                .create();</span><br><span class="line">        MessageId id = p.newMessage(Schema.STRING).key(<span class="string">"key-1"</span>).value(<span class="string">"hello world"</span>).send();</span><br><span class="line">        p.flush();</span><br><span class="line">        log.info(<span class="string">"send "</span> + id);</span><br><span class="line">        p.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Consumer c = client.newConsumer()</span><br><span class="line">                .subscriptionName(<span class="string">"con_encrypt"</span>)</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .cryptoKeyReader(<span class="keyword">new</span> RawFileKeyReader())</span><br><span class="line">                .subscribe();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Message msg = c.receive(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c.acknowledge(msg);</span><br><span class="line">            log.info(<span class="string">"receive "</span> + msg.getKey() + <span class="string">", "</span> + <span class="keyword">new</span> String(msg.getData()));</span><br><span class="line">        &#125;</span><br><span class="line">        c.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getPublicKey</span><br><span class="line">12:29:21.462 [main] INFO  encrypt.EncryptTest - send 56925:3:-1</span><br><span class="line">getPrivateKey</span><br><span class="line">12:29:21.535 [main] INFO  encrypt.EncryptTest - receive key-1, hello world</span><br></pre></td></tr></table></figure><p>可以看到在生产者端使用公钥对AES密钥加密，在消费者端使用私钥对AES密钥进行解密。</p><p><strong>生产者设置数据加密密钥：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Add public encryption key, used by producer to encrypt the data key.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;At the time of producer creation, Pulsar client checks if there are keys added to encryptionKeys. If keys are</span><br><span class="line">  * found, a callback &#123;@link CryptoKeyReader#getPrivateKey(String, Map)&#125; and</span><br><span class="line">  * &#123;@link CryptoKeyReader#getPublicKey(String, Map)&#125; is invoked against each key to load the values of the key.</span><br><span class="line">  * Application should implement this callback to return the key in pkcs8 format. If compression is enabled, message</span><br><span class="line">  * is encrypted after compression. If batch messaging is enabled, the batched message is encrypted.</span><br><span class="line">  *</span><br><span class="line">  * @param key</span><br><span class="line">  *            the name of the encryption key in the key store</span><br><span class="line">  * @return the producer builder instance</span><br><span class="line">  *&#x2F;</span><br><span class="line"> ProducerBuilder&lt;T&gt; addEncryptionKey(String key);</span><br></pre></td></tr></table></figure><p>当生产者创建时，pulsar客户端检查是否添加了密钥，如果找到了就回调CryptoKeyReader的方法获取公钥/私钥。应用需要实现CryptoKeyReader的方法，并返回pkcs8格式的密钥。如果消息开启了压缩，则消息会在压缩后被加密。如果消息是批量发送的，则消息被打包后会被加密。</p>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证和授权(3)</title>
      <link href="/2021/08/05/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(3)/"/>
      <url>/2021/08/05/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认证和授权流程"><a href="#1-认证和授权流程" class="headerlink" title="1. 认证和授权流程"></a>1. 认证和授权流程</h1><p>认证和授权需要一个第三方用户管理中心，该管理中心的功能包含以下几点：</p><ol><li>提供用户注册和管理。</li><li>提供tenant、namespace、topic的创建和管理。</li><li>提供用户信息和权限的验证接口。</li></ol><p>当新增一个业务时，需要创建对应的用户，然后使用该用户创建tenant、namespace和topic。然后客户端可以携带用户名/密码连接到broker，broker到管理中心验证用户是否有效，拉取用户的权限并保存到本地，之后对客户端的操作进行权限的验证。</p><p>整体流程：</p><p><img src="assets/640-20231007110807330.png" alt="图片"></p><p>上述设计的核心是把tenant、namespace、topic的看作一种资源，消息的发布和订阅看作是对资源的使用，认证和授权的方案设计就可以分成两部分：</p><ol><li>对资源的管理权限</li><li>对资源的使用权限</li></ol><p>其中，对资源的管理权限可以由用户中心去做，可以创建用户，给用户分配资源和使用权限，同时也可以给用户创建子用户，给子用户分配主用户权限下的资源等。用户中心的输出就是&lt;角色，权限&gt;的集合，把这个集合提供给broker，这样broker就可以根据这个集合判断用户的操作是否合法。</p><h1 id="2-数据表设计"><a href="#2-数据表设计" class="headerlink" title="2. 数据表设计"></a>2. 数据表设计</h1><table><thead><tr><th>表名</th><th>含义</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>sys_user_info</td><td>用户信息表</td><td>配置用户信息</td><td></td></tr><tr><td>sys_service_group</td><td>业务分组表</td><td>用户属于某一个业务</td><td></td></tr><tr><td>sys_role</td><td>角色表</td><td>用角色进行权限的控制</td><td></td></tr><tr><td>sys_user_role_map</td><td>用户和角色关系表</td><td>用户和角色之间的关系，一个用户可能属于多个角色</td><td></td></tr><tr><td>res_cluster</td><td>集群表</td><td>配置ADMQ集群信息，包含名称、地址等</td><td></td></tr><tr><td>res_tenant</td><td>租户表</td><td>配置集群下的租户信息</td><td></td></tr><tr><td>res_namespace</td><td>命名空间表</td><td>配置租户下的namespace信息</td><td></td></tr><tr><td>res_topic</td><td>topic表</td><td>配置namespace下的topic信息</td><td></td></tr><tr><td>sys_role_res</td><td>角色和资源权限关系表</td><td>配置角色和资源之间的关系和对应的权限</td><td></td></tr><tr><td>sys_authority</td><td>权限配置表</td><td>配置资源权限字典</td><td></td></tr></tbody></table><h2 id="2-1-用户信息表"><a href="#2-1-用户信息表" class="headerlink" title="2.1 用户信息表"></a>2.1 用户信息表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>用户ID</td><td>bigint(20)</td><td>主键递增</td></tr><tr><td>username</td><td>用户名称</td><td>varchar(128)</td><td></td></tr><tr><td>nick</td><td>昵称</td><td>varchar(128)</td><td></td></tr><tr><td>passwd</td><td>用户密码</td><td>varchar(128)</td><td>加密后</td></tr><tr><td>service_group</td><td>业务分组</td><td>bigint(20)</td><td></td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>update_time</td><td>修改时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr></tbody></table><h2 id="2-2-业务分组表"><a href="#2-2-业务分组表" class="headerlink" title="2.2 业务分组表"></a>2.2 业务分组表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>组ID</td><td>bigint(20)</td><td>主键递增</td></tr><tr><td>group_name</td><td>分组名称</td><td>varchar(128)</td><td></td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>update_time</td><td>修改时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr></tbody></table><h2 id="2-3-角色表"><a href="#2-3-角色表" class="headerlink" title="2.3 角色表"></a>2.3 角色表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>组ID</td><td>bigint(20)</td><td>主键递增</td></tr><tr><td>role_name</td><td>角色名称</td><td>varchar(128)</td><td></td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>update_time</td><td>修改时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr></tbody></table><h2 id="2-4-用户和角色关系表"><a href="#2-4-用户和角色关系表" class="headerlink" title="2.4 用户和角色关系表"></a>2.4 用户和角色关系表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>user_id</td><td>用户id</td><td>bigint(20)</td><td></td></tr><tr><td>role_id</td><td>角色id</td><td>bigint(20)</td><td></td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr></tbody></table><h2 id="1-5-集群表"><a href="#1-5-集群表" class="headerlink" title="1.5 集群表"></a>1.5 集群表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>组ID</td><td>bigint(20)</td><td>主键递增</td></tr><tr><td>name</td><td>集群名称</td><td>varchar(128)</td><td></td></tr><tr><td>address</td><td>集群地址</td><td>varchar(128)</td><td></td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>update_time</td><td>修改时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr></tbody></table><h2 id="1-6-租户表"><a href="#1-6-租户表" class="headerlink" title="1.6 租户表"></a>1.6 租户表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>组ID</td><td>bigint(20)</td><td>主键递增</td></tr><tr><td>clusters</td><td>所属集群</td><td>varchar(128)</td><td>可以属于多个集群</td></tr><tr><td>name</td><td>名称</td><td>varchar(128)</td><td></td></tr><tr><td>is_valid</td><td>是否有效</td><td>int(2)</td><td>1：有效，2：无效</td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>update_time</td><td>修改时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr></tbody></table><h2 id="1-7-命名空间表"><a href="#1-7-命名空间表" class="headerlink" title="1.7 命名空间表"></a>1.7 命名空间表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>组ID</td><td>bigint(20)</td><td>主键递增</td></tr><tr><td>tenant</td><td>租户ID</td><td>bigint(20)</td><td></td></tr><tr><td>name</td><td>名称</td><td>varchar(128)</td><td></td></tr><tr><td>is_valid</td><td>是否有效</td><td>int(2)</td><td>1：有效，2：无效</td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>update_time</td><td>修改时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr></tbody></table><h2 id="1-8-topic表"><a href="#1-8-topic表" class="headerlink" title="1.8 topic表"></a>1.8 topic表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>组ID</td><td>bigint(20)</td><td>主键递增</td></tr><tr><td>tenant</td><td>租户ID</td><td>bigint(20)</td><td></td></tr><tr><td>namespace</td><td>命名空间ID</td><td>bigint(20)</td><td></td></tr><tr><td>name</td><td>名称</td><td>varchar(128)</td><td></td></tr><tr><td>is_valid</td><td>是否有效</td><td>int(2)</td><td>1：有效，2：无效</td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>update_time</td><td>修改时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr></tbody></table><h2 id="1-9-角色和资源权限关系表"><a href="#1-9-角色和资源权限关系表" class="headerlink" title="1.9 角色和资源权限关系表"></a>1.9 角色和资源权限关系表</h2><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>role_id</td><td>角色ID</td><td>bigint(20)</td><td></td></tr><tr><td>res_type</td><td>资源类型</td><td>int(11)</td><td>1：cluster2：tenant3：namespace4：topic</td></tr><tr><td>res_id</td><td>资源ID</td><td>bigint(20)</td><td></td></tr><tr><td>authorities</td><td>权限列表</td><td>varchar(128)</td><td>逗号隔开</td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>1.10 权限配置表</p><table><thead><tr><th><strong>名称</strong></th><th><strong>含义</strong></th><th><strong>类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>主键</td><td>int(11)</td><td></td></tr><tr><td>desc</td><td>权限描述</td><td>varchar(256)</td><td></td></tr><tr><td>add_time</td><td>添加时间</td><td>bigint(20)</td><td></td></tr><tr><td>remark</td><td>备注信息</td><td>varchar(256)</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>目前支持的几种权限：</strong></p><table><thead><tr><th>ID</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>100</td><td>创建tenant</td><td></td></tr><tr><td>101</td><td>删除tenant</td><td></td></tr><tr><td>102</td><td>tenant下所有topic的写权限</td><td></td></tr><tr><td>103</td><td>tenant下所有topic的读权限</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>创建namespace</td><td></td></tr><tr><td>201</td><td>删除namespace</td><td></td></tr><tr><td>202</td><td>namespace下所有topic的写权限</td><td></td></tr><tr><td>203</td><td>namespace下所有topic的读权限</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>创建topic</td><td></td></tr><tr><td>301</td><td>删除topic</td><td></td></tr><tr><td>302</td><td>topic的写权限</td><td></td></tr><tr><td>303</td><td>topic的读权限</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar失败重试（negativeAckRedeliveryDelay）的解释</title>
      <link href="/2021/08/04/pulsar/pulsar%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%EF%BC%88negativeAckRedeliveryDelay%EF%BC%89%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2021/08/04/pulsar/pulsar%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%EF%BC%88negativeAckRedeliveryDelay%EF%BC%89%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在pulsar讨论群里看到关于这个api的问题，然后就去看了代码，了解了其功能和详细处理逻辑，在此记录下。</p></blockquote><h1 id="1-消息发布订阅流程"><a href="#1-消息发布订阅流程" class="headerlink" title="1. 消息发布订阅流程"></a>1. 消息发布订阅流程</h1><p><img src="assets/image-20231008221757348.png" alt="image-20231008221757348"></p><p>如上图所示，消费者收到消息并返回确认后，broker端就认为这条消息被成功转发了。但是consumer端接收到消息后可能会处理失败，导致没有发送确认给broker。broker端有一个未确认消息队列，这个队列达到一定大小后就会阻塞，这时broker就不会继续发送消息给consumer，也不会重复发送以前未确认的消息给consumer。如果consumer和broker断开连接了，未确认的消息就又会重新发送给consumer了。</p><p>这时候有人看到negativeAckRedeliveryDelay，猜想是不是可以设置重复消费消息，即当一定时间内没有确认后能再次接收到该消息。然后我看过代码后发现确实是能实现的，实现方式是handler回复消费失败后，把失败的消息发送给broker，broker再发送给consumer。</p><h1 id="2-关于消息重复发送的解释"><a href="#2-关于消息重复发送的解释" class="headerlink" title="2. 关于消息重复发送的解释"></a>2. 关于消息重复发送的解释</h1><p><img src="assets/image-20231008221819464.png" alt="image-20231008221819464"></p><p>broker发送Msg01给consumer1，consumer1在handle中处理失败，调用negativeAcknowledge方法，发送处理失败的消息信息给broker，broker收到后再选择发送给consumer1或者consumer2.</p><p>其中两个重要的API：</p><p><strong>ConsumerBuilder，用于设置多长时间后再次收到处理失败的消息。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConsumerBuilder&lt;T&gt; ackTimeoutTickTime(long tickTime, TimeUnit timeUnit);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Set the delay to wait before re-delivering messages that have failed to be process.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;When application uses &#123;@link Consumer#negativeAcknowledge(Message)&#125;, the failed message</span><br><span class="line">     * will be redelivered after a fixed timeout. The default is 1 min.</span><br><span class="line">     *</span><br><span class="line">     * @param redeliveryDelay</span><br><span class="line">     *            redelivery delay for failed messages</span><br><span class="line">     * @param timeUnit</span><br><span class="line">     *            unit in which the timeout is provided.</span><br><span class="line">     * @return the consumer builder instance</span><br><span class="line">     * @see Consumer#negativeAcknowledge(Message)</span><br><span class="line">     *&#x2F;</span><br><span class="line"> ConsumerBuilder&lt;T&gt; negativeAckRedeliveryDelay(long redeliveryDelay, TimeUnit timeUnit);</span><br></pre></td></tr></table></figure><p><strong>Consumer，用于通知broker自己处理消息失败了。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Acknowledge the failure to process a single message.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;When a message is &quot;negatively acked&quot; it will be marked for redelivery after</span><br><span class="line">     * some fixed delay. The delay is configurable when constructing the consumer</span><br><span class="line">     * with &#123;@link ConsumerBuilder#negativeAckRedeliveryDelay(long, TimeUnit)&#125;.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This call is not blocking.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Example of usage:</span><br><span class="line">     * &lt;pre&gt;&lt;code&gt;</span><br><span class="line">     * while (true) &#123;</span><br><span class="line">     *     Message&lt;String&gt; msg &#x3D; consumer.receive();</span><br><span class="line">     *</span><br><span class="line">     *     try &#123;</span><br><span class="line">     *          &#x2F;&#x2F; Process message...</span><br><span class="line">     *</span><br><span class="line">     *          consumer.acknowledge(msg);</span><br><span class="line">     *     &#125; catch (Throwable t) &#123;</span><br><span class="line">     *          log.warn(&quot;Failed to process message&quot;);</span><br><span class="line">     *          consumer.negativeAcknowledge(msg);</span><br><span class="line">     *     &#125;</span><br><span class="line">     * &#125;</span><br><span class="line">     * &lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param message</span><br><span class="line">     *            The &#123;@code Message&#125; to be acknowledged</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void negativeAcknowledge(Message&lt;?&gt; message);</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><p>测试的思路是：</p><ol><li>编写两个客户端，同时订阅一份数据。</li><li>在第一个客户端里返回无效确认，第二个客户端里返回有效确认。</li><li>确认第一个客户端返回取消确认的消息是否能被第二个客户端收到。</li></ol><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ack;</span><br><span class="line"><span class="keyword">import</span> auth.client.VVAuthentication;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/4 16:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedeliverTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(RedeliverTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RedeliverTest main = <span class="keyword">new</span> RedeliverTest();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line">    String topic = <span class="string">"persistent://tenant_vv/ns1/redeliver_test"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; consumer(<span class="keyword">true</span>, latch)).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确保第一个消费者先收到消息</span></span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; consumer(<span class="keyword">false</span>, latch)).start();</span><br><span class="line">        produce();</span><br><span class="line">        log.info(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PulsarClient client = newClient()) &#123;</span><br><span class="line">            Producer p = client.newProducer()</span><br><span class="line">                    .topic(topic)</span><br><span class="line">                    .create();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">                p.newMessage(Schema.STRING).value(<span class="string">"data_"</span> + i).key(<span class="string">"sub mode "</span>+ i).sendAsync();</span><br><span class="line">            &#125;</span><br><span class="line">            p.flush();</span><br><span class="line">            p.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">boolean</span> replay, CountDownLatch latch)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PulsarClient client = newClient()) &#123;</span><br><span class="line">            String tag = <span class="string">"replay_mode_"</span> + replay;</span><br><span class="line">            Consumer c = client.newConsumer(Schema.STRING)</span><br><span class="line">                    .topic(topic)</span><br><span class="line">                    <span class="comment">// 设置消息处理失败后，2秒后再此收到消息。</span></span><br><span class="line">                    .negativeAckRedeliveryDelay(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .subscriptionType(SubscriptionType.Shared)</span><br><span class="line">                    .subscriptionName(<span class="string">"sub_name"</span>)</span><br><span class="line">                    .subscribe();</span><br><span class="line">            latch.countDown();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Message&lt;String&gt; msg = c.receive(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (replay) &#123;</span><br><span class="line">                    c.negativeAcknowledge(msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c.acknowledge(msg);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(tag + <span class="string">" receive "</span> + msg.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            c.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PulsarClient <span class="title">newClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PulsarClient client = PulsarClient.builder()</span><br><span class="line">                .serviceUrl(<span class="string">"pulsar://x.x.x.x:6650"</span>)</span><br><span class="line">                .authentication(<span class="keyword">new</span> VVAuthentication())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16:52:56.639 [Thread-1] INFO  ack.RedeliverTest - replay_mode_true receive data_0</span><br><span class="line">16:52:56.639 [Thread-1] INFO  ack.RedeliverTest - replay_mode_true receive data_1</span><br><span class="line">16:52:58.660 [Thread-3] INFO  ack.RedeliverTest - replay_mode_false receive data_0</span><br><span class="line">16:52:58.660 [Thread-3] INFO  ack.RedeliverTest - replay_mode_false receive data_1</span><br></pre></td></tr></table></figure><p>可以看到，第一个客户端收到消息并调用negativeAcknowledge返回无效确认后，第二个客户端在2秒后能收到消息了，并且消息是有序的。</p><h1 id="4-涉及到的主要代码"><a href="#4-涉及到的主要代码" class="headerlink" title="4. 涉及到的主要代码"></a>4. 涉及到的主要代码</h1><p>主要逻辑是，consumer处理失败后，把失败的消息通知给broker，broker把失败消息缓存起来，标记为需要重新发送的消息，然后每次发送消息给消费者的时候检查是否有需要重发的消息，如果有的话就发送。</p><h2 id="4-1-ConsumerImpl"><a href="#4-1-ConsumerImpl" class="headerlink" title="4.1 ConsumerImpl"></a>4.1 ConsumerImpl</h2><p>保存消息并等待发送</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">negativeAcknowledge</span><span class="params">(MessageId messageId)</span> </span>&#123;</span><br><span class="line">    negativeAcksTracker.add(messageId);</span><br><span class="line">    <span class="comment">// Ensure the message is not redelivered for ack-timeout, since we did receive an "ack"</span></span><br><span class="line">    unAckedMessageTracker.remove(messageId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用接收消息的netty channel发送失败消息通知给broker</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redeliverUnacknowledgedMessages</span><span class="params">(Set&lt;MessageId&gt; messageIds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (messageIds.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    checkArgument(messageIds.stream().findFirst().get() <span class="keyword">instanceof</span> MessageIdImpl);</span><br><span class="line">    <span class="keyword">if</span> (conf.getSubscriptionType() != SubscriptionType.Shared</span><br><span class="line">        &amp;&amp; conf.getSubscriptionType() != SubscriptionType.Key_Shared) &#123;</span><br><span class="line">        <span class="comment">// We cannot redeliver single messages if subscription type is not Shared</span></span><br><span class="line">        redeliverUnacknowledgedMessages();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ClientCnx cnx = cnx();</span><br><span class="line">    <span class="keyword">if</span> (isConnected() &amp;&amp; cnx.getRemoteEndpointProtocolVersion() &gt;= ProtocolVersion.v2.getValue()) &#123;</span><br><span class="line">        <span class="keyword">int</span> messagesFromQueue = removeExpiredMessagesFromQueue(messageIds);</span><br><span class="line">        Iterable&lt;List&lt;MessageIdImpl&gt;&gt; batches = Iterables.partition(</span><br><span class="line">            messageIds.stream()</span><br><span class="line">            .map(messageId -&gt; (MessageIdImpl)messageId)</span><br><span class="line">            .collect(Collectors.toSet()), MAX_REDELIVER_UNACKNOWLEDGED);</span><br><span class="line">        batches.forEach(ids -&gt; &#123;</span><br><span class="line">            getRedeliveryMessageIdData(ids).thenAccept(messageIdData -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!messageIdData.isEmpty()) &#123;</span><br><span class="line">                    ByteBuf cmd = Commands.newRedeliverUnacknowledgedMessages(consumerId, messageIdData);</span><br><span class="line">                    cnx.ctx().writeAndFlush(cmd, cnx.ctx().voidPromise());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (messagesFromQueue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            increaseAvailablePermits(cnx, messagesFromQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"[&#123;&#125;] [&#123;&#125;] [&#123;&#125;] Redeliver unacked messages and increase &#123;&#125; permits"</span>, subscription, topic,</span><br><span class="line">                      consumerName, messagesFromQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnx == <span class="keyword">null</span> || (getState() == State.Connecting)) &#123;</span><br><span class="line">        log.warn(<span class="string">"[&#123;&#125;] Client Connection needs to be established for redelivery of unacknowledged messages"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">"[&#123;&#125;] Reconnecting the client to redeliver the messages."</span>, <span class="keyword">this</span>);</span><br><span class="line">        cnx.ctx().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-NegativeAcksTraker"><a href="#4-2-NegativeAcksTraker" class="headerlink" title="4.2 NegativeAcksTraker"></a>4.2 NegativeAcksTraker</h2><p>添加处理失败的消息到缓存中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MessageId messageId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (messageId <span class="keyword">instanceof</span> BatchMessageIdImpl) &#123;</span><br><span class="line">        BatchMessageIdImpl batchMessageId = (BatchMessageIdImpl) messageId;</span><br><span class="line">        messageId = <span class="keyword">new</span> MessageIdImpl(batchMessageId.getLedgerId(), batchMessageId.getEntryId(),</span><br><span class="line">                                      batchMessageId.getPartitionIndex());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nackedMessages == <span class="keyword">null</span>) &#123;</span><br><span class="line">        nackedMessages = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    nackedMessages.put(messageId, System.nanoTime() + nackDelayNanos);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Schedule a task and group all the redeliveries for same period. Leave a small buffer to allow for</span></span><br><span class="line">        <span class="comment">// nack immediately following the current one will be batched into the same redeliver request.</span></span><br><span class="line">        <span class="keyword">this</span>.timeout = timer.newTimeout(<span class="keyword">this</span>::triggerRedelivery, timerIntervalNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过触发器发送失败消息到broker</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">triggerRedelivery</span><span class="params">(Timeout t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nackedMessages.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Group all the nacked messages into one single re-delivery request</span></span><br><span class="line">    Set&lt;MessageId&gt; messagesToRedeliver = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">    nackedMessages.forEach((msgId, timestamp) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; now) &#123;</span><br><span class="line">            addChunkedMessageIdsAndRemoveFromSequnceMap(msgId, messagesToRedeliver, <span class="keyword">this</span>.consumer);</span><br><span class="line">            messagesToRedeliver.add(msgId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    messagesToRedeliver.forEach(nackedMessages::remove);</span><br><span class="line">    consumer.onNegativeAcksSend(messagesToRedeliver);</span><br><span class="line">    <span class="comment">// 使用netty发送消息给broker</span></span><br><span class="line">    consumer.redeliverUnacknowledgedMessages(messagesToRedeliver);</span><br><span class="line">    <span class="keyword">this</span>.timeout = timer.newTimeout(<span class="keyword">this</span>::triggerRedelivery, timerIntervalNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-ServerCnx"><a href="#4-3-ServerCnx" class="headerlink" title="4.3 ServerCnx"></a>4.3 ServerCnx</h2><p>处理接收到的需要重新发送的消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleRedeliverUnacknowledged</span><span class="params">(CommandRedeliverUnacknowledgedMessages redeliver)</span> </span>&#123;</span><br><span class="line">    checkArgument(state == State.Connected);</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"[&#123;&#125;] Received Resend Command from consumer &#123;&#125; "</span>, remoteAddress, redeliver.getConsumerId());</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture&lt;Consumer&gt; consumerFuture = consumers.get(redeliver.getConsumerId());</span><br><span class="line">    <span class="keyword">if</span> (consumerFuture != <span class="keyword">null</span> &amp;&amp; consumerFuture.isDone() &amp;&amp; !consumerFuture.isCompletedExceptionally()) &#123;</span><br><span class="line">        Consumer consumer = consumerFuture.getNow(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (redeliver.getMessageIdsCount() &gt; <span class="number">0</span> &amp;&amp; Subscription.isIndividualAckMode(consumer.subType())) &#123;</span><br><span class="line">            consumer.redeliverUnacknowledgedMessages(redeliver.getMessageIdsList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            consumer.redeliverUnacknowledgedMessages();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-Consumer"><a href="#4-4-Consumer" class="headerlink" title="4.4 Consumer"></a>4.4 Consumer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redeliverUnacknowledgedMessages</span><span class="params">(List&lt;MessageIdData&gt; messageIds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalRedeliveryMessages = <span class="number">0</span>;</span><br><span class="line">    List&lt;PositionImpl&gt; pendingPositions = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">for</span> (MessageIdData msg : messageIds) &#123;</span><br><span class="line">        PositionImpl position = PositionImpl.get(msg.getLedgerId(), msg.getEntryId());</span><br><span class="line">        LongPair batchSize = pendingAcks.get(position.getLedgerId(), position.getEntryId());</span><br><span class="line">        <span class="keyword">if</span> (batchSize != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingAcks.remove(position.getLedgerId(), position.getEntryId());</span><br><span class="line">            totalRedeliveryMessages += batchSize.first;</span><br><span class="line">            pendingPositions.add(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addAndGetUnAckedMsgs(<span class="keyword">this</span>, -totalRedeliveryMessages);</span><br><span class="line">    blockedConsumerOnUnackedMsgs = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"[&#123;&#125;-&#123;&#125;] consumer &#123;&#125; received &#123;&#125; msg-redelivery &#123;&#125;"</span>, topicName, subscription, consumerId,</span><br><span class="line">                  totalRedeliveryMessages, pendingPositions.size());</span><br><span class="line">    &#125;</span><br><span class="line">    subscription.redeliverUnacknowledgedMessages(<span class="keyword">this</span>, pendingPositions);</span><br><span class="line">    msgRedeliver.recordMultipleEvents(totalRedeliveryMessages, totalRedeliveryMessages);</span><br><span class="line">    <span class="keyword">int</span> numberOfBlockedPermits = PERMITS_RECEIVED_WHILE_CONSUMER_BLOCKED_UPDATER.getAndSet(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// if permitsReceivedWhileConsumerBlocked has been accumulated then pass it to Dispatcher to flow messages</span></span><br><span class="line">    <span class="keyword">if</span> (numberOfBlockedPermits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        MESSAGE_PERMITS_UPDATER.getAndAdd(<span class="keyword">this</span>, numberOfBlockedPermits);</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"[&#123;&#125;-&#123;&#125;] Added &#123;&#125; blockedPermits to broker.service.Consumer's messagePermits for consumer &#123;&#125;"</span>,</span><br><span class="line">                      topicName, subscription, numberOfBlockedPermits, consumerId);</span><br><span class="line">        &#125;</span><br><span class="line">        subscription.consumerFlow(<span class="keyword">this</span>, numberOfBlockedPermits);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-PersistentDispatcherMultipleConsumers"><a href="#4-5-PersistentDispatcherMultipleConsumers" class="headerlink" title="4.5 PersistentDispatcherMultipleConsumers"></a>4.5 PersistentDispatcherMultipleConsumers</h2><p>保存消息到缓存中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">redeliverUnacknowledgedMessages</span><span class="params">(Consumer consumer, List&lt;PositionImpl&gt; positions)</span> </span>&#123;</span><br><span class="line">        positions.forEach(position -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (addMessageToReplay(position.getLedgerId(), position.getEntryId())) &#123;</span><br><span class="line">                redeliveryTracker.addIfAbsent(position);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"[&#123;&#125;-&#123;&#125;] Redelivering unacknowledged messages for consumer &#123;&#125;"</span>, name, consumer, positions);</span><br><span class="line">        &#125;</span><br><span class="line">        readMoreEntries();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>这里只是总结下消息重发的处理逻辑，具体broker和consumer之间是怎么通信的还需要继续研究…</p>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程 - 异步处理（CompletableFuture）</title>
      <link href="/2021/08/03/Java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%20-%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%88CompletableFuture%EF%BC%89/"/>
      <url>/2021/08/03/Java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%20-%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%88CompletableFuture%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="一、示例"><a href="#一、示例" class="headerlink" title="一、示例"></a>一、示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/2 17:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(FunctionTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FunctionTest main = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        System.out.println(<span class="string">"\n------------------------------------   函数式编程方式  ------------------------------------"</span>);</span><br><span class="line">        main.run();</span><br><span class="line">        System.out.println(<span class="string">"\n------------------------------------ 经典的异步实现方式 ------------------------------------"</span>);</span><br><span class="line">        main.runOld();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> value = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 定义任务内容</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            value += <span class="number">101</span>;</span><br><span class="line">            log.info(<span class="string">"supplyAsync, value="</span> + value);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">"%d"</span>, value);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"sleep done"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行完任务后执行匿名函数</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; next = future.thenAccept(v -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"thenAccept, value="</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取任务的执行结果</span></span><br><span class="line">        String result = future.get();</span><br><span class="line">        log.info(<span class="string">"thenAccept, get="</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runOld</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        value = <span class="number">101</span>;</span><br><span class="line">        LinkedBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 启动线程执行任务</span></span><br><span class="line">        task(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞方式等待任务执行结束</span></span><br><span class="line">        String result = queue.take();</span><br><span class="line">        log.info(<span class="string">"thenAccept, get="</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(LinkedBlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String result = <span class="string">"failed"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value += <span class="number">101</span>;</span><br><span class="line">                log.info(<span class="string">"supplyAsync, value="</span> + value);</span><br><span class="line">                result = String.format(<span class="string">"%d"</span>, value);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">""</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(<span class="string">""</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、输出"><a href="#二、输出" class="headerlink" title="二、输出"></a>二、输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------------------------------   函数式编程方式  ------------------------------------</span><br><span class="line">08:47:51.571 [ForkJoinPool.commonPool-worker-1] INFO  main.FunctionTest - supplyAsync, value&#x3D;202</span><br><span class="line">08:47:52.575 [main] INFO  main.FunctionTest - sleep done</span><br><span class="line">08:47:52.575 [main] INFO  main.FunctionTest - thenAccept, value&#x3D;202</span><br><span class="line">08:47:52.575 [main] INFO  main.FunctionTest - thenAccept, get&#x3D;202</span><br><span class="line"></span><br><span class="line">------------------------------------ 经典的异步实现方式 ------------------------------------</span><br><span class="line">08:47:52.576 [Thread-1] INFO  main.FunctionTest - supplyAsync, value&#x3D;202</span><br><span class="line">08:47:52.576 [main] INFO  main.FunctionTest - thenAccept, get&#x3D;202</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h4 id="三、解释"><a href="#三、解释" class="headerlink" title="三、解释"></a>三、解释</h4><p>解决的是执行完一个异步函数后，得到执行结果或者根据执行结果继续执行后续的处理逻辑。</p><p>之前的方法是把异步执行的任务放到线程中执行，然后另外一个线程监听通知队列或者阻塞等待任务执行完毕，任务执行完后往队列放一个通知，通知等待线程。</p><p>现在可以采用更为简洁的方式去处理这种场景：</p><ol><li>定义一个异步函数</li><li>使异步函数执行</li><li>获取执行结果</li></ol><p>当调用get、thenAccept等方法后，java本身会帮助我们执行异步逻辑，并以阻塞的方式等待结果。</p><p><strong>一个函数对象只会执行一次，执行完之后会保存这个结果，下次调用get等计算方法的时候直接使用上次的计算结果。</strong></p><h4 id="四、查看代码"><a href="#四、查看代码" class="headerlink" title="四、查看代码"></a>四、查看代码</h4><p>通过get方法查看具体的执行方式：</p><p>CompletableFuture.get()</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    Object r;</span><br><span class="line">    return reportGet((r &#x3D; result) &#x3D;&#x3D; null ? waitingGet(true) : r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数之前执行过，则会把结果保存到result变量中，调用get方法执行返回result结果；</p><p>如果函数没有执行过，则调用waitingGet方法执行。</p><p>下面看waitingGet方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Object waitingGet(boolean interruptible) &#123;    Signaller q &#x3D; null;    boolean queued &#x3D; false;    int spins &#x3D; -1;    Object r;    while ((r &#x3D; result) &#x3D;&#x3D; null) &#123;        if (spins &lt; 0)            spins &#x3D; SPINS;        else if (spins &gt; 0) &#123;            if (ThreadLocalRandom.nextSecondarySeed() &gt;&#x3D; 0)                --spins;        &#125;        else if (q &#x3D;&#x3D; null)            q &#x3D; new Signaller(interruptible, 0L, 0L);        else if (!queued)            queued &#x3D; tryPushStack(q);        else if (interruptible &amp;&amp; q.interruptControl &lt; 0) &#123;            q.thread &#x3D; null;            cleanStack();            return null;        &#125;        else if (q.thread !&#x3D; null &amp;&amp; result &#x3D;&#x3D; null) &#123;            try &#123;                ForkJoinPool.managedBlock(q);            &#125; catch (InterruptedException ie) &#123;                q.interruptControl &#x3D; -1;            &#125;        &#125;    &#125;    if (q !&#x3D; null) &#123;        q.thread &#x3D; null;        if (q.interruptControl &lt; 0) &#123;            if (interruptible)                r &#x3D; null; &#x2F;&#x2F; report interruption            else                Thread.currentThread().interrupt();        &#125;    &#125;    postComplete();    return r;&#125;</span><br></pre></td></tr></table></figure><p>此方法的目的是阻塞的方式检测定义的function是否执行完毕，执行完毕或者出现异常后返回结果。</p><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>这种编程方式是一种思维的转变，让异步结构变得更清晰，前后关系也很清楚（都是A-&gt;B-&gt;C），可以把所有的异步代码放在一起写，不需要添加额外的异步执行结果判断变量。</p><p>但是需要一段时间去习惯这种写法，否则也会被其中各种匿名函数和api绕晕。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证和授权(2)</title>
      <link href="/2021/08/01/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(2)/"/>
      <url>/2021/08/01/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(2)/</url>
      
        <content type="html"><![CDATA[<p>前面介绍了认证和授权的主要流程，本篇重点说明pulsar授权信息的存储以及怎么结合第三方用户中心实现授权管理。</p><ol><li>基于pulsar-admin的授权指令</li></ol><p>关于cluster、broker、bookie、tenant、namespace、topic的命令。</p><p>具体可参考：<a href="https://pulsar.apache.org/pulsar-admin-cli/?version=2.8.0" target="_blank" rel="noopener">https://pulsar.apache.org/pulsar-admin-cli/?version=2.8.0</a></p><ol start="2"><li>授权信息存储</li></ol><p>使用pulsar默认的授权管理类（org.apache.pulsar.broker.authorization.PulsarAuthorizationProvider），授权信息会保存到global-zookeeper中，路径如下：</p><p>[zk: 172.20.140.11:2184(CONNECTED) 5] ls -R /admin/policies /admin/policies /admin/policies/public /admin/policies/pulsar /admin/policies/tenant_c /admin/policies/tenant_vv /admin/policies/public/default /admin/policies/pulsar/system /admin/policies/tenant_vv/ns1</p><p>查看/admin/policies/tenant_vv/ns1的节点内容</p><p>{ “auth_policies”: { “destination_auth”: {}, “namespace_auth”: { “vv123”: [ “consume”, “produce” ] }, “subscription_auth_roles”: {} }, “backlog_quota_map”: {}, “bundles”: { “boundaries”: [ “0x00000000”, “0x40000000”, “0x80000000”, “0xc0000000”, “0xffffffff” ], “numBundles”: 4 }, “clusterDispatchRate”: {}, “clusterSubscribeRate”: {}, “deleted”: false, “encryption_required”: false, “is_allow_auto_update_schema”: true, “latency_stats_sample_rate”: {}, “offload_threshold”: -1, “properties”: {}, “publishMaxMessageRate”: {}, “replication_clusters”: [ “vv” ], “replicatorDispatchRate”: {}, “schema_auto_update_compatibility_strategy”: “Full”, “schema_compatibility_strategy”: “UNDEFINED”, “schema_validation_enforced”: false, “subscriptionDispatchRate”: {}, “subscription_auth_mode”: “None”, “subscription_expiration_time_minutes”: 0, “subscription_types_enabled”: [], “topicDispatchRate”: {} }</p><p>在auth_policies里可以看到给角色vv123分配了produce和consume权限。</p><ol start="3"><li>授权实现思路</li></ol><p>首先需要对所有需要权限的操作进行拦截，pulsar提供了如下两个接口：</p><p>// 处理连接认证的 org.apache.pulsar.broker.authentication.AuthenticationProvider </p><p>// 处理授权的 org.apache.pulsar.broker.authorization.AuthorizationProvider</p><p>定义一组需要进行权限管理的操作，具体如下：</p><p>定义好用户和操作之间的关系，并给每一个用户分配唯一的token标识</p><p>在一次连接中保存用户的token信息和权限，并定时更新权限</p><p>针对用户的每一次操作都根据token进行权限的验证</p><p>由此我们可以知道，授权管理的前提是有一个用户管理中心，管理中心负责用户的创建和权限的分配。客户端连接的时候去用户中心获取token信息，然后携带token连接到broker，broker在用户第一次连接是去管理中心获取用户的权限信息并缓存。最后就是对用户的操作进行权限的判断了。</p><ol start="4"><li>用户信息管理中心</li></ol><p>结合pulsar的常用操作，我们可以设计几张表保存用户信息和权限信息。</p>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证和授权(1)</title>
      <link href="/2021/07/29/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(1)/"/>
      <url>/2021/07/29/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(1)/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>本系列文章准备详细的说明pulsar的认证和授权流程，并结合市场上常见的主-主账号授权、主-子账号授权需求提供解决办法。</p><h3 id="2-整体结构"><a href="#2-整体结构" class="headerlink" title="2. 整体结构"></a>2. 整体结构</h3><p>首先我们需要对pulsar有一个整体的认识，pulsar本身是一个分布式部署的消息订阅分发中间件，它主要包含三个组件：</p><p>zookeeper：负责配置管理</p><p>broker：对外提供服务，接收发布订阅请求</p><p>bookkeeper：负责消息的持久化</p><p><img src="assets/image-20210611184242420.png" alt="image-20210611184242420"></p><h3 id="3-通信方式"><a href="#3-通信方式" class="headerlink" title="3. 通信方式"></a>3. 通信方式</h3><p>pulsar提供了两种服务，一种是http的，主要负责处理创建tenant、namespace、topic和获取集群状态等信息；另外一种是基于netty写的tcp服务，主要用于接收客户端发送的消息和订阅请求。</p><p>http服务都在org.apache.pulsar.broker.admin包下，可以看到对于cluster、broker、tenant、namespace等都提供了对应的api操作接口。</p><p>tcp服务的核心处理类是org.apache.pulsar.broker.service.ServerCnx。</p><p>消息格式为TLV格式的二进制数据，每条消息的前4个字节为消息的总长度。</p><p>看下具体的消息格式：</p><p><img src="assets/image-20231007104802008.png" alt="image-20231007104802008"></p><h3 id="4-认证处理逻辑"><a href="#4-认证处理逻辑" class="headerlink" title="4. 认证处理逻辑"></a>4. 认证处理逻辑</h3><p>客户端和broker之间是TCP长连接，在客户端连接到broker后，broker会对客户端的合法性进行验证，如果不合法则断开连接，判断流程是：</p><ol><li>判断是否开启了连接认证（conf/broker.conf：authenticationEnabled）</li><li>如果没有开启认证，则返回连接成功</li><li>如果开启了认证，则获取认证内容、认证客户端选择的服务端认证策略</li><li>如果服务端不支持客户端提供的认证策略，则返回认证失败</li><li>如果支持，则调用策略的认证方法（AuthenticationProvider.authenticate）</li><li>如果认证过程没有抛出异常，则返回认证成功，并保存认证结果（这里的认证结果就是role，后续会根据role对客户端的其他操作进行授权管理）</li><li>认证过程完成。</li></ol><p>认证处理包含几个重要的接口</p><ul><li><p>服务端（broker）：</p><p>org.apache.pulsar.broker.authentication.AuthenticationProvider，核心方法如下：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ServiceConfiguration config)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化时使用，在broker启动的时候初始化。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 范围认证策略的名称，需要和客户端发送的名称保持一致。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">authenticate</span><span class="params">(AuthenticationDataSource authData)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="comment">// 进行客户端认证，返回客户端的角色名称。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// broker关闭时调用此方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>客户端：</p><p>org.apache.pulsar.client.api.Authentication</p><p>org.apache.pulsar.client.api.AuthenticationDataProvider，核心方法如下：</p></li></ul><p><strong>Authentication</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 认证策略的名称。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthenticationDataProvider <span class="title">getAuthData</span><span class="params">()</span> <span class="keyword">throws</span> PulsarClientException </span>&#123;</span><br><span class="line">   <span class="comment">// 返回认证数据持有对象，即另外一个核心接口的实现类。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, String&gt; authParams)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 程序启动时调用，可以得到配置文件中的配置项。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> PulsarClientException </span>&#123;</span><br><span class="line">    <span class="comment">// 程序启动时调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 程序停止时调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AuthenticationDataProvider</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasDataForHttp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// http区是否有数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; getHttpHeaders() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">// 获取http头信息，如果上述方法返回true，则这里要设置http header内容。然后broker端才能根据http header name获取到数据。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasDataFromCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否有命令数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCommandData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果上述方法返回true，则这里要返回broker端需要的数据。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-授权处理逻辑"><a href="#5-授权处理逻辑" class="headerlink" title="5. 授权处理逻辑"></a>5. 授权处理逻辑</h3><p>授权需要在客户端连接认证的基础上进行，根据连接认证完成后生成的role对后续的操作进行权限管理。</p><p>授权管理包含两部分：</p><ul><li>使用pulsar-admin管理集群时的权限验证（http协议）</li><li>客户端连接到broker进行数据读写时的权限验证（tcp协议）</li></ul><p>上述两部分授权的处理逻辑其实没有区别，都是先通过连接认证获取获取客户端的role，然后根据role判断客户端是否有对应操作的权限。由于上边已经说了role的获取途径，下面重点写下pulsar对于客户端的哪些操作进行了权限的判断。</p><p><img src="assets/image-20231007105427754.png" alt="image-20231007105427754"></p><h3 id="6-自定义认证和授权"><a href="#6-自定义认证和授权" class="headerlink" title="6. 自定义认证和授权"></a>6. 自定义认证和授权</h3><p>自定义认证和授权只需要实现前两节中列出的接口即可。</p><h3 id="7-第三方认证和授权中心"><a href="#7-第三方认证和授权中心" class="headerlink" title="7. 第三方认证和授权中心"></a>7. 第三方认证和授权中心</h3><p>为了能更好的对客户端的权限进行管理，需要一个统一的第三方认证中心，记录tenant、namespace和topic的信息以及用户信息，并建立起用户和操作之间的权限关系。这样，在客户端连接到broker后，broker就可以根据客户端传递的用户信息对客户端操作进行权限验证。</p><h3 id="8-具体实现（不包含真正的权限验证部分，只是为了测试整体流程）"><a href="#8-具体实现（不包含真正的权限验证部分，只是为了测试整体流程）" class="headerlink" title="8. 具体实现（不包含真正的权限验证部分，只是为了测试整体流程）"></a>8. 具体实现（不包含真正的权限验证部分，只是为了测试整体流程）</h3><h4 id="8-1-实现broker端认证接口"><a href="#8-1-实现broker端认证接口" class="headerlink" title="8.1 实现broker端认证接口"></a>8.1 实现broker端认证接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> auth.server;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.broker.ServiceConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.broker.authentication.AuthenticationDataSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.broker.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.naming.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VVAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(VVAuthenticationProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String methodName = <span class="string">"vv_auth_v2"</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong seq = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> String header = <span class="string">"vv_auth"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ServiceConfiguration config)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" initialize"</span> + <span class="string">", seq="</span> + seq.incrementAndGet());</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; superRoles = config.getSuperUserRoles();</span><br><span class="line">        <span class="keyword">if</span> (superRoles == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String role : superRoles) &#123;</span><br><span class="line">            log.info(methodName + <span class="string">" initialize "</span> + role + <span class="string">", seq="</span> + seq.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" getAuthMethodName"</span>);</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">authenticate</span><span class="params">(AuthenticationDataSource authData)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" authenticate"</span> + <span class="string">", seq="</span> + seq.incrementAndGet());</span><br><span class="line">        String roleToken = <span class="string">"unknown"</span>;</span><br><span class="line">        <span class="keyword">if</span> (authData.hasDataFromCommand()) &#123;</span><br><span class="line">            roleToken = authData.getCommandData();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (authData.hasDataFromHttp()) &#123;</span><br><span class="line">            roleToken = authData.getHttpHeader(header);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"Authentication data source does not have a role token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(methodName + <span class="string">" authenticate "</span> + roleToken + <span class="string">", seq="</span> + seq.incrementAndGet());</span><br><span class="line">        <span class="keyword">return</span> roleToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" close"</span> + <span class="string">", seq="</span> + seq.incrementAndGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-实现客户端认证接口"><a href="#8-2-实现客户端认证接口" class="headerlink" title="8.2 实现客户端认证接口"></a>8.2 实现客户端认证接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> auth.client;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.AuthenticationDataProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.PulsarClientException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 14:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VVAuthentication</span> <span class="keyword">implements</span> <span class="title">Authentication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(VVAuthentication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String methodName = <span class="string">"vv_auth_v2"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" getAuthMethodName"</span>);</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationDataProvider <span class="title">getAuthData</span><span class="params">()</span> <span class="keyword">throws</span> PulsarClientException </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" getAuthData"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VVAuthenticationDataProvider();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, String&gt; authParams)</span> </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" configure"</span>);</span><br><span class="line">        <span class="keyword">if</span> (authParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        authParams.forEach((key, value) -&gt; &#123;</span><br><span class="line">            log.info(methodName + <span class="string">" configure "</span> + key + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> PulsarClientException </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> auth.client;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.AuthenticationDataProvider;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 14:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VVAuthenticationDataProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationDataProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(VVAuthenticationDataProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String methodName = <span class="string">"vv_auth_v2"</span>;</span><br><span class="line">    <span class="keyword">private</span> String header = <span class="string">"vv_auth"</span>;</span><br><span class="line">    <span class="keyword">private</span> String token = <span class="string">"vv-role"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasDataForHttp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" hasDataForHttp"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; getHttpHeaders() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(methodName + <span class="string">" getHttpHeaders"</span>);</span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        headers.put(header, token);</span><br><span class="line">        <span class="keyword">return</span> headers.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasDataFromCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" hasDataFromCommand"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCommandData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(methodName + <span class="string">" getCommandData"</span>);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-修改conf-broker-conf配置文件"><a href="#8-3-修改conf-broker-conf配置文件" class="headerlink" title="8.3 修改conf/broker.conf配置文件"></a>8.3 修改conf/broker.conf配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### --- Authentication --- ###</span><br><span class="line"># Enable authentication</span><br><span class="line"># 开启连接认证</span><br><span class="line">authenticationEnabled&#x3D;true</span><br><span class="line"># Authentication provider name list, which is comma separated list of class names</span><br><span class="line"># 自定义的broker端实现的处理类</span><br><span class="line">authenticationProviders&#x3D;auth.server.VVAuthenticationProvider</span><br><span class="line"># Interval of time for checking for expired authentication credentials</span><br><span class="line">authenticationRefreshCheckSeconds&#x3D;60</span><br><span class="line"># Enforce authorization</span><br><span class="line"># 开启授权认证</span><br><span class="line">authorizationEnabled&#x3D;true</span><br><span class="line"># Authorization provider fully qualified class-name</span><br><span class="line"># 自定义的授权认证处理类</span><br><span class="line">authorizationProvider&#x3D;auth.server.VVPulsarAuthorizationProvider</span><br><span class="line"># Allow wildcard matching in authorization</span><br><span class="line"># (wildcard matching only applicable if wildcard-char:</span><br><span class="line"># * presents at first or last position eg: *.pulsar.service, pulsar.service.*)</span><br><span class="line">authorizationAllowWildcardsMatching&#x3D;false</span><br><span class="line"># Role names that are treated as &quot;super-user&quot;, meaning they will be able to do all admin</span><br><span class="line"># operations and publish&#x2F;consume from all topics</span><br><span class="line"># 超级用户，创建tenant的时候需要超级用户</span><br><span class="line">superUserRoles&#x3D;vv-role,cc-role</span><br><span class="line"># Authentication settings of the broker itself. Used when the broker connects to other brokers,</span><br><span class="line"># either in same or other clusters</span><br><span class="line">brokerClientTlsEnabled&#x3D;false</span><br><span class="line"># 自定义的客户端认证实现类</span><br><span class="line">brokerClientAuthenticationPlugin&#x3D;auth.client2.client.VVAuthentication</span><br><span class="line">brokerClientAuthenticationParameters&#x3D;</span><br><span class="line">brokerClientTrustCertsFilePath&#x3D;</span><br></pre></td></tr></table></figure><h4 id="8-4-重启broker"><a href="#8-4-重启broker" class="headerlink" title="8.4 重启broker"></a>8.4 重启broker</h4><p>./bin/pulsar-daemon stop broker</p><p>./bin/pulsar-daemon start broker</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="8-5-验证是否有效"><a href="#8-5-验证是否有效" class="headerlink" title="8.5 验证是否有效"></a>8.5 验证是否有效</h5><p><strong>通过pulsar-admin命令进行验证</strong></p><p>首先配置conf/client.conf文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authPlugin&#x3D;auth.client2.client.VVAuthenticationauthParams&#x3D;</span><br></pre></td></tr></table></figure><p>执行命令并验证结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行以下命令.&#x2F;bin&#x2F;pulsar-admin tenants list# 客户端侧输出日志18:21:52.173 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 configure18:21:52.175 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 configure token&#x3D;123456vv18:21:52.335 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 getAuthMethodName18:21:52.336 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 start18:21:52.611 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 getAuthData18:21:52.612 [main] INFO  auth.client.VVAuthenticationDataProvider - vv_auth_v2 hasDataForHttp18:21:52.789 [main] INFO  auth.client.VVAuthenticationDataProvider - vv_auth_v2 hasDataForHttp18:21:52.789 [main] INFO  auth.client.VVAuthenticationDataProvider - vv_auth_v2 getHttpHeaders# 服务端（broker）侧输出日志18:23:53.957 [pulsar-web-41-11] INFO  auth.server.VVAuthenticationProvider - vv_auth_v2 authenticate, seq&#x3D;329618:23:53.957 [pulsar-web-41-11] INFO  auth.server.VVAuthenticationProvider - vv_auth_v2 authenticate vv-role, seq&#x3D;329718:23:53.958 [pulsar-web-41-11] INFO  org.eclipse.jetty.server.RequestLog - x.x.x.x - - [29&#x2F;Jul&#x2F;2021:18:23:53 +0800] &quot;GET &#x2F;admin&#x2F;v2&#x2F;tenants HTTP&#x2F;1.1&quot; 200 42 &quot;-&quot; &quot;Pulsar-Java-v2.8.0&quot; 1# 在pulsar-admin侧可以看到输出的tenant列表&quot;public&quot;&quot;pulsar&quot;&quot;tenant_c&quot;&quot;tenant_vv&quot;</span><br></pre></td></tr></table></figure><p><strong>通过java程序验证</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> auth;</span><br><span class="line"><span class="keyword">import</span> auth.client.VVAuthentication;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/19 10:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(AuthTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AuthTest main = <span class="keyword">new</span> AuthTest();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line">    String pulsarUrl = <span class="string">"pulsar://x.x.x.x:6650"</span>;</span><br><span class="line">    String topic = <span class="string">"persistent://tenant_vv/ns1/auth_test"</span>;</span><br><span class="line">    Authentication authentication = <span class="keyword">new</span> VVAuthentication();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PulsarClient client = PulsarClient.builder()</span><br><span class="line">                .authentication(authentication)</span><br><span class="line">                .serviceUrl(pulsarUrl)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//        send(client);</span></span><br><span class="line"><span class="comment">//        testReader(client);</span></span><br><span class="line">        consume(client);</span><br><span class="line">        System.out.println(<span class="string">"connect successed "</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Consumer consumer = client.newConsumer()</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .subscriptionName(<span class="string">"consumer-test"</span>)</span><br><span class="line">                .subscribe();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Message m = consumer.receive();</span><br><span class="line">            <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"recv "</span> + <span class="keyword">new</span> String(m.getData()));</span><br><span class="line">                consumer.acknowledge(m);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Producer p = client.newProducer()</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .create();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            p.newMessage().key(<span class="string">"aaa"</span>).value((<span class="string">"hello "</span> + i).getBytes()).send();</span><br><span class="line">            log.info(<span class="string">"send "</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p.flush();</span><br><span class="line">        p.close();</span><br><span class="line">        System.out.println(<span class="string">"send done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testReader</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Reader reader = client.newReader()</span><br><span class="line">                .subscriptionName(<span class="string">"reader-test"</span>)</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .startMessageId(MessageId.earliest)</span><br><span class="line"><span class="comment">//                .startMessageId(DefaultImplementation.newMessageId(121493, -1, -1))</span></span><br><span class="line">                .create();</span><br><span class="line">        <span class="keyword">while</span> (reader.hasMessageAvailable()) &#123;</span><br><span class="line">            Message msg = reader.readNext();</span><br><span class="line">            log.info(<span class="string">"reader recv msg, id="</span> + msg.getMessageId() + <span class="string">" key="</span> + msg.getKey() + <span class="string">", value="</span> + <span class="keyword">new</span> String(msg.getData()));</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证和授权(0)</title>
      <link href="/2021/07/28/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(0)/"/>
      <url>/2021/07/28/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(0)/</url>
      
        <content type="html"><![CDATA[<h3 id="pulsar认证说明"><a href="#pulsar认证说明" class="headerlink" title="pulsar认证说明"></a>pulsar认证说明</h3><p>pulsar支持TLS、Athenz、Kerberos、JSON Web Token等认证，也支持自定义认证。</p><p>pulsar基于Netty进行数据的通信，通信内容的格式是TLV。服务端处理数据的类是org.apache.pulsar.broker.service.ServerCnx，客户端处理数据的类是org.apache.pulsar.client.impl.ClientCnx，这两个类都继承PulsarDecoder，在PulsarDecoder中区分各种type，然后根据type调用各种业务处理，在CONNECT中处理认证。</p><p>可以看下pulsar中的消息类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> PARTITIONED_METADATA</span><br><span class="line"><span class="keyword">case</span> PARTITIONED_METADATA_RESPONSE</span><br><span class="line"><span class="keyword">case</span> LOOKUP</span><br><span class="line"><span class="keyword">case</span> LOOKUP_RESPONSE</span><br><span class="line"><span class="keyword">case</span> ACK</span><br><span class="line"><span class="keyword">case</span> ACK_RESPONSE</span><br><span class="line"><span class="keyword">case</span> CLOSE_CONSUMER</span><br><span class="line"><span class="keyword">case</span> CLOSE_PRODUCER</span><br><span class="line"><span class="keyword">case</span> CONNECT</span><br><span class="line"><span class="keyword">case</span> CONNECTED</span><br><span class="line"><span class="keyword">case</span> ERROR</span><br><span class="line"><span class="keyword">case</span> FLOW</span><br><span class="line"><span class="keyword">case</span> MESSAGE</span><br><span class="line"><span class="keyword">case</span> PRODUCER</span><br><span class="line"><span class="keyword">case</span> SEND</span><br><span class="line"><span class="keyword">case</span> SEND_ERROR</span><br><span class="line"><span class="keyword">case</span> SEND_RECEIPT</span><br><span class="line"><span class="keyword">case</span> SUBSCRIBE</span><br><span class="line"><span class="keyword">case</span> SUCCESS</span><br><span class="line"><span class="keyword">case</span> PRODUCER_SUCCESS</span><br><span class="line"><span class="keyword">case</span> UNSUBSCRIBE</span><br><span class="line"><span class="keyword">case</span> SEEK</span><br><span class="line"><span class="keyword">case</span> PING</span><br><span class="line"><span class="keyword">case</span> PONG</span><br><span class="line"><span class="keyword">case</span> REDELIVER_UNACKNOWLEDGED_MESSAGES</span><br><span class="line"><span class="keyword">case</span> CONSUMER_STATS</span><br><span class="line"><span class="keyword">case</span> CONSUMER_STATS_RESPONSE</span><br><span class="line"><span class="keyword">case</span> REACHED_END_OF_TOPIC</span><br><span class="line"><span class="keyword">case</span> GET_LAST_MESSAGE_ID</span><br><span class="line"><span class="keyword">case</span> GET_LAST_MESSAGE_ID_RESPONSE</span><br><span class="line"><span class="keyword">case</span> ACTIVE_CONSUMER_CHANGE</span><br><span class="line"><span class="keyword">case</span> GET_TOPICS_OF_NAMESPACE</span><br><span class="line"><span class="keyword">case</span> GET_TOPICS_OF_NAMESPACE_RESPONSE</span><br><span class="line"><span class="keyword">case</span> GET_SCHEMA</span><br><span class="line"><span class="keyword">case</span> GET_SCHEMA_RESPONSE</span><br><span class="line"><span class="keyword">case</span> GET_OR_CREATE_SCHEMA</span><br><span class="line"><span class="keyword">case</span> GET_OR_CREATE_SCHEMA_RESPONSE</span><br><span class="line"><span class="keyword">case</span> AUTH_CHALLENGE</span><br><span class="line"><span class="keyword">case</span> AUTH_RESPONSE</span><br><span class="line"><span class="keyword">case</span> NEW_TXN</span><br><span class="line"><span class="keyword">case</span> NEW_TXN_RESPONSE</span><br><span class="line"><span class="keyword">case</span> ADD_PARTITION_TO_TXN</span><br><span class="line"><span class="keyword">case</span> ADD_PARTITION_TO_TXN_RESPONSE</span><br><span class="line"><span class="keyword">case</span> ADD_SUBSCRIPTION_TO_TXN</span><br><span class="line"><span class="keyword">case</span> ADD_SUBSCRIPTION_TO_TXN_RESPONSE</span><br><span class="line"><span class="keyword">case</span> END_TXN</span><br><span class="line"><span class="keyword">case</span> END_TXN_RESPONSE</span><br><span class="line"><span class="keyword">case</span> END_TXN_ON_PARTITION</span><br><span class="line"><span class="keyword">case</span> END_TXN_ON_PARTITION_RESPONSE</span><br><span class="line"><span class="keyword">case</span> END_TXN_ON_SUBSCRIPTION</span><br><span class="line"><span class="keyword">case</span> END_TXN_ON_SUBSCRIPTION_RESPONSE</span><br></pre></td></tr></table></figure><h3 id="pulsar认证实现步骤"><a href="#pulsar认证实现步骤" class="headerlink" title="pulsar认证实现步骤"></a>pulsar认证实现步骤</h3><p>pulsar的认证很简单，下面两个步骤就可以完成。</p><ol><li>分别实现org.apache.pulsar.client.api.Authentication和org.apache.pulsar.broker.authentication.AuthenticationProvider接口，第一个用户客户端侧认证，第二个用户服务端侧认证。</li><li>修改conf/broker.conf文件，开启认证功能。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enable authentication</span><br><span class="line">authenticationEnabled&#x3D;true</span><br><span class="line"># Authentication provider name list, which is comma separated list of class names</span><br><span class="line">authenticationProviders&#x3D;auth.server.VVAuthenticationProvider</span><br><span class="line"># Interval of time for checking for expired authentication credentials</span><br><span class="line">authenticationRefreshCheckSeconds&#x3D;60</span><br><span class="line"># Role names that are treated as &quot;super-user&quot;, meaning they will be able to do all admin</span><br><span class="line"># operations and publish&#x2F;consume from all topics</span><br><span class="line">superUserRoles&#x3D;vv-role,cc-role</span><br><span class="line"># Authentication settings of the broker itself. Used when the broker connects to other brokers,</span><br><span class="line"># either in same or other clusters</span><br><span class="line">brokerClientTlsEnabled&#x3D;false</span><br><span class="line">brokerClientAuthenticationPlugin&#x3D;auth.client2.client.VVAuthentication</span><br><span class="line">brokerClientAuthenticationParameters&#x3D;</span><br><span class="line">brokerClientTrustCertsFilePath&#x3D;</span><br></pre></td></tr></table></figure><p>需要注意的是，broker和client之间有认证，broker和broker之间也有认证，所以在自己实现的认证接口中需要区分角色，以免造成数据处理问题。</p><h3 id="pulsar授权说明"><a href="#pulsar授权说明" class="headerlink" title="pulsar授权说明"></a>pulsar授权说明</h3><p>pulsar认证和授权是分开的，认证部分用于验证客户端是否合法，授权部分则是细分了各个客户端的权限，包含tenant、namespace、topic操作权限等。授权部分和认证部分虽然是分开的，但是授权是基于角色进行的，而角色是由认证部分生成的，所以要开启授权的前提是先开启认证。</p><h3 id="pulsar授权实现步骤"><a href="#pulsar授权实现步骤" class="headerlink" title="pulsar授权实现步骤"></a>pulsar授权实现步骤</h3><ol><li>实现org.apache.pulsar.broker.authorization.AuthorizationProvider接口</li><li>修改conf/broker.conf文件，开启授权功能。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enforce authorization</span><br><span class="line">authorizationEnabled&#x3D;true</span><br><span class="line"># Authorization provider fully qualified class-name</span><br><span class="line">authorizationProvider&#x3D;auth.server.VVPulsarAuthorizationProvider</span><br><span class="line"></span><br><span class="line"># Allow wildcard matching in authorization</span><br><span class="line"># (wildcard matching only applicable if wildcard-char:</span><br><span class="line"># * presents at first or last position eg: *.pulsar.service, pulsar.service.*)</span><br><span class="line">authorizationAllowWildcardsMatching&#x3D;false</span><br><span class="line"></span><br><span class="line"># Role names that are treated as &quot;super-user&quot;, meaning they will be able to do all admin</span><br><span class="line"># operations and publish&#x2F;consume from all topics</span><br><span class="line">superUserRoles&#x3D;vv-role,cc-role</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bookkeeper</title>
      <link href="/2021/06/15/pulsar/bookkeeper/"/>
      <url>/2021/06/15/pulsar/bookkeeper/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>bookkeeper 类似于一个日志存储系统。</p><h5 id="1-Ledger"><a href="#1-Ledger" class="headerlink" title="1. Ledger"></a>1. Ledger</h5><p>Ledger 创建了之后，进行写数据、关闭和删除操作。</p><p><img src="assets/image-20210615103446035.png" alt="image-20210615103446035"></p><p>Legder 元数据的存储。结构如上图</p><p><strong>参数的含义</strong></p><p>state ：Ledger 的开关状态，open、close</p><p>last entry id  : 上一次确认的entry id， entry id 是从 0 开始递增的</p><p>ensemble / write quorum / ack quorum ：ledger 存放位置的复制信息</p><h5 id="2-Entry"><a href="#2-Entry" class="headerlink" title="2. Entry"></a>2. Entry</h5><p>entry 的元数据信息</p><p><img src="assets/image-20210615104115039.png" alt="image-20210615104115039"></p><p><strong>参数的含义</strong></p><p>Lid 和 Eid ： 记录的是 entry 的key</p><p>LAC : 最后一条已经添加的记录</p><p>Digest ：记录字节的数据，用于完整性校验</p><p>上面介绍的 entry 和 Ledger 的元数据都会存入 Zookeeper 中。</p><h3 id="二、架构"><a href="#二、架构" class="headerlink" title="二、架构"></a>二、架构</h3><p><img src="assets/image-20210615105211046.png" alt="image-20210615105211046"></p><p><strong>3大组件</strong></p><h5 id="1-zookeeper"><a href="#1-zookeeper" class="headerlink" title="1. zookeeper"></a>1. zookeeper</h5><p>存储元数据信息</p><h5 id="2-client"><a href="#2-client" class="headerlink" title="2. client"></a>2. client</h5><p>实现一致性、策略性相关的逻辑</p><h5 id="3-bookie"><a href="#3-bookie" class="headerlink" title="3. bookie"></a>3. bookie</h5><p>存储 ledger 对应的 entry ，所有的 bookie 都会存储到 Bookkeeper 上，让客户端发现</p><p>bookie 可以看做是一个 key-value 数据库。其中 key 就是 （lid + eid），value 就是 ledger 中的 entry 。</p><img src="assets/image-20210615110356991.png" alt="image-20210615110356991" style="zoom: 67%;" /><p>bookie 的实现是依靠 journal 和 ledger storage。</p><h6 id="3-1-journal"><a href="#3-1-journal" class="headerlink" title="3.1 journal"></a>3.1 journal</h6><p>journal 只有写操作，bookie 负责顺序把 entry 写到 journal 文件里，不会进行随机访问。 </p><p>写满了一个 journal 之后，bookie 就会开启一个新的 journal 文件，继续按照顺序写 entry。</p><p><strong>索引 write cache</strong></p><p>journal 中的 entry 是没办法查询的，这个时候就需要索引来达到高效查询了。</p><p>write cache：bookie 端每次在写 entry 进 journal 的时候，会进行一个写缓存的操作。</p><p>写缓存的操作时，bookie 会对 entry 进行排序， 按 ledger 的来源进行划分，为了 entry 可以按照 ledger 进行排序。</p><p>当缓存写满时，bookie 会把 write cache 刷到磁盘中。flush 的过程中会进行重新整理成几个目录。一个是 ledger index，用来存储 entry key，一个是 entry log，用来存储 value。</p><h6 id="3-2-ledger-storage"><a href="#3-2-ledger-storage" class="headerlink" title="3.2 ledger storage"></a>3.2 ledger storage</h6><p>两种方式，DB ledger storage 和 Sorted ledger storage，实现途径是一样的，就是索引存储的时候不太一样。</p><h3 id="三、数据流动"><a href="#三、数据流动" class="headerlink" title="三、数据流动"></a>三、数据流动</h3><p>bookie 的操作基本都是再客户端完成和实现的，比如副本复制、读写 entry 等操作。</p><p>data flow 是如何在客户端中实现的。</p><p>ledger 元数据中的几个参数</p><ul><li><strong>Ensemble</strong> —— 用哪几台 bookie 去存储 ledger 对应的 entry</li><li><strong>Write Quorum</strong> ——对于一条 entry，需要存多少副本</li><li><strong>Ack Quorum</strong> —— 在写 entry 时，要等几个 response</li></ul><p>默认情况下是（3,3,3），一共三个 bookie 去存储 ledger 对应的 entry，对于一个 entry，需要 3 个副本， 只有当3个 bookie 返回 response，才会确认。 </p><h3 id="四、恢复"><a href="#四、恢复" class="headerlink" title="四、恢复"></a>四、恢复</h3><h5 id="1-Ledger-Recovery"><a href="#1-Ledger-Recovery" class="headerlink" title="1. Ledger Recovery"></a>1. Ledger Recovery</h5><p>假设有一个 broker1 去写数据，不断地 append entry 到 ledger x ，当 T0 时间点更新 LAC 为 2， 这时发出的 entry3 是还没有得到请求回复的。这时的 entry3 的状态时 outstanding</p><p><img src="assets/image-20210615190010277.png" alt="image-20210615190010277"></p><p>此时因为脑裂，broker2 去接管这个 topic 的写入， 尝试打开 ledger x 却发现他是 open 状态。 这个状态是无法继续进行读写操作的，那么 broker2 就对 ledger x 进行恢复操作 – Ledger Recovery</p><p><strong>Ledger Recovery 流程</strong></p><ol><li>此时返回当前 ledger 里最大的 LAC 数值，然后进行 recovery 的操作执行</li><li>开始 recovery 操作之后，如果 broker1 还打算继续操作 ledger ，会收到 【操作失败】提醒，此时 broker1 知道当前这个 ledger 被其他 broker 使用后，会放弃所属权。</li><li>由于 entry3 处于 outstanding 的状态， 还没有被写到 bookie 上。 继续往下读，发现没有 bookie 对下面的数据读写，就会采取关闭的操作，并将最后一条 entry 写回去。</li><li>开启一个新的 ledger ，开始写入</li></ol><h5 id="2-Bookie-Recovery"><a href="#2-Bookie-Recovery" class="headerlink" title="2. Bookie Recovery"></a>2. Bookie Recovery</h5><p>todo。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar 读写性能调优</title>
      <link href="/2021/06/15/pulsar/pulsar%20%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
      <url>/2021/06/15/pulsar/pulsar%20%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h3 id="一、缓存概念"><a href="#一、缓存概念" class="headerlink" title="一、缓存概念"></a>一、缓存概念</h3><h5 id="1-broker层面缓存"><a href="#1-broker层面缓存" class="headerlink" title="1. broker层面缓存"></a>1. broker层面缓存</h5><p>在 broker 层面里，存在一个 <strong>managed ledger</strong> 库，也就相当于 topic。也就是说每一个 topic 后边都有一个 managed ledger 进行服务存储等。</p><p>它会把 topic 里用到的所有 ledger 进行管理，并记录到元数据里。同时在消费订阅层面，也会将其订阅进度、消息签收进度等进行记录。</p><p><strong>managed ledger cache</strong>  ：新写入的数据会进行缓存</p><h5 id="2-bookkeeper层面缓存"><a href="#2-bookkeeper层面缓存" class="headerlink" title="2. bookkeeper层面缓存"></a>2. bookkeeper层面缓存</h5><p>entry 写入 journal log 时，同时也会写入到 memory table 里，这时客户端认定为写入成功。这时会提出一个 check point，当满足 checkpoint 后，会把一段时间内的 journal log 数据放置到 entry log 里。而 index DB 则主要是记录 entry 放置在 entry log 的位置信息。</p><h3 id="二、写入时优化"><a href="#二、写入时优化" class="headerlink" title="二、写入时优化"></a>二、写入时优化</h3><h5 id="1-开启分片"><a href="#1-开启分片" class="headerlink" title="1. 开启分片"></a>1. 开启分片</h5><h5 id="2-加大内存"><a href="#2-加大内存" class="headerlink" title="2. 加大内存"></a>2. 加大内存</h5><p>producer 生产消息时，是先把消息放到队列中的，如果队列满了，消息是会被阻塞的。</p><h5 id="3-批量消息"><a href="#3-批量消息" class="headerlink" title="3.  批量消息"></a>3.  批量消息</h5><p>开启 batched 后，调动的 broker 数量减少，调用 bookie 次数也减少了，从而可以减少客户端和服务端的cpu使用，提升消息发送和读取的吞吐量。</p><h5 id="4-数据压缩"><a href="#4-数据压缩" class="headerlink" title="4. 数据压缩"></a>4. 数据压缩</h5><h5 id="5-bookie-写入优化"><a href="#5-bookie-写入优化" class="headerlink" title="5. bookie 写入优化"></a>5. bookie 写入优化</h5><p>消息持久化配置的选项，5-3-2 模式，会比 5-5-5的模式有更高的性能</p><h5 id="6-优化参数参考"><a href="#6-优化参数参考" class="headerlink" title="6. 优化参数参考"></a>6. 优化参数参考</h5><p><strong>Broker 端</strong></p><ol><li><p>managedLedgerDefaultEnsembleSize</p></li><li><p>managedLedgerDefaultWriteQuorum</p></li><li><p>managedLedgerDefaultAckQuorum</p></li><li><p>managedLedgerNumWorkerThreads</p></li><li><p>numIOThreads</p></li><li><p>Dorg.apache.bookkeeper.conf.readsystemproperties=true -DnumIOThreads=8</p></li></ol><p><strong>Bookie 端</strong></p><ol><li><p>Journal Directories</p></li><li><p>Ledger Directories</p></li><li><p>Journal sync data</p></li><li><p>Journal group commit</p></li><li><p>Write cache</p></li><li><p>Flush interval</p></li><li><p>Add worker threads and max pending add requests</p></li><li><p>Journal pagecache flush interval</p></li></ol><h3 id="三、读取时优化"><a href="#三、读取时优化" class="headerlink" title="三、读取时优化"></a>三、读取时优化</h3><h5 id="1-加大内存"><a href="#1-加大内存" class="headerlink" title="1. 加大内存"></a>1. 加大内存</h5><p>消息读取其实跟写入差不多，也有一个 queue</p><h5 id="2-批量读取数据"><a href="#2-批量读取数据" class="headerlink" title="2. 批量读取数据"></a>2. 批量读取数据</h5><h5 id="3-多consumer"><a href="#3-多consumer" class="headerlink" title="3. 多consumer"></a>3. 多consumer</h5><h5 id="4-优化参数参考"><a href="#4-优化参数参考" class="headerlink" title="4. 优化参数参考"></a>4. 优化参数参考</h5><p><strong>Bookie 端</strong></p><ol><li><p>dbStorage_rocksDB_blockCacheSize</p></li><li><p>dbStorage_readAheadCacheMaxSizeMb</p></li><li><p>dbStorage_readAheadCacheBatchSize</p></li><li><p>Read worker threads</p></li></ol><p><strong>Broker 端</strong></p><ol><li><p>Managed ledger cache</p></li><li><p>Dispatcher max read batch size</p></li><li><p>Bookkeeper sticky reads</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topic Discovery, ServiceURL and Cluster</title>
      <link href="/2021/06/12/pulsar/Topic%20Discovery,%20ServiceURL%20and%20Cluster/"/>
      <url>/2021/06/12/pulsar/Topic%20Discovery,%20ServiceURL%20and%20Cluster/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Topic-Discovery"><a href="#一、Topic-Discovery" class="headerlink" title="一、Topic Discovery"></a>一、Topic Discovery</h3><h5 id="1-Topic-Assignment"><a href="#1-Topic-Assignment" class="headerlink" title="1. Topic Assignment"></a>1. Topic Assignment</h5><p>首先看一下层次化结构</p><p><img src="assets/image-20210613110219438.png" alt="image-20210613110219438"></p><p>根据图上所示，topic 的分配是按照 namespace 来划分的</p><p>一个 namespace 下面会有很多个 topic，namespace 会把所有的 topic 组成一个环（<strong>namespace hash ring</strong>）。在 topic 分配之前，会把 topic 的名字 hash 到 namespace hash ring 里。然后根据不同 topic 的 hash 值 又会分为几个小组， 也就是 <strong>namespace bundle</strong>， bundle 的数量可以在创建 namespace 时就可以指定确认了。</p><p>topic 映射 到 bundle 后，接下来就会将 bundle 分配给 broker。 也就是 topic 的分配不在于 topic 本身，而是 bundle 操作。处理过程依靠 <strong>load Maneger</strong> 进行，对 bundle 进行分配。</p><p>load manager 是从 broker 中选出来的一台。 topic 分配到 broker 的过程，全程是由 load manager 来执行的。</p><p><img src="assets/image-20210613132008908.png" alt="image-20210613132008908"></p><h5 id="2-Topic-lookup"><a href="#2-Topic-lookup" class="headerlink" title="2. Topic lookup"></a>2. Topic lookup</h5><p>topic 如何找到对应的那台 broker呢？</p><p>先介绍一个概念：Topic owner ，又可以称为 namespace bundle owner 。</p><p>topic 与 broker 的映射关系，存储在 owner 中， owner存储在zookeeper中，任何一个 broker 都可以获取到 topic 到 owner 的映射关系。 </p><p>lookup 流程：</p><p>pulsar 客户端发起 topic lookup 请求给 broker，broker 开启 lookup模式，根据 namespace 去检测出映射的 bundle， 然后将此反馈发给 zookeeper 去查找对应，最后将请求结果返回给客户端。</p><p>客户端这时， 会根据请求结果和目标 broker 进行 tcp 长链接。</p><p><img src="assets/image-20210613134047938.png" alt="image-20210613134047938"></p><p>有个问题，这个时候如果目标 broker 的地址不能直接链接，该怎么办？</p><p>解决方案：</p><p>使用 pulsar proxy 。它提供了 topic 查询路由功能，可以作为 tcp 反向代理来使用</p><h3 id="二、ServiceURL"><a href="#二、ServiceURL" class="headerlink" title="二、ServiceURL"></a>二、ServiceURL</h3><p>知道了整个 topic discovery 之后。对 service URL 的使用就会更加准确了</p><p>service URL 高可用的几种方式</p><p>DNS：在 broker 之前配置一个 DNS，落实到 broker 里。 缺点是 过期时间和缓存限制</p><p>Load Balance：可以探测活跃的 broker，可以及时清理 broker。</p><p>Multi-Hosts：把所有机器当做一个列表，pulsar客户端进行负载均衡，第一次用第一个broker，链接失败用第二个，以此类推</p><h3 id="三、Clusters"><a href="#三、Clusters" class="headerlink" title="三、Clusters"></a>三、Clusters</h3><p>部署 pulsar 集群的时候，需要制定 cluster name， 集群配置信息作为元数据保存到 zookeeper 上。</p><p>在 cluster 配置文件里，主要是四个接入端口，分为两大类。</p><p><strong>HTTP service</strong>：即提供 admin 操作的接口</p><ul><li>Web service URL (http://)</li><li>Web service URL TLS (https://)</li></ul><p><strong>Broker service</strong>：即客户端、producer、consumer 等需要连接的 6650 端口。</p><ul><li>Broker service URL (pulsar://)</li><li>Broker service URL TLS (pulsar+ssl://)</li></ul><p>这几个参数只有在进行跨机房复制时才使用。</p>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar messager lifecycle</title>
      <link href="/2021/06/11/pulsar/pulsar%20messager%20lifecicle/"/>
      <url>/2021/06/11/pulsar/pulsar%20messager%20lifecicle/</url>
      
        <content type="html"><![CDATA[<p>在介绍消息的生命周期之前，先看一下 pulsar 的架构</p><h3 id="一、pulsar-集群"><a href="#一、pulsar-集群" class="headerlink" title="一、pulsar 集群"></a>一、pulsar 集群</h3><h5 id="1-Brokers-Bookies"><a href="#1-Brokers-Bookies" class="headerlink" title="1. Brokers + Bookies"></a>1. Brokers + Bookies</h5><p>broker 是各个组件之间进行交互的对象。pulsar 是分层架构模式，使用 Bookkeeper 作为额外的存储系统， bookies 就是 Bookkeeper 里的存储节点。</p><p>Brokers + Bookies 构成 pulsar 的两个层次， 共同完成 pulsar 的数据服务</p><p>Broker： 整个消息层的生产和消费，无存储状态</p><p>Bookie： 数据持久化保存的节点，有存储状态</p><h5 id="2-Zookeeper"><a href="#2-Zookeeper" class="headerlink" title="2. Zookeeper"></a>2. Zookeeper</h5><p>Zookeeper 在 Pulsar 里的作用是存储 Pulsar 系统里的元数据和集群的管理以及节点的发现等，节点发现就是发现集群中有哪些 broker 哪些 bookie 。</p><p>以上的三个组件，构成了 Pulsar 的集群。Brokers + bookies 为数据服务，Zookeeper 为元数据服务。</p><p><img src="assets/image-20210611184242420.png" alt="image-20210611184242420"></p><h3 id="二、message-lifecycle"><a href="#二、message-lifecycle" class="headerlink" title="二、message lifecycle"></a>二、message lifecycle</h3><h5 id="1-producer-生产消息（写过程）"><a href="#1-producer-生产消息（写过程）" class="headerlink" title="1. producer 生产消息（写过程）"></a>1. producer 生产消息（写过程）</h5><p>producer 通过生产消息到一个 topic， 一个 topic 中可能有 N 个 partition， 每个 partition 给一个 broker 服务。</p><p>生产者内部有一个 MessageWriter 的类， 这个 MessageWriter 默认是 round-robin 的过程，就是发送每条消息的时候回去轮训找到一个 partition 进行发送，但为了提高效率，在一段时间内只会选择一个 partition 进行发送。如果 message 指定了 key，那么会根据 key 的hash去找到对应的 partition 进行发送。</p><p>之后 Broker 收到消息后会调用 BookKeeper 的客户端并发去写多个 bookie 副本。当 broker 收到一定数量的 ACK 后，他会认为消息已经写入成功，broker 返回客户端，告知这条消息已经被持久化完成。</p><p>整个写的过程消息是从 producer 到 broker，broker 到 Bookkeeper 上。 整个过程中客户端都不会跟Zookeeper打交道，也不会和 Bookkeeper打交道， 只和 Broker 打交道。</p><h5 id="2-consumer-消费消息（读过程）"><a href="#2-consumer-消费消息（读过程）" class="headerlink" title="2. consumer 消费消息（读过程）"></a>2. consumer 消费消息（读过程）</h5><h6 id="2-1-broker-有缓存的情况下"><a href="#2-1-broker-有缓存的情况下" class="headerlink" title="2.1 broker 有缓存的情况下"></a>2.1 broker 有缓存的情况下</h6><p>Broker 可能已经缓存了部分信息，consumer 在连接到 broker 后建立长链接， broker 把消息从内存里拿出来通过推得方式 dispatch 给 consumer， consumer 收到消息后会放到消费端的 receiver queue 中，consumer 就可以消费了，完了发送确认ack给broker。</p><h6 id="2-2-broker-没有缓存的情况下"><a href="#2-2-broker-没有缓存的情况下" class="headerlink" title="2.2 broker 没有缓存的情况下"></a>2.2 broker 没有缓存的情况下</h6><p>broker 没有缓存这部分数据，需要去 bookie 去读取数据， 数据读取出来后再 dispatch 给 consumer，读取是选择任意一个存储节点读取的，整个存储架构没有主节点的说法。</p><h5 id="3-Data-Retention"><a href="#3-Data-Retention" class="headerlink" title="3. Data Retention"></a>3. Data Retention</h5><h6 id="3-1-Subscription-Initial-Position"><a href="#3-1-Subscription-Initial-Position" class="headerlink" title="3.1 Subscription Initial Position"></a>3.1 Subscription Initial Position</h6><p>之前整理了 subscription 和 cursor 的概念。如果有个新的订阅是pulsar中没有的，那么如何创建 cursor？</p><p>这里就有两个概念</p><p>earliest：放到整个流中第一条有效数据</p><p>latest: 放到整个流中最后一条有效数据 (默认的)</p><p>Cursor 放置的位置，决定了最终消费了什么数据</p><p><img src="assets/image-20210611195453885.png" alt="image-20210611195453885"></p><h6 id="3-2-Message-Retention"><a href="#3-2-Message-Retention" class="headerlink" title="3.2 Message Retention"></a>3.2 Message Retention</h6><p>消费位置最早的订阅决定了你能保留消息多久，订阅之前的消息可以被删除。这是 pulsar 的默认行为， 即消费完就可以被删除， 释放空间留给之后的消息使用。</p><p>由于流计算的需求，有些数据消费完还不能删除，需要再额外保留个三五天。就需要 retention 来进行数据的保留设置</p><p><img src="assets/image-20210611200055467.png" alt="image-20210611200055467"></p><p>添加后 retention 后, 紫色部分的内容就是该保留的数据，可以配置多大内存/多少天。但前提是被所有订阅消费完了</p><h6 id="3-3-TTL"><a href="#3-3-TTL" class="headerlink" title="3.3 TTL"></a>3.3 TTL</h6><p>还有一种情况就是，生产者一直在生产消息，但是消费者一直没有处理，那么消息永远不会被确认，那么这个消息会被一直累积。</p><p>为了保障消息不会被一只累加下去，可以在这写橘色消息部分加上TTL，TTL作用范围是没被确认的消息。</p><p><img src="assets/image-20210611200532518.png" alt="image-20210611200532518"></p><p>在TTL之后，消息会到Retention中，然后再经理过Retention中设置的时间，进行最后的数据清除。</p><h6 id="3-4-Message-Deletion"><a href="#3-4-Message-Deletion" class="headerlink" title="3.4 Message Deletion"></a>3.4 Message Deletion</h6><p>正常理解是，消息过期后就会被删除，但是在pulsar中，消息的删除是按照 片（segment） 进行的。</p><p><img src="assets/image-20210611200921982.png" alt="image-20210611200921982"></p><p>例如上图，删除的是 S1 这个分片，而S2 不会被删除，因为只有分片中所有的消息是待删除状态，才会去删除这个分片。</p><h6 id="3-5-storage-size"><a href="#3-5-storage-size" class="headerlink" title="3.5 storage size"></a>3.5 storage size</h6><p>storage size是计算所有没被删除的 segment 所占用的存储空间。</p><p>整个存储空间是按照 segment 之间的存储力度进行计算的，同时 garbage collector 是定时执行的，所有有时候可以发现 segement 已经被清空了，但是 storage size 仍然没有变化。</p>]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pulsar基础</title>
      <link href="/2021/06/10/pulsar/pulsar%20%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/06/10/pulsar/pulsar%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>Pulsar 是一个用于服务器到服务器的消息系统，具备高吞吐，低延迟，计算存储分离，多租户，异地复制等特性，这些特性也使得Pulsar成为kafka的有力竞争者</p><h3 id="二、Pub-Sub"><a href="#二、Pub-Sub" class="headerlink" title="二、Pub/Sub"></a>二、Pub/Sub</h3><p>下面介绍pulsar做为一个发布订阅消息中间件的一些主要概念</p><ul><li>Message</li><li>Producer</li><li>Consumer</li><li>Broker</li><li>Topic</li><li>Subscription</li></ul><h5 id="1-Message"><a href="#1-Message" class="headerlink" title="1. Message"></a>1. Message</h5><p>消息是 Pulsar 的基础单元，Producer 发送消息，Consumer 消费消息，Broker 保存消息。</p><h6 id="1-1-消息的组成"><a href="#1-1-消息的组成" class="headerlink" title="1.1 消息的组成"></a>1.1 消息的组成</h6><ol><li>data：数据</li><li>key：消息键，非常重要的一个概念，消息的发送和路由都与它有关</li><li>property：键值对，存放一些主数据之外的额外消息</li><li>producer name：消费者名</li><li>sequence id:   序列号。消息去重会使用到这个参数，相同的序列号只会发送一次</li><li>publish time：发布时间</li><li>event time:  事件事件</li><li>TypedMessageBuilder:  用于构建消息</li></ol><h5 id="2-Producer"><a href="#2-Producer" class="headerlink" title="2. Producer"></a>2. Producer</h5><p>Producer 可以发送消息到指定的 topic。往 Pulsar 里发送消息时，相应的数据会带上 schema 的信息。Pulsar 会确保一个 producer 往 topic 发送的消息是满足一定的 schema 格式。</p><h6 id="2-1-发送模式"><a href="#2-1-发送模式" class="headerlink" title="2.1 发送模式"></a>2.1 发送模式</h6><p>同步发送send，异步发送sendAsync</p><h6 id="2-2-批量处理"><a href="#2-2-批量处理" class="headerlink" title="2.2 批量处理"></a>2.2 批量处理</h6><p>通过设置enableBatching、batchingMaxMessages、maxPendingMessages等，来设置批量消息的发送规则。</p><h6 id="2-3-消息压缩"><a href="#2-3-消息压缩" class="headerlink" title="2.3 消息压缩"></a>2.3 消息压缩</h6><p>通过设置compressionType，来指定压缩类型</p><h6 id="2-4-分块"><a href="#2-4-分块" class="headerlink" title="2.4 分块"></a>2.4 分块</h6><p>分块的前提是禁用批量处理</p><h5 id="3-Consumer"><a href="#3-Consumer" class="headerlink" title="3. Consumer"></a>3. Consumer</h5><p>consumer与broker建立TCP长链接，然后开始接受从broker的推送来的消息。同时也会根据schema来格式化消息</p><h6 id="3-1-接收模式"><a href="#3-1-接收模式" class="headerlink" title="3.1 接收模式"></a>3.1 接收模式</h6><p>同步接收</p><p>异步接收，返回一个CompletableFuture</p><h6 id="3-2-ACK"><a href="#3-2-ACK" class="headerlink" title="3.2 ACK"></a>3.2 ACK</h6><p>确认消息/取消确认：消费者成功/失败消费一条消息，这条消费者会发送一个确认消息/取消确认给broker。成功的话，这条消息会根据消息保留策略来进行删除。</p><h6 id="3-3-监听器"><a href="#3-3-监听器" class="headerlink" title="3.3 监听器"></a>3.3 监听器</h6><p>通过MesssageListener可以监听接受的每条消息，通过received方法进行逻辑处理</p><h6 id="3-4-死信、重试队列"><a href="#3-4-死信、重试队列" class="headerlink" title="3.4 死信、重试队列"></a>3.4 死信、重试队列</h6><p>设置了死信队列，消费者消费一条消息时，当超时或者否定确认，这条消息会被重新传递，当多次的重新传递后，这条消息会被放入到指定的死信topic中。</p><p>重试队列，当消费者消费一条消息时，当超时或者否定确认，默认会进行重试。</p><h6 id="3-5-Cursor-和-Reader"><a href="#3-5-Cursor-和-Reader" class="headerlink" title="3.5 Cursor 和 Reader"></a>3.5 Cursor 和 Reader</h6><p>Cursor 在消费者端，代表了每组订阅组的消费状态。 broker 的 cursor 会追踪每个订阅消费到了哪里，然后记录下来。</p><p>Reader 和 Cursor 不同， cursor 是 pulsar帮你管理消费状态信息，但是 Reader 是一个没有状态的，消息被消费了，它消费状态不会持久化。也就是下次再读取的时候还是能读取到。</p><h5 id="4-Broker"><a href="#4-Broker" class="headerlink" title="4. Broker"></a>4. Broker</h5><p>分区落靠的服务器，就是 Broker。Broker 用来接收与发送消息，生产方连接到 broker 去生产消息，消费方连接到 broker 去消费消息。</p><p>数据不会存储在 Broker 上，是放在 Bookkeeper 中。这也是 Pulsar 与其他中间件的区别。</p><h5 id="5-Topic"><a href="#5-Topic" class="headerlink" title="5. Topic"></a>5. Topic</h5><p>topic是消息的集合，所有的producer的消息，都会归属到指定的topic里。所有topic里的消息，会按照一定的规则，被切分成不同的分区（Partition）。一个分区会落到一台broker上。</p><p>topic格式：{persistent|non-persistent}://tenant/namespace/topic</p><p>pulsar层级化的管理，使用 Tenant 和 namespace。 </p><h5 id="6-Subscription"><a href="#6-Subscription" class="headerlink" title="6. Subscription"></a>6. Subscription</h5><p>consumer 连接到 broker，需要定义自己的 Subscription ，一个订阅的所有 consumer 会作为一个整体去消费 topic 里的所有消息。</p><h6 id="6-1-订阅模式"><a href="#6-1-订阅模式" class="headerlink" title="6.1 订阅模式"></a>6.1 订阅模式</h6><p>四种模式：Exclusive、Failover、Shared、Key_Shared</p><p>Exclusive：只有一个 consumer 可以消费消息。</p><p>Failover：一个消费者作为一个主题分区( partition, 一个 topic 会有多个 partition ) 的主使用者，其他消费者被作为故障转移备用。</p><p>Shared:  消息会轮训发送给该订阅下的所有 consumer 。</p><p>Key_Shared：消息按照 key 进行分发给 consumer。融合了 Failover 和 Shared 的特性。</p><h3 id="三、schema"><a href="#三、schema" class="headerlink" title="三、schema"></a>三、schema</h3><p>Schema 的作用就是如何序列化反序列化数据，不用在客户端另外去做处理。</p><p><strong>schema 的格式</strong></p><ul><li>type：schema类型</li><li>schema：schema 定义，和数据</li><li>properties：跟 schema 关联的部分属性</li></ul><p><strong>两类 schema</strong></p><ul><li>key-value：要同时定义 key schema 和 value schema，将这两者的信息组合在一起放置在 schema 信息文件内</li><li>struct ：AVRO、JSON、Protobuf 三种类型</li></ul><p><strong>schema 的兼容性检查</strong></p><img src="assets/image-20210615194709854.png" alt="image-20210615194709854" style="zoom: 50%;" />]]></content>
      
      
      <categories>
          
          <category> pulsar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pulsar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
      <url>/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>堆(Heap)</strong>是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵<a href="https://baike.baidu.com/item/完全二叉树/7773232" target="_blank" rel="noopener">完全二叉树</a>的数组对象。</p><h2 id="1、二叉堆"><a href="#1、二叉堆" class="headerlink" title="1、二叉堆"></a>1、二叉堆</h2><p>二叉堆是完全二元树或者是近似完全二元树，按照数据的排列方式可以分为两种：最大堆和最小堆。</p><p>二叉堆一般都通过”数组”来实现</p><h2 id="2、左倾堆"><a href="#2、左倾堆" class="headerlink" title="2、左倾堆"></a>2、左倾堆</h2><p>左倾堆(leftist tree 或 leftist heap)，又被成为左偏树、左偏堆，最左堆等。</p><p>它和二叉堆一样，都是优先队列实现方式。可以高效解决”对两个优先队列进行合并”的问题。</p><p><img src="https://imine141.github.io/images/1559037013198.png" alt="img"></p><p>上图是一颗左倾树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：键值和零距离。</p><ul><li>键值：作用是来比较节点的大小，从而对节点进行排序。</li><li>零距离：是从一个节点到一个”最近的不满节点”的路径长度。不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。</li></ul><p>左倾堆有以下几个基本性质：</p><ul><li>节点的键值小于或等于它的左右子节点的键值。</li><li>节点的左孩子的NPL &gt;= 右孩子的NPL。</li><li>节点的NPL = 它的右孩子的NPL + 1。</li></ul><p>合并两个左倾堆的基本思想如下：</p><ol><li>如果一个空左倾堆与一个非空左倾堆合并，返回非空左倾堆。</li><li>如果两个左倾堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li><li>如果新堆的右孩子的NPL &gt; 左孩子的NPL，则交换左右孩子。</li><li>设置新堆的根节点的NPL = 右子堆NPL + 1</li></ol><h2 id="3、斜堆"><a href="#3、斜堆" class="headerlink" title="3、斜堆"></a>3、斜堆</h2><p>斜堆也叫自适应堆，它是左倾堆的一个变种。和左倾堆一样，它通常也用于实现优先队列；作为一种自适应的左倾堆，它的合并操作的时间复杂度也是O(log n)。</p><p>它与左倾堆的差别是：</p><ol><li>斜堆的节点没有”零距离”这个属性，而左倾堆则有。</li><li>斜堆的合并操作和左倾堆的合并操作算法不同。</li></ol><p>斜堆的合并操作</p><ol><li>如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。</li><li>如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li><li>合并后，交换新堆根节点的左孩子和右孩子。</li></ol><p>第 3 步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。</p><h2 id="4、二项堆"><a href="#4、二项堆" class="headerlink" title="4、二项堆"></a>4、二项堆</h2><p>二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。</p><h3 id="1）二项树"><a href="#1）二项树" class="headerlink" title="1）二项树"></a>1）二项树</h3><p>二项树是一种递归定义的有序树。它的递归定义如下：</p><ol><li>二项树B0只有一个结点；</li><li>二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。</li></ol><p><img src="https://imine141.github.io/images/1559037015017.png" alt="img"></p><h3 id="2）二项堆"><a href="#2）二项堆" class="headerlink" title="2）二项堆"></a>2）二项堆</h3><p>二项堆和之前所讲的堆(二叉堆、左倾堆、斜堆)一样，也是用于实现优先队列的。二项堆是指满足以下性质的二项树的集合：</p><ol><li>每棵二项树都满足最小堆性质。即，父节点的关键字 &lt;= 它的孩子的关键字。</li><li>不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。</li></ol><p><img src="https://imine141.github.io/images/1559037015069.png" alt="img"></p><h2 id="5、斐波那契堆"><a href="#5、斐波那契堆" class="headerlink" title="5、斐波那契堆"></a>5、斐波那契堆</h2><p>斐波那契堆(Fibonacci heap)是一种可合并堆，可用于实现合并优先队列。它比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。</p><p>与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。</p><p>与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是有根而无序的。</p><p><img src="https://imine141.github.io/images/1559037015086.png" alt="img"></p><h2 id="6、索引堆"><a href="#6、索引堆" class="headerlink" title="6、索引堆"></a>6、索引堆</h2><p>索引堆是对堆进行了优化。</p><p>索引堆使用了一个新的int类型的数组，用于存放索引信息。</p><p>索引堆的交换操作交换的是元素的索引，而不是直接交换元素。</p><h2 id="7、Treap-树堆"><a href="#7、Treap-树堆" class="headerlink" title="7、Treap 树堆"></a>7、Treap 树堆</h2><p>一棵treap是一棵修改了结点顺序的二叉查找树，如图，显示一个例子，通常树内的每个结点x都有一个关键字值key[x]，另外，还要为结点分配priority[x]，它是一个独立选取的随机数。</p><p><img src="https://imine141.github.io/images/1559037015141.png" alt="img"></p><p>假设所有的优先级是不同的，所有的关键字也是不同的。treap的结点排列成让关键字遵循二叉查找树性质，并且优先级遵循最小堆顺序性质：</p><ol><li>如果v是u的左孩子，则key[v] &lt; key[u].</li><li>如果v是u的右孩子，则key[v] &gt; key[u].</li><li>如果v是u的孩子，则priority[u] &gt; priority[u].</li></ol><p>这两个性质的结合就是为什么这种树被称为“treap”的原因，因为它同时具有二叉查找树和堆的特征。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
      <url>/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、图的基本概念"><a href="#一、图的基本概念" class="headerlink" title="一、图的基本概念"></a>一、图的基本概念</h2><p>图：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合。E 是图 G 中边的集合。</p><h3 id="1、各种图定义"><a href="#1、各种图定义" class="headerlink" title="1、各种图定义"></a>1、各种图定义</h3><ul><li><strong>无向边</strong>：若顶点 <code>V_i</code> 到 <code>V_j</code>，之间的边没有方向，则称这条边为无向边(Edge)。<ul><li>用无序偶对 (<code>V_i</code>，<code>V_j</code>) 来表示。</li></ul></li><li><strong>有向边</strong>：若从顶点 <code>V_i</code> 到 <code>V_j</code>的边有方向，则称这条边为有向边，也称为弧（Arc）。<ul><li>用有序偶&lt;<code>V_i</code>，<code>V_j</code>&gt;来表示 . <code>V_i</code>称为弧尾，<code>V_j</code>称为弧头。</li></ul></li><li><strong>无向图</strong>：如果图中任意两个顶点之间的边都是无向边，则称该图为无向图(Undirected graphs)。</li><li><strong>有向图</strong>：如果图中任意两个顶点之间的边都是有向边，则称该图为有向图(Directed graphs)。</li><li><strong>无向完全图</strong>：在无向图中，如果任意两个顶点之间都存在边，则称该因为无向完全图。<ul><li>含有 n 个顶点的无向完全图有  n(n-1)/2  条边。</li></ul></li><li><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。<ul><li>含有 n 个顶点的有向完全图有 <code>n*(n-1)</code> 条边</li></ul></li><li><strong>权</strong>：与图的边或弧相关的数叫做权(Weight)</li><li><strong>网</strong>：带权的图通常称为网 (Network) 。</li><li><strong>简单图</strong>：在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</li><li>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>。稀疏、稠密是相对的。</li><li><strong>子图</strong>：假设有两个图 G= (V,{E}) 和 G’= (V’,{E’}) ，如果 <code>V&#39;为 V的子图</code> 且 <code>E&#39;为 E的子图</code>，则称 G’ 为 G 的子图。</li></ul><h3 id="2、图的顶点与边间关系"><a href="#2、图的顶点与边间关系" class="headerlink" title="2、图的顶点与边间关系"></a>2、图的顶点与边间关系</h3><ul><li><strong>邻接点</strong>：无向图中，顶点之间如有边相连，则互为邻接点</li><li><strong>顶点的度</strong>：记为TD(v)<ul><li>无向图中，和顶点相关联的边的数目，就是顶点的度</li><li>有向图中，TD(v) = ID(v) + OD(v)<ul><li><strong>入度</strong>：有向图中，以顶点为头的弧的数目，记为ID(v)</li><li><strong>出度</strong>：有向图中，以顶点为尾的弧的数目，记为OD(v)</li></ul></li></ul></li><li><strong>路径</strong>：<ul><li>无向图中，顶点到顶点的路径是一个顶点序列</li><li>有向图中，路径也是有向的</li><li><strong>路径的长度</strong>：是路径上的边或弧的数目。</li></ul></li><li><strong>回路或环</strong>：第一个顶点到最后一个顶点相同的路径称为回路或环</li><li><strong>简单路径</strong>：序列中顶点不重复出现的路径称为简单路径</li><li><strong>简单回路</strong>：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</li></ul><h3 id="3、连通图相关术语"><a href="#3、连通图相关术语" class="headerlink" title="3、连通图相关术语"></a>3、连通图相关术语</h3><ul><li><strong>连通</strong>：无向图中，如果顶点间有路径，则称为连通的</li><li><strong>连通图</strong>：无向图中，如果图中任意两个顶点都是连通的，则为连通图</li><li><strong>强连通图</strong>：有向图中，每一对顶点之间都<em>相互</em>存在路径，则为强连通图</li><li><strong>连通分量</strong>：无向图中的<em>极大</em>连通子图称为连通分量</li><li><strong>强连通分量</strong>：有向图中的<em>极大</em>强连通子图称做有向图的强连通分量。</li><li><strong>生成树</strong>：无向图中连通且有 n 个顶点 n-l 条边。</li><li><strong>有向树</strong>：有向图恰有一个顶点的入度为 0 ，其余顶点的入度均为 1。</li><li><strong>生成森林</strong>：一个有向图的生成森林由若干棵有向树组成 ， 含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</li></ul><h2 id="二、图的存储及基本操作"><a href="#二、图的存储及基本操作" class="headerlink" title="二、图的存储及基本操作"></a>二、图的存储及基本操作</h2><h3 id="1、邻接矩阵：适合稠密图"><a href="#1、邻接矩阵：适合稠密图" class="headerlink" title="1、邻接矩阵：适合稠密图"></a>1、邻接矩阵：适合稠密图</h3><p>邻接矩阵 (Adjacency Matrix)用两个数组来表示图：</p><ul><li><p>一维数组：存储图中顶点信息</p></li><li><p>二维数组：存储图中的边或弧的信息。</p></li></ul><h4 id="1）无向图"><a href="#1）无向图" class="headerlink" title="1）无向图"></a>1）无向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE1" alt="img"></p><ul><li>无向图的边数组是一个对称矩阵</li><li>有无边：arc[i][j] 是否为 1</li><li>顶点的度：顶点<code>v_i</code>在邻接矩阵中第 i 行(或第 i列)的元素之和</li><li>邻接点：邻接矩阵中第 i 行元素值为 1 就是顶点<code>v_i</code>的邻接点。</li></ul><h4 id="2）有向图"><a href="#2）有向图" class="headerlink" title="2）有向图"></a>2）有向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE2" alt="img"></p><ul><li>有向图的矩阵不对称。</li><li>有无弧：arc[i][j] 是否为 1</li><li>入度：第 i 行元素之和</li><li>出度：第 i 列元素之和</li><li>邻接点：第 i 行元素值为 1 的</li></ul><h4 id="3）网"><a href="#3）网" class="headerlink" title="3）网"></a>3）网</h4><p>网的对应边或弧存权值</p><p><img src="https://imine141.github.io/images/%E5%9B%BE3.jpg" alt="img"></p><h3 id="2、邻接表：适合稀疏图"><a href="#2、邻接表：适合稀疏图" class="headerlink" title="2、邻接表：适合稀疏图"></a>2、邻接表：适合稀疏图</h3><p>邻接表(Adjacency List) 使用数组与链表相结合存储图</p><ul><li>一维数组：存顶点，和指向第一个邻接点的指针</li><li>单链表：存每个顶点的所有邻接点。邻接点在顶点表中的下标，</li></ul><h4 id="1）无向图-1"><a href="#1）无向图-1" class="headerlink" title="1）无向图"></a>1）无向图</h4><p><img src="https://imine141.github.io/images/%E5%9B%BE4.jpg" alt="img"></p><ul><li>度：顶点的边表中结点的个数</li><li>是否存在边：测试定点边表中是否存在结点下标</li><li>邻接点：顶点的边表</li></ul><h4 id="2）有向图-1"><a href="#2）有向图-1" class="headerlink" title="2）有向图"></a>2）有向图</h4><p>以顶点为弧尾来存储边表</p><p>有向图的逆邻接表：以顶点为弧头的边表</p><p><img src="https://imine141.github.io/images/%E5%9B%BE5.jpg" alt="img"></p><h4 id="3）网-1"><a href="#3）网-1" class="headerlink" title="3）网"></a>3）网</h4><p>在边表结点定义中再增加一个 weight 的数据域，存储权值信息</p><p><img src="https://imine141.github.io/images/%E5%9B%BE6.jpg" alt="img"></p><h3 id="3、十字链表：适合有向图"><a href="#3、十字链表：适合有向图" class="headerlink" title="3、十字链表：适合有向图"></a>3、十字链表：适合有向图</h3><p>对于有向图来说，邻接表是有缺陷的。出度入度只能关心一个。</p><p>十字链表把邻接表与逆邻接表结合起来。</p><ul><li>一维数组：顶点表结点<ul><li>data</li><li>firstin：入边表头指针</li><li>firstout：出边表头指针</li></ul></li><li>边表结点：<ul><li>tailvex：弧起点在顶点表的下标</li><li>headvex：弧终点在顶点表中的下标</li><li>headlink：入边表指针域</li><li>taillink ：边表指针域</li><li>weight：如果是网，存储权值</li></ul></li></ul><p>实线箭头指针的图示与邻接表相同。虚线箭头是逆邻接表的表示。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE7.jpg" alt="img"></p><h3 id="4、邻接多重表：适合处理无向图的边"><a href="#4、邻接多重表：适合处理无向图的边" class="headerlink" title="4、邻接多重表：适合处理无向图的边"></a>4、邻接多重表：适合处理无向图的边</h3><p>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中下标。ilink 指向依附顶点 ivex 的下一条边， jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构。</p><p>邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE8.jpg" alt="img"></p><h3 id="5、边集数组：适合对边依次处理"><a href="#5、边集数组：适合对边依次处理" class="headerlink" title="5、边集数组：适合对边依次处理"></a>5、边集数组：适合对边依次处理</h3><p>边集数组是由两个一维数组构成。一个是存储顶点的信息;另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标 (begin) 、终点下标 (end) 和权(weigbt) 组成</p><p><img src="https://imine141.github.io/images/%E5%9B%BE9" alt="img"></p><h2 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h2><p>图的遍历(Traversing Grapb)：从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次</p><h3 id="1、深度优先搜索"><a href="#1、深度优先搜索" class="headerlink" title="1、深度优先搜索"></a>1、深度优先搜索</h3><p>深度优先遍历(Depth_First_Search)，也有称为深度优先搜索，简称为 DFS。</p><p>类似于树的前序遍历，用数组记录访问：</p><ol><li>访问初始结点v，并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，否则算法结束。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li></ol><h3 id="2、广度优先搜索"><a href="#2、广度优先搜索" class="headerlink" title="2、广度优先搜索"></a>2、广度优先搜索</h3><p>广度优先遍历 (Breadth.First.Search) ，又称为广度优先搜索，简称 BFS。</p><p>类似于树的分层遍历，用队列保持访问过的结点的顺序：</p><ol><li>访问初始结点v并标记结点v为已访问。</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束。</li><li>出队列，取得队头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<ol><li>若结点w尚未被访问，则访问结点w并标记为已访问。</li><li>结点w入队列</li><li>查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol></li></ol><h2 id="四、图的基本应用"><a href="#四、图的基本应用" class="headerlink" title="四、图的基本应用"></a>四、图的基本应用</h2><h3 id="1、最小（代价）生成树"><a href="#1、最小（代价）生成树" class="headerlink" title="1、最小（代价）生成树"></a>1、最小（代价）生成树</h3><p>最小生成树： 一个具有n个顶点的加权的无向连通图，用n-1条边连接这n个顶点，并且使得连接之后的所有边的权值之和最小的树。</p><h4 id="1）普里姆-Prim-算法"><a href="#1）普里姆-Prim-算法" class="headerlink" title="1）普里姆 ( Prim )算法"></a>1）普里姆 ( Prim )算法</h4><ol><li>将点分为两拨，已经加入最小生成树的，未加入的</li><li>找到未加入中距离集合最近的点，添加该点，修改其它点到集合的距离</li><li>直到所有结点都加入到最小生成树</li></ol><h4 id="2）克鲁斯卡尔-Kruskal-算法"><a href="#2）克鲁斯卡尔-Kruskal-算法" class="headerlink" title="2）克鲁斯卡尔( Kruskal )算法"></a>2）克鲁斯卡尔( Kruskal )算法</h4><ol><li>现将所有边进行权值的从小到大排序</li><li>定义一个一维数组代表连接过的边，数组的下标为边的起点，值为边的终点</li><li>按照排好序的集合用边对顶点进行依次连接，连接的边则存放到一维数组中</li><li>用一维数组判断是否对已经连接的边能构成回路，有回路则无效，没回路则是一条有效边</li><li>重复3，4直至遍历完所有的边为止，即找到最小生成树</li></ol><h3 id="2、最短路径"><a href="#2、最短路径" class="headerlink" title="2、最短路径"></a>2、最短路径</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><h4 id="1）迪杰斯特拉-Dijkstra-算法"><a href="#1）迪杰斯特拉-Dijkstra-算法" class="headerlink" title="1）迪杰斯特拉( Dijkstra ) 算法"></a>1）迪杰斯特拉( Dijkstra ) 算法</h4><p>适用于求一个节点到其他节点的最短路径，通过广度搜索来遍历其他所有需要求距离的点。</p><ol><li>选取初始节点作为一个集合，D(v)表示初始节点到V节点的最短路径</li><li>所有能直接到达V的节点路径记为 D(v)=距离，不能直接到达的节点路径记为 D(v)=无穷</li><li>选取 D(v) 最小的节点加入初始节点集合，最短路径记为<code>D(w)=min(D(w),D(v)+j(v,w))</code>（j(v,w)为节点V到W的距离）</li><li>重复步骤3，直到所有节点都加入初始节点集合</li></ol><h4 id="2）弗洛伊德-Floyd-算法"><a href="#2）弗洛伊德-Floyd-算法" class="headerlink" title="2）弗洛伊德( Floyd )算法"></a>2）弗洛伊德( Floyd )算法</h4><p>适用于求所有顶点至所有顶点的最短路径问题。</p><p><img src="https://imine141.github.io/images/%E5%9B%BE10.jpg" alt="img"></p><ol><li>确定一个中间点</li><li>定义两个二维数组 D[][] 和 P[][]<ul><li>D 代表顶点到顶点的最短路径权值和的矩阵，即点的邻接矩阵</li><li>P 代表对应顶点的最小路径的前驱矩阵</li></ul></li><li>对于每一对顶点 v 和 w，看看是否存在一个顶点 u 使得从 v 到 u 再到 w 比己知的路径更短。</li></ol><h3 id="3、拓扑排序"><a href="#3、拓扑排序" class="headerlink" title="3、拓扑排序"></a>3、拓扑排序</h3><ul><li>AOV：有向无环图</li><li>拓扑序列：是一个有向无环图的所有顶点的线性序列。<ul><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ul></li><li>拓扑排序：对一个有向图构造拓扑序列的过程<ul><li>从 AOV 中选择一个入度为0的顶点并输出。</li><li>从图中删除该顶点，井删除以此顶点为尾的弧</li><li>重复此步骤，直到输出全部顶点，或不存在入度为0的顶点为止。</li></ul></li></ul><p>建立一个邻接表，在顶点表结点结构中，增加一个人度域 in</p><h3 id="4、关键路径"><a href="#4、关键路径" class="headerlink" title="4、关键路径"></a>4、关键路径</h3><ul><li>AOE：有向无环网</li><li>路径长度：路径上各个活动所持续的时间之和</li><li>关键路径：从源点到汇点具有最大长度的路径</li><li>关键活动：在关键路径上的活动</li></ul><h5 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h5><ol><li>事件最早开始时间（etv）：顶点<code>v_k</code>最早发生的时间。</li><li>事件最晚开始时间（ltv）：顶点<code>v_k</code>最晚发生的时间，超出则会延误整个工期。</li><li>活动的最早开始时间（ete）：弧<code>a_k</code>最早发生时间。</li><li>活动的最晚开始时间（lte）：弧<code>a_k</code>最晚发生时间。不推迟工期的最晚开工时间。</li></ol><p>由 1 和 2 可以求得 3 和 4 ，然后再根据 ete[k] 是否与 lte[k] 相等来判断<code>a_k</code>是 否是关键活动。</p><p>建立一个邻接表，弧链表增加了 weight 域，用来存储弧的权值。</p><ul><li>先要调用一次拓扑序列算法的代码来计算etv和拓扑序列表。</li><li>数组etv存储事件最早发生时间</li><li>数组ltv存储事件最迟发生时间</li><li>全局栈用来保存拓扑序列</li></ul><p>如果是多条关键路径，则单是提高一条关键路径上的关键活动速度并不是能导致整个工程缩短工期、而必须提高同时在几条关键路径上的活动的速度。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
      <url>/2020/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、树的基本概念"><a href="#一、树的基本概念" class="headerlink" title="一、树的基本概念"></a>一、树的基本概念</h2><p>树：是 n ( n&gt;=0 ) 个结点的有限集。</p><ul><li>n = 0 时称为空树。</li><li>在任意一棵非空树中:<ul><li>有且仅有一个根结点</li><li>当 n &gt; 1 时，其余结点可分为一个或多个互不相交的有限集。 其中每一个集合本身又是一棵树，并且称为根的子树。</li></ul></li></ul><h3 id="1、结点分类"><a href="#1、结点分类" class="headerlink" title="1、结点分类"></a>1、结点分类</h3><ul><li>结点的度：结点拥有的子树数</li><li>叶结点：度为 0 的结点</li><li>分支结点：度不为 0 的结点</li><li>树的度：树内各结点的度的最大值</li></ul><h3 id="2、结点间关系"><a href="#2、结点间关系" class="headerlink" title="2、结点间关系"></a>2、结点间关系</h3><ul><li>孩子：结点的子树的根称</li><li>双亲：上一结点</li><li>兄弟：同一个双亲的孩子</li><li>祖先：从根到该结点所经分支上的所有结点</li></ul><h3 id="3、树的其他相关概念"><a href="#3、树的其他相关概念" class="headerlink" title="3、树的其他相关概念"></a>3、树的其他相关概念</h3><ul><li>层次：根开始定义起，根为第一层 ，根的孩子为第二层</li><li>堂兄弟：双亲在同一层的结点</li><li>树的深度：树中结点的最大层次</li><li>有序树：树中结点的各子树从左至右有次序，不能互换</li><li>无序树：非有序树</li><li>森林：m (m&gt;=0) 互不相交的树的集合</li></ul><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h3 id="1、二叉树的定义"><a href="#1、二叉树的定义" class="headerlink" title="1、二叉树的定义"></a>1、二叉树的定义</h3><p>二叉树：是 n(n &gt;= 0) 个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><h4 id="1）主要特征"><a href="#1）主要特征" class="headerlink" title="1）主要特征"></a>1）主要特征</h4><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树.</li></ul><h4 id="2）特殊二叉树"><a href="#2）特殊二叉树" class="headerlink" title="2）特殊二叉树"></a>2）特殊二叉树</h4><ul><li>斜树：都只有一边子结点<ul><li>左斜树：所有的结点都只有左子树的二叉树</li><li>右斜树：所有结点都是只有右子树的二叉树</li><li>线性表结构可以理解为是树的一种极其特殊的表现形式</li></ul></li><li>满二叉树：每层结点都排满了</li><li>完全二叉树：按层排序，到结尾中间没有漏掉的结点</li></ul><h4 id="3）二叉树性质"><a href="#3）二叉树性质" class="headerlink" title="3）二叉树性质"></a>3）二叉树性质</h4><ul><li><p>在二叉树的第 i 层上至多有 <code>2^{i-1}</code> 个结点 (i &gt;= 1 ) 。</p></li><li><p>深度为 k 的二叉树至多有<code>2^k-1</code>个结点 (k &gt;= l) 。</p></li><li><p>对任何一棵二叉树 T，如果其终端结点数为 <code>n_0</code>，度为 2 的结点数为 <code>n_2</code>，则 <code>n_0 = n_2 +1</code>。</p></li><li><p>具有 n 个结点的完全二叉树的深度为 <code>[log_2n]+1</code> ([x] 表示不大于 x 的最大整数)。</p></li><li><p>如果对一棵有 n 个结点的完全二叉树(其深度为 <code>[log_2n]+1</code> ) 的结点按层序编号(从第 1 层到第<code>[log_2n]+1</code>层，每层从左到右) ，对任一结点 i (1&lt;= i&lt;= n)有:</p><ul><li>如果 i = 1 ，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1 ，则其双亲是结点 [i/2]。</li></ul></li><li><p>如果 2i &gt; n ，则结点 i 无左孩子(结点 i 为叶子结点)；否则其左孩子是结点 2i。</p><ul><li>如果 2i+1 &gt; n ，则结点 i 无右孩子；否则其右孩子是结点 2i+1 。</li></ul></li></ul><h3 id="2、二叉树的存储结构"><a href="#2、二叉树的存储结构" class="headerlink" title="2、二叉树的存储结构"></a>2、二叉树的存储结构</h3><h4 id="1）顺序存储结构"><a href="#1）顺序存储结构" class="headerlink" title="1）顺序存储结构"></a>1）顺序存储结构</h4><p>顺序存储结构一般只用于完全二叉树。</p><p>用一维数组存储二叉树中的结点，数组的下标和结点序号一致。没有结点的存空。</p><h4 id="2）链式存储结构"><a href="#2）链式存储结构" class="headerlink" title="2）链式存储结构"></a>2）链式存储结构</h4><p>二叉链表：一个数据域和两个指针域的链表。</p><p>指针域分别存左孩子和右孩子的指针。</p><h3 id="3、二叉树的遍历"><a href="#3、二叉树的遍历" class="headerlink" title="3、二叉树的遍历"></a>3、二叉树的遍历</h3><h4 id="1）遍历方法"><a href="#1）遍历方法" class="headerlink" title="1）遍历方法"></a>1）遍历方法</h4><ul><li>前序遍历：根节点-&gt;左子树-&gt;右子树</li><li>中序遍历：左子树-&gt;根节点-&gt;右子树</li><li>后序遍历：左子树-&gt;右子树-&gt;根节点</li><li>层序（宽度优先、广度优先）遍历：每一层从左向右输出</li></ul><p>前序、中序、后序遍历用迭代很简单。</p><p>层序遍历，元素储存有先进先出的特性，选用队列。</p><h4 id="2）遍历推导"><a href="#2）遍历推导" class="headerlink" title="2）遍历推导"></a>2）遍历推导</h4><ul><li>己知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树 。</li><li>已知前序和后序遍历，是不能确定一棵二叉树的</li></ul><h4 id="3）二叉树的建立"><a href="#3）二叉树的建立" class="headerlink" title="3）二叉树的建立"></a>3）二叉树的建立</h4><p>扩展二叉树：将每个结点的空指针引出一个虚结点，值为特定值（如“#”）</p><p>扩展二叉树可以用递归采用前序、中序、后序遍历的一个遍历序列就确定一颗二叉树。</p><h3 id="4、线索二叉树"><a href="#4、线索二叉树" class="headerlink" title="4、线索二叉树"></a>4、线索二叉树</h3><h4 id="1）基本概念"><a href="#1）基本概念" class="headerlink" title="1）基本概念"></a>1）基本概念</h4><ul><li>线索：指向前驱和后继的指针称为线索</li><li>线索链表：加上线索的二叉链表称为线索链表</li><li>线索化：将二叉链表中的空指针改为指向前驱或后继的线索</li></ul><p>线索二叉树，等于是把一棵二叉树转属变成了一个双向链表，对插入删除结点、查找某个结点都带来了方便</p><h4 id="2）构造"><a href="#2）构造" class="headerlink" title="2）构造"></a>2）构造</h4><p>每个结点增设两个标志域 ltag 和 rtag，区分指针是指向孩子还是指向前驱、后继。</p><p>在遍历的过程中修改空指针。</p><p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h2 id="三、树、森林"><a href="#三、树、森林" class="headerlink" title="三、树、森林"></a>三、树、森林</h2><h3 id="1、树的存储结构"><a href="#1、树的存储结构" class="headerlink" title="1、树的存储结构"></a>1、树的存储结构</h3><h4 id="1-）双亲表示法"><a href="#1-）双亲表示法" class="headerlink" title="1 ）双亲表示法"></a>1 ）双亲表示法</h4><p>除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。</p><p><img src="https://imine141.github.io/images/%E6%A0%911" alt=""></p><p>存储结构的设计是一个非常灵活的过程。</p><ul><li>双亲域：增加一个结点指示其双亲结点的域</li><li>长子域：增加一个结点最左边孩子的域</li><li>右兄弟域：增加一个右兄弟域体现兄弟关系</li></ul><p>当算法中需要在树结构中频繁地查找某结点的父结点时，使用双亲表示法最合适。当频繁地访问结点的孩子结点时，双亲表示法就很麻烦，采用孩子表示法就很简单。</p><h4 id="2）孩子表示法"><a href="#2）孩子表示法" class="headerlink" title="2）孩子表示法"></a>2）孩子表示法</h4><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。</p><ul><li>方案一：指针域的个数就等于树的度<ul><li>树中各结点的度相差很大时，浪费空间</li></ul></li><li>方案二：每个结点指针域的个数等于该结点的度<ul><li>各个结点的链表是不相同的结构，还要维护结点的度的数值，浪费运算时间</li></ul></li></ul><h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p><p><img src="https://imine141.github.io/images/%E6%A0%912" alt=""></p><h5 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="headerlink" title="双亲孩子表示法"></a>双亲孩子表示法</h5><p>使用孩子表示法存储的树结构，正好和双亲表示法相反，适用于查找某结点的孩子结点，不适用于查找其父结点。可以将两种表示方法合二为一</p><p><img src="https://imine141.github.io/images/%E6%A0%913" alt=""></p><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><p>把一棵复杂的树变成一棵二叉树</p><p>链表中每个结点由 3 部分组成：</p><ul><li>孩子指针域：表示指向当前结点的第一个孩子结点</li><li>数据域</li><li>兄弟指针域：表示指向当前结点的下一个兄弟结点</li></ul><p><img src="https://imine141.github.io/images/%E6%A0%914" alt=""></p><h3 id="2、树、森林与二叉树的转换"><a href="#2、树、森林与二叉树的转换" class="headerlink" title="2、树、森林与二叉树的转换"></a>2、树、森林与二叉树的转换</h3><h4 id="1）树转换为二叉树"><a href="#1）树转换为二叉树" class="headerlink" title="1）树转换为二叉树"></a>1）树转换为二叉树</h4><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去钱。对树中每个结点，只保留它与第一个孩子结点的连线，删除色与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%915" alt=""></p><h4 id="2）森林转换为二叉树"><a href="#2）森林转换为二叉树" class="headerlink" title="2）森林转换为二叉树"></a>2）森林转换为二叉树</h4><ol><li>把每棵树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%916" alt=""></p><h4 id="3）二叉树转换为树"><a href="#3）二叉树转换为树" class="headerlink" title="3）二叉树转换为树"></a>3）二叉树转换为树</h4><ol><li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%917" alt=""></p><h4 id="4）二叉树转换为森林"><a href="#4）二叉树转换为森林" class="headerlink" title="4）二叉树转换为森林"></a>4）二叉树转换为森林</h4><p>假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。</p><ol><li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。</li><li>将每棵分离后的二叉树转换为树。</li></ol><p><img src="https://imine141.github.io/images/%E6%A0%918" alt=""></p><h3 id="3、树和森林的遍历"><a href="#3、树和森林的遍历" class="headerlink" title="3、树和森林的遍历"></a>3、树和森林的遍历</h3><h4 id="1）树的遍历"><a href="#1）树的遍历" class="headerlink" title="1）树的遍历"></a>1）树的遍历</h4><p>分为两种方式</p><ul><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历棍的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li></ul><h4 id="2）森林的遍历"><a href="#2）森林的遍历" class="headerlink" title="2）森林的遍历"></a>2）森林的遍历</h4><p>也分为两种方式:</p><ul><li>前序遍历: 先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依放用同样方式遍历除去第一棵树的剩余树构成的森林。</li><li>后序遍历: 是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。</li></ul><p>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p><p>当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。</p><h2 id="四、二叉树的应用"><a href="#四、二叉树的应用" class="headerlink" title="四、二叉树的应用"></a>四、二叉树的应用</h2><h3 id="1、BST（二叉排序树-二叉查找树-二叉搜索树）"><a href="#1、BST（二叉排序树-二叉查找树-二叉搜索树）" class="headerlink" title="1、BST（二叉排序树/二叉查找树/二叉搜索树）"></a>1、BST（二叉排序树/二叉查找树/二叉搜索树）</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>二叉排序树：又称为二叉查找树、二叉搜索树。它或者是一棵空树，或者是具有下列性质的二叉树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p>二叉排序树利于插入和删除的实现。</p><h4 id="2-操作"><a href="#2-操作" class="headerlink" title="2)操作"></a>2)操作</h4><ul><li>查找：查找成功返回ture，指向成功结点；查找失败返回false，指向上一结点。</li><li>插入：查找不成功，则插入到上一节点的子节点</li><li>构建：反复插入</li><li>删除：<ul><li>叶子节点直接删；</li><li>只有左或右子树的，“子继父业”；</li><li>左右子树都有的，找到需要删除的结点 p 的直接前驱(或直接后继) s，用 s 来替换结点 p，然后再删除此结点 s，s 的子结点移到 s 原来的位置</li></ul></li></ul><h3 id="2、平衡二叉树"><a href="#2、平衡二叉树" class="headerlink" title="2、平衡二叉树"></a>2、平衡二叉树</h3><h4 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>平衡二叉树：是一种二叉排序树，其中每一个节点的左子树和右子树的高度之差的绝对值不超过 1。</li><li>平衡因子：二叉树上结点的左子树深度减去右子树深度的值（只可能是-1 、0 和 1）</li><li>最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。</li></ul><h4 id="2）失衡调整"><a href="#2）失衡调整" class="headerlink" title="2）失衡调整"></a>2）失衡调整</h4><p><img src="https://imine141.github.io/images/%E6%A0%919" alt=""></p><ul><li>LL失衡：右旋（Zig）。当传入一个二叉排序树 P，将它的左孩子结点定义为 L ，将 L 的右子树变成 P 的左子树，再将 P 改成 L 的右子树，最后将 L 替换 P 成为根结点。</li><li>RR失衡：左旋（Zag）。与右旋对称。</li><li>LR失衡：先左旋后右旋（Zig-zag）</li><li>RL失衡：先右旋后左旋（Zag-zig）</li></ul><h3 id="3、堆"><a href="#3、堆" class="headerlink" title="3、堆"></a>3、堆</h3><p>最大堆、最小堆</p><h3 id="4、红黑树"><a href="#4、红黑树" class="headerlink" title="4、红黑树"></a>4、红黑树</h3><p>把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。</p><h3 id="5、哈夫曼-Huffman-树和哈夫曼编码"><a href="#5、哈夫曼-Huffman-树和哈夫曼编码" class="headerlink" title="5、哈夫曼(Huffman)树和哈夫曼编码"></a>5、哈夫曼(Huffman)树和哈夫曼编码</h3><h4 id="1）赫夫曼树定义"><a href="#1）赫夫曼树定义" class="headerlink" title="1）赫夫曼树定义"></a>1）赫夫曼树定义</h4><ul><li>路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</li><li>树的路径长度：就是从树根到每一结点的路径长度之和。</li><li>带权路径长度：结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。</li><li>树的带权路径长度：为树中所有叶子结点的带权路径长度之和 。</li></ul><p>赫夫曼树：带权路径长度 WPL 最小的二叉树称做赫夫曼树。</p><h4 id="2-赫夫曼树构造"><a href="#2-赫夫曼树构造" class="headerlink" title="2)赫夫曼树构造"></a>2)赫夫曼树构造</h4><ol><li>根据给定的 n 个权值 {<code>w_1,w_2,...,w_n</code>} 构成 n 棵二叉树的集合 F={ <code>T_1,T_2,...,T_n</code>}，其中每棵二叉树 <code>T_i</code> 中只有一个带权为 <code>w_i</code> 根结点，其左右子树均为空。</li><li>在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中 。</li><li>重复 2 和 3 步骤，直到 F 只含一棵树为止。这棵树便是赫夫曼树。</li></ol><h4 id="3-赫夫曼编码"><a href="#3-赫夫曼编码" class="headerlink" title="3)赫夫曼编码"></a>3)赫夫曼编码</h4><p>赫夫曼编码：对需要编码的字符集，统计各个字符出现的次数或频率，作为权值，构造赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，从根节点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码。</p><ul><li>定长编码：像 ASCII 编码</li><li>变长编码：单个编码的长度不一致，可以根据整体出现频率来调节</li><li>前缀码：所谓的前缀码，就是没有任何码字是其他码字的前缀</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2020/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2020/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><ul><li>栈：是限定仅在表尾进行插入和删除操作的线性表。后进先出LIFO<ul><li>栈顶(top)：允许插入和删除的一端</li><li>核底(bottom)：另一端</li></ul></li><li>栈的引入简化了程序设计，使关注范围缩小，聚焦于要解决的问题核心。</li></ul><h3 id="2-栈的顺序存储结构-顺序栈"><a href="#2-栈的顺序存储结构-顺序栈" class="headerlink" title="2 栈的顺序存储结构 - 顺序栈"></a>2 栈的顺序存储结构 - 顺序栈</h3><h5 id="1）存储结构"><a href="#1）存储结构" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><p>栈是线性表的特例，栈的顺序存储是线性表顺序存储的简化。</p><ul><li>栈底：数组0端</li><li>top 变量：指示栈顶元素在数组中的位置，空栈-1</li></ul><h5 id="2）基本操作"><a href="#2）基本操作" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>进栈push：栈顶指针加一，新插元素赋值栈顶空间</li><li>出栈pop：栈顶指针减一，返回原栈顶</li></ul><h5 id="3）两栈共享空间"><a href="#3）两栈共享空间" class="headerlink" title="3）两栈共享空间"></a>3）两栈共享空间</h5><p>一个数组来存储两个具有相同数据类型的栈，数组两端为栈底，向中间靠拢。</p><p>通常都是当两个栈的空间需求有相反关系时，才使用这样的数据结构。</p><h3 id="3-栈的链式存储结构-链栈"><a href="#3-栈的链式存储结构-链栈" class="headerlink" title="3 栈的链式存储结构 - 链栈"></a>3 栈的链式存储结构 - 链栈</h3><h5 id="1）存储结构-1"><a href="#1）存储结构-1" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><ul><li>栈顶：单链表的头部，替代头结点</li></ul><h5 id="2）基本操作-1"><a href="#2）基本操作-1" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>进栈push：当前栈顶元素赋值给新结点后继，新结点赋值给栈顶指针</li><li>出栈pop：栈顶指针下移，释放原栈顶结点</li></ul><h5 id="3）顺序栈与链栈对比"><a href="#3）顺序栈与链栈对比" class="headerlink" title="3）顺序栈与链栈对比"></a>3）顺序栈与链栈对比</h5><ul><li>如元素变化不可预料，最好是用链栈；</li><li>如元素变化在可控范围内，使用顺序栈。</li></ul><h3 id="4-栈的应用"><a href="#4-栈的应用" class="headerlink" title="4 栈的应用"></a>4 栈的应用</h3><h5 id="1）递归"><a href="#1）递归" class="headerlink" title="1）递归"></a>1）递归</h5><p>编译器使用栈实现递归</p><h5 id="2）四则运算表达式求值"><a href="#2）四则运算表达式求值" class="headerlink" title="2）四则运算表达式求值"></a>2）四则运算表达式求值</h5><ul><li>中缀表达式：标准四则运算表达式，所有的运算符号都在两数字的中间<ul><li><code>9 + (3 - 1) * 3 + 10/2</code></li></ul></li><li>逆波兰表示：一种不需要括号的后缀表达法，所有的符号都是在要运算数字的后面出现<ul><li><code>9 3 1-3 * + 10 2 / +</code></li></ul></li></ul><h6 id="1-将中缀表达式转化为后缀表达式-栈用来进出运算的符号-。"><a href="#1-将中缀表达式转化为后缀表达式-栈用来进出运算的符号-。" class="headerlink" title="1. 将中缀表达式转化为后缀表达式(栈用来进出运算的符号)。"></a>1. 将中缀表达式转化为后缀表达式(栈用来进出运算的符号)。</h6><ul><li>从左到右遍历中缀表达式的每一数字和符号，若是数字就输出，即成为后缀表达式的一部分</li><li>若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈</li><li>一直到最终输出后缀表达式为止。</li></ul><h6 id="2-将后缀表达式进行运算得出结果-栈用来进出运算的数字-。"><a href="#2-将后缀表达式进行运算得出结果-栈用来进出运算的数字-。" class="headerlink" title="2. 将后缀表达式进行运算得出结果(栈用来进出运算的数字)。"></a>2. 将后缀表达式进行运算得出结果(栈用来进出运算的数字)。</h6><ul><li>从左到右遍历表达式的每个数字和符号，遇到是数字就进栈；</li><li>遇到是符号，就将处于栈顶两个数字出拢，进行运算，运算结果进栈</li><li>一直到最终获得结果。</li></ul><h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><ul><li>队列：是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。先进先出FIFO<ul><li>队尾：允许插入的一端</li><li>队头：允许删除的一端称</li></ul></li></ul><h3 id="2-队列的顺序存储结构-循环队列"><a href="#2-队列的顺序存储结构-循环队列" class="headerlink" title="2 队列的顺序存储结构 - 循环队列"></a>2 队列的顺序存储结构 - 循环队列</h3><h5 id="1）存储结构-2"><a href="#1）存储结构-2" class="headerlink" title="1）存储结构"></a>1）存储结构</h5><ul><li>循环队列：队列的头尾相接的顺序存储结构</li><li>front 指针：头指针</li><li>rear 指针：尾指针。若队列不空，指向队尾的下一个位置</li><li>标志变量 flag：标记队列是否满了</li></ul><h5 id="2）基本操作-2"><a href="#2）基本操作-2" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>入队EnQueue：判满，新元素给尾指针位置，尾指针后移</li><li>出队DeQueue：判空，返回对头元素，头指针后移</li></ul><h3 id="3-队列的链式存储结构-链队列"><a href="#3-队列的链式存储结构-链队列" class="headerlink" title="3 队列的链式存储结构 - 链队列"></a>3 队列的链式存储结构 - 链队列</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。</p><ul><li>front 指针：头指针。指向头结点。</li><li>rear 指针：尾指针。指向终端结点。</li></ul><h5 id="2）基本操作-3"><a href="#2）基本操作-3" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>入队EnQueue：新结点赋值给原对尾结点后继，新结点设为队尾结点，尾指针指向新结点</li><li>出队DeQueue：头结点的后继结点出队，头结点的后继改为其后面的结点。若链表除头结点外只剩一个元素时， 则需将尾指针指向头结点</li></ul><h5 id="3）循环队列与链队列对比"><a href="#3）循环队列与链队列对比" class="headerlink" title="3）循环队列与链队列对比"></a>3）循环队列与链队列对比</h5><ul><li>在可以确定队列长度最大值的情况下，建议用循环队列</li><li>如果无法预估队列的长度时，则用链队列</li></ul><h3 id="4-队列的应用"><a href="#4-队列的应用" class="headerlink" title="4 队列的应用"></a>4 队列的应用</h3><p>键盘输入显示器输出</p><p>排队</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表List</title>
      <link href="/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、线性表的定义和基本操作"><a href="#一、线性表的定义和基本操作" class="headerlink" title="一、线性表的定义和基本操作"></a>一、线性表的定义和基本操作</h2><h5 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h5><p>线性表：零个或多个数据元素的有序排列。</p><blockquote><p>除第一个元素外，每个元素有且只有一个直接前驱元素；除最后一个元素外，每个元素有且只有一个直接后继元素。</p></blockquote><h5 id="2）基本操作"><a href="#2）基本操作" class="headerlink" title="2）基本操作"></a>2）基本操作</h5><ul><li>InitList：初始化</li><li>ListEmpty：判空</li><li>ClearList：清空</li><li>GetElem：取值</li><li>LocateElem：定位</li><li>Listlnsert：插入</li><li>ListDelete：删除</li><li>ListLength：长度</li></ul><h2 id="二、线性表的实现"><a href="#二、线性表的实现" class="headerlink" title="二、线性表的实现"></a>二、线性表的实现</h2><h3 id="1-顺序存储"><a href="#1-顺序存储" class="headerlink" title="1 顺序存储"></a>1 顺序存储</h3><h5 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h5><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><h5 id="2）存储结构"><a href="#2）存储结构" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>一维数组，存取时间性能为O(1)，随机存取结构</p><ul><li>存储空间的起始位置：数组 data 的存储位置</li><li>线性表的最大容量：数组长度 MaxSize</li><li>线性表的当前长度 : length</li></ul><h5 id="3）主要操作"><a href="#3）主要操作" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><ul><li>取值O(1)：返回数组中指定下标的值。下标超限抛异常</li><li>插入O(n)：从最后一个元素到插入位置元素依次后移，插入，表长+1。位置或长度有问题抛异常或扩容。</li><li>删除O(n)：从删除位置到最后元素依次前移，表长-1。删除位置不合理抛异常。</li></ul><h5 id="4）优缺点"><a href="#4）优缺点" class="headerlink" title="4）优缺点"></a>4）优缺点</h5><p>优点</p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任一位置的元素</li></ul><p>缺点</p><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的”碎片”</li></ul><h3 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="2 链式存储"></a>2 链式存储</h3><h4 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h4><h5 id="1）定义-2"><a href="#1）定义-2" class="headerlink" title="1）定义"></a>1）定义</h5><p>不考虑相邻，哪有空就存哪，让每个元素知道它下一个元素的位置</p><h5 id="2）存储结构-1"><a href="#2）存储结构-1" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。</p><ul><li>单链表：每个结点中只包含一个指针域，n 个结点链结成一个链表</li><li>结点：数据元素的存储映像，由数据域和指针域组成<ul><li>数据域：存储数据元素信息的域</li><li>指针域：存储直接后继位置的域</li></ul></li><li>头指针：（必要元素）指向链表中第一个结点的存储位置</li><li>头结点：（可选元素）为方便操作，可在第一个结点前附设一个头结点。<ul><li>头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息。</li><li>有了头节点，对第一结点前插入和删除第一结点，与其他结点的操作就统一了</li></ul></li><li>线性链表的最后一个结点指针为“空”</li></ul><h5 id="3）主要操作-1"><a href="#3）主要操作-1" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><ul><li>读取O(n)：从第一个节点遍历</li><li>插入、删除：遍历查找第i个元素O(n)，改变指针，插入和删除O(1)<ul><li>若不知道位置，与顺序存储结构没有优势。知道位置后，优势很大</li><li>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显</li></ul></li><li>整表创建：动态生成链表。从空表起，依次建立元素结点，插入链表。<ul><li>头插法：新结点插入到头结点与前一新元素之间。</li><li>尾插法：记录尾结点，新结点插在终端结点后面</li></ul></li><li>整表删除：便利每个节点，在内存中将它释放</li></ul><h5 id="4）单链表与顺序存储优缺点"><a href="#4）单链表与顺序存储优缺点" class="headerlink" title="4）单链表与顺序存储优缺点"></a>4）单链表与顺序存储优缺点</h5><ul><li>时间性能<ul><li>查找<ul><li>顺序：o(1)</li><li>单链表：O(n)</li></ul></li><li>插入和删除<ul><li>顺序：平均移动一半元素，O(n)</li><li>单链表：找出位置后，O(1)</li></ul></li></ul></li><li>空间性能<ul><li>顺序：需预分配，大了浪费，小了溢出</li><li>单链表：无需分配不受限</li></ul></li><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。</li><li>若需要频繁插入和删除时，宜采用单链表结构。</li><li>元素个数变化较大或未知时，最好用单链表。</li><li>如长度确定，顺序存储结构效率会高很多。</li></ul><h4 id="2-2-静态链表"><a href="#2-2-静态链表" class="headerlink" title="2.2 静态链表"></a>2.2 静态链表</h4><h5 id="1）定义-3"><a href="#1）定义-3" class="headerlink" title="1）定义"></a>1）定义</h5><p>针对没有指针的语言，用数组来代替指针描述链表，被称为静态链表。</p><h5 id="2）存储结构-2"><a href="#2）存储结构-2" class="headerlink" title="2）存储结构"></a>2）存储结构</h5><p>游标实现法：数组的元素都是由两个数据域组成， data 和 cur</p><ul><li>数据域data ：用来存放数据元素</li><li>游标 cur ：相当于单链表中的 next 指针，存放该元素的后继在数组中的下标</li><li>第一个元素：存放备用链表的第一个结点的下标</li><li>最后一个元素：存放第一个有数值的元素的下标</li></ul><h5 id="3）主要操作-2"><a href="#3）主要操作-2" class="headerlink" title="3）主要操作"></a>3）主要操作</h5><p>将可用空间链成备用链表</p><ul><li>插入<ul><li>模拟空间分配：从备用链表上取第一个结点作为待插入的新结点</li></ul></li><li>删除<ul><li>模拟空间释放：将删除位置加入备用链表第一位</li></ul></li></ul><h5 id="4）静态链表优缺点"><a href="#4）静态链表优缺点" class="headerlink" title="4）静态链表优缺点"></a>4）静态链表优缺点</h5><ul><li>插入和删除操作时 ，只需要修改游标。</li><li>没有解决连镇存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性</li></ul><h4 id="2-3-循环链表"><a href="#2-3-循环链表" class="headerlink" title="2.3 循环链表"></a>2.3 循环链表</h4><h5 id="1）定义-4"><a href="#1）定义-4" class="headerlink" title="1）定义"></a>1）定义</h5><p>循环链表：将单链表中终端结点的指针端由空指针改为指向头结点，这种头尾相接的单链表称为单循环链表，简称循环链表。</p><h5 id="2）差异"><a href="#2）差异" class="headerlink" title="2）差异"></a>2）差异</h5><p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断 p-&gt;next 是否为空，现在则是 p -&gt; next 不等于头结点，则循环未结束。</p><h5 id="3）尾指针"><a href="#3）尾指针" class="headerlink" title="3）尾指针"></a>3）尾指针</h5><p>如用尾指针替代头指针，则查找开始结点和终端结点都很方便。</p><h4 id="2-4-双向链表"><a href="#2-4-双向链表" class="headerlink" title="2.4 双向链表"></a>2.4 双向链表</h4><h5 id="1）定义-5"><a href="#1）定义-5" class="headerlink" title="1）定义"></a>1）定义</h5><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p><h5 id="2）主要操作"><a href="#2）主要操作" class="headerlink" title="2）主要操作"></a>2）主要操作</h5><p>在插入和删除时，需要更改两个指针变量。顺序很重要，千万不能写反了。</p><ul><li>插入<ul><li>先搞定插入结点的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。</li></ul></li><li>删除<ul><li>将前结点的后继指向后结点，将后结点的前驱指向前结点</li></ul></li></ul><h3 id="3-线性表的应用"><a href="#3-线性表的应用" class="headerlink" title="3 线性表的应用"></a>3 线性表的应用</h3><p>队列和堆栈</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与广义表</title>
      <link href="/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数组的概念、多维数组的实现"><a href="#1-数组的概念、多维数组的实现" class="headerlink" title="1 数组的概念、多维数组的实现"></a>1 数组的概念、多维数组的实现</h3><h4 id="1）数组的概念"><a href="#1）数组的概念" class="headerlink" title="1）数组的概念"></a>1）数组的概念</h4><ul><li>数组的特点：元素数目固定；下标有界。</li><li>数组的操作：按照下标进行读写。</li></ul><h4 id="2）多维数组的实现"><a href="#2）多维数组的实现" class="headerlink" title="2）多维数组的实现"></a>2）多维数组的实现</h4><h5 id="行优先顺序"><a href="#行优先顺序" class="headerlink" title="行优先顺序"></a>行优先顺序</h5><p>存储时先按行从小到大的顺序存储，在每一行中按列号从小到大存储。</p><h5 id="列优先顺序"><a href="#列优先顺序" class="headerlink" title="列优先顺序"></a>列优先顺序</h5><p>存储时先按列从小到大的顺序存储，在每一列中按行号从小到大存储。</p><h3 id="2-矩阵的压缩存储"><a href="#2-矩阵的压缩存储" class="headerlink" title="2 矩阵的压缩存储"></a>2 矩阵的压缩存储</h3><p>矩阵的压缩存储就是存储数组时，尽量减少存储空间，但数组中每个元素必须存储。</p><p>在矩阵中，如果有规律可寻，只要存储其中一部分，而另外一部分的存储地址可以通过相应的算法将它计算出来，从而占有较少的存储空间达到存储整个矩阵的目的。</p><p>矩阵的压缩存储仅能针对特殊矩阵使用，对于没有规律可循的二维数组则不能使用。</p><h4 id="1）对称矩阵"><a href="#1）对称矩阵" class="headerlink" title="1）对称矩阵"></a>1）对称矩阵</h4><p>只需对对称矩阵中n(n+1)/2个元素进行储存表示</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E5%B9%BF%E4%B9%89%E8%A1%A81" alt=""></p><h4 id="2）三角矩阵"><a href="#2）三角矩阵" class="headerlink" title="2）三角矩阵"></a>2）三角矩阵</h4><p>以主对角线划分，三角矩阵有上三角和下三角两种。上三角矩阵它的下三角中的元素均为常数。下三角矩阵正好相反，它的主对角线上方均为常数。</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A82" alt=""></p><h4 id="3）稀疏矩阵"><a href="#3）稀疏矩阵" class="headerlink" title="3）稀疏矩阵"></a>3）稀疏矩阵</h4><p>if 一个 m * n 的矩阵含有 t 个非零元素，且 t 远远小于 m * n，则称这个矩阵为稀疏矩阵</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A83" alt=""></p><p>除了记录非零元素的值之外，还必须同时几下它所在的行和列的位置。稀疏矩阵的存储方法一般有三种：三元组法、行逻辑连接顺序表和十字链表法。</p><h5 id="三元组法"><a href="#三元组法" class="headerlink" title="三元组法"></a>三元组法</h5><p>用三项内容表示稀疏矩阵中的每个非零元素，形式为：（i,j,value）。<br>其中，i 表示行序号，j 表示列序号，value 表示非零元素的值</p><h3 id="3-广义表的基本概念"><a href="#3-广义表的基本概念" class="headerlink" title="3 广义表的基本概念"></a>3 广义表的基本概念</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>广义表：是线性表的扩展，具体定义为n（n≥0）个元素的有限集合。<br>n的值是广义表的长度，如果n=0称广义表为空表。</li><li>长度：广义表中含有元素的个数称</li><li>深度：广义表中含有的括号对数</li></ul><h5 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h5><p>广义表的数据元素有两种类型：一个是不可再分的元素（原子元素）；一个是可以再分的元素（子表）。</p><ul><li>如果所有的元素都是原子元素，则称为线性表。</li><li>如果数据元素中含有子表元素，则称为广义表。</li></ul><h5 id="记法"><a href="#记法" class="headerlink" title="记法"></a>记法</h5><p>广义表一般记作：LS=(a1,a2,……,an)</p><p>常见的广义表为：A=()、B=(())、C=(a,b)、D=(A,B,C)、E=(a,E)</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>广义表有三个重要的特点：</p><ul><li>第一：广义表的元素可以是子表，而子表的元素还可以是子表，广义表是一个多层次的结构。</li><li>第二：广义表可以为其他广义表所共享。</li><li>第三：广义表可以是一个递归表，即表也可以是其本身的一个子表。</li></ul><h4 id="2）存储方式"><a href="#2）存储方式" class="headerlink" title="2）存储方式"></a>2）存储方式</h4><p>广义表的存储方法有很多种，一般采用链表存储。</p><p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A84" alt=""></p><p>flag表示标志位。当flag为0时，表示该结点为原子元素，info表示原子元素的值；当flag为1时表示该结点为子表，info表示指针，指向该子表的第一个结点。 link表示指针，指向广义表的下一个元素。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修饰符</title>
      <link href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-访问修饰符"><a href="#1-访问修饰符" class="headerlink" title="1 访问修饰符"></a>1 访问修饰符</h3><ul><li>private：仅对本类可见</li><li>public：对所有类可见<ul><li>接口里方法默认 public</li></ul></li><li>protected：对本包和所有子类可见</li><li>default：对本包可见</li></ul><p>一个方法可以访问所属类的所有对象的私有对象</p><h3 id="2-非访问修饰符"><a href="#2-非访问修饰符" class="headerlink" title="2 非访问修饰符"></a>2 非访问修饰符</h3><h4 id="2-1-final"><a href="#2-1-final" class="headerlink" title="2.1 final"></a>2.1 final</h4><ul><li>final 域（常量）<ul><li>final 域必须显式指定初始值，赋值后，不能被重新赋值。</li><li>基本类型：final 使数值不变</li><li>引用类型：final 使引用不变，但是被引用的对象本身是可以修改的</li></ul></li><li>final 方法<ul><li>final 方法可以被子类继承，但是不能被子类修改。</li><li>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</li></ul></li><li>final 类<ul><li>final 类不能被继承</li></ul></li></ul><h4 id="2-2-static"><a href="#2-2-static" class="headerlink" title="2.2 static"></a>2.2 static</h4><ul><li>静态域（变量）<ul><li>类变量，多实例也只有一份拷贝</li></ul></li><li>静态常量<ul><li>多与 final 组成静态常量，一般大写</li></ul></li><li>静态方法<ul><li>类方法，独立于对象，没有隐式参数 this 和 super，可以访问静态域</li><li>不可从一个 static 方法内部发出对非 static 方法的调用</li><li>必须有实现，不能是抽象方法</li></ul></li><li>静态内部类<ul><li>只有内部类能被声明为 static。</li><li>静态内部类不能访问外部类的非静态的变量和方法。</li></ul></li><li>静态代码块<ul><li>静态块在类加载时自动执行</li></ul></li><li>静态导包<ul><li>JDK 1.5，用 import static 代替 import 静态导入，可以直接使用类的静态方法和静态域，而不需要使用类名作为前缀。</li></ul></li></ul><p>存在继承的情况下，初始化顺序为：</p><blockquote><p>父类（静态变量、静态语句块）<br>子类（静态变量、静态语句块）<br>父类（实例变量、普通语句块）<br>父类（构造函数）<br>子类（实例变量、普通语句块）<br>子类（构造函数）</p></blockquote><h4 id="2-3-abstract"><a href="#2-3-abstract" class="headerlink" title="2.3 abstract"></a>2.3 abstract</h4><ul><li>抽象类<ul><li>抽象类不能实例化，唯一目的是为了对该类进行扩充。</li><li>抽象类可以不包含抽象方法。</li></ul></li><li>抽象方法<ul><li>抽象方法是一种没有任何实现的方法，具体实现由子类提供。</li><li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li><li>包含抽象方法的类，一定要声明为抽象类。</li></ul></li></ul><h4 id="2-4-synchronized"><a href="#2-4-synchronized" class="headerlink" title="2.4 synchronized"></a>2.4 synchronized</h4><ul><li>方法</li><li>代码块<ul><li>synchronized 声明的方法同一时间只能被一个线程访问。</li></ul></li></ul><h4 id="2-5-transient"><a href="#2-5-transient" class="headerlink" title="2.5 transient"></a>2.5 transient</h4><ul><li>transient 变量<ul><li>序列化时被跳过</li></ul></li></ul><h4 id="2-6-volatile"><a href="#2-6-volatile" class="headerlink" title="2.6 volatile"></a>2.6 volatile</h4><p>volatile 同步变量</p><ul><li>原子性：不保证</li><li>可见性：保证，读写立刻与主内存交换</li><li>有序性：保证，禁止指令重排序优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 对象与类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-抽象"><a href="#1-抽象" class="headerlink" title="1 抽象"></a>1 抽象</h3><p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2 封装"></a>2 封装</h3><p>把数据和行为隐藏，只能通过暴露的接口访问数据。</p><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3 继承"></a>3 继承</h3><p>通过扩展一个类来建立另一个新的类。</p><h4 id="3-1-慎用继承"><a href="#3-1-慎用继承" class="headerlink" title="3.1 慎用继承"></a>3.1 慎用继承</h4><ol><li>将公共操作和域放在超类。</li><li>不要使用受保护的域。</li><li>使用继承实现”is-a”。</li><li>除非所有继承的方法都有意义，否则不要使用继承。</li><li>在覆盖方法时，不要改变预期的行为。</li><li>使用多态，而非类型信息。</li><li>不要过多地使用反射。</li></ol><h4 id="3-2-强制类型转换"><a href="#3-2-强制类型转换" class="headerlink" title="3.2 强制类型转换"></a>3.2 强制类型转换</h4><p>只能在继承层次内进行类型转换。</p><p>在将超类转换成子类之前，应该使用 instanceof 进行检查。</p><ul><li>上溯造型（Upcasting）：把衍生类型当作它的基本类型处理</li><li>下溯造型（Downcasting）：向下转型，超类可用子类置换。</li></ul><h4 id="3-3-重写（override）"><a href="#3-3-重写（override）" class="headerlink" title="3.3 重写（override）"></a>3.3 重写（override）</h4><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><ul><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ul><h4 id="3-4-重载（overload）"><a href="#3-4-重载（overload）" class="headerlink" title="3.4 重载（overload）"></a>3.4 重载（overload）</h4><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4 多态"></a>4 多态</h3><p>一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。</p><p>Java 实现多态有三个必要条件：继承、重写、上溯造型。</p><p>虚拟机预先为每个类创建了一个方法表（method table），其中列出了所有方法的签名和实际调用的方法。</p><h4 id="4-1-动态绑定"><a href="#4-1-动态绑定" class="headerlink" title="4.1 动态绑定"></a>4.1 动态绑定</h4><p>在运行时能够自动选择调用哪个方法的现象称为动态绑定。</p><ol><li>编译器会列举类方法表中同名方法，和超类方法表中同名且为 public 的方法。</li><li>编译器重载匹配参数类型，若有完全匹配的就选择，没有就匹配允许类型转换的方法，如果这样还是不能找到匹配项，编译器就会报错；同时如果找到多于一个匹配项，编译器也会报错。</li></ol><h4 id="4-2-静态绑定"><a href="#4-2-静态绑定" class="headerlink" title="4.2 静态绑定"></a>4.2 静态绑定</h4><p>如果是 private,static,final 方法或者构造器，那么编译器可以明确地知道该调用哪个方法，这种调用方式成为静态绑定。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 对象与类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E7%B1%BB/"/>
      <url>/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-类"><a href="#1-类" class="headerlink" title="1 类"></a>1 类</h3><p>类是构造对象的模板。</p><p>由类构造对象的过程称为创建类的实例。</p><p>一个源文件中，只能有一个公共类，类名必须与文件名相同。</p><h4 id="1-1-类之间的关系"><a href="#1-1-类之间的关系" class="headerlink" title="1.1 类之间的关系"></a>1.1 类之间的关系</h4><p>最常见的关系有：</p><ol><li>依赖（uses-a）：一个类的方法需要操纵另一个类的对象</li><li>聚合（has-a）：类 A 的对象包含着类 B 的对象</li><li>继承（is-a）：继承是一种用于表示特殊与一般的关系，父类更一般</li></ol><p>应该尽可能地将相互依赖的类减至最少。</p><h4 id="1-2-构造器"><a href="#1-2-构造器" class="headerlink" title="1.2 构造器"></a>1.2 构造器</h4><ol><li>构造器和类名同名，参数不限，没有返回值。</li><li>构造器中的局部变量会覆盖同名实例域。</li><li>若未手动编写构造器，会默认提供一个无参构造器，设默认值。手动提供构造器后，不会自动提供无参构造器。</li><li>构造器不能被继承，因此不能被重写，但可以被重载。</li><li>父类与子类的构造函数调用次序：若子类构造器没有显式调用父类构造器，不管子类构造器有无参数，都默认调用父类无参构造器。</li></ol><h4 id="1-3-finalize-方法"><a href="#1-3-finalize-方法" class="headerlink" title="1.3 finalize 方法"></a>1.3 finalize 方法</h4><p>可以为任何一个类添加 finalize 方法，将在垃圾回收器清除对象之前调用。不要依赖，不能保证被调用。</p><h4 id="1-4-Object：所有类的超类"><a href="#1-4-Object：所有类的超类" class="headerlink" title="1.4 Object：所有类的超类"></a>1.4 Object：所有类的超类</h4><p>如果重新定义 equals 方法，就必须重新定义 hashCode 方法。eauals 与 hashCode 的定义必须一致：如果 x.eauals(y) 返回 true，那么 x.hashCode() 必须与 y.hashCode() 具有相同的值。</p><h5 id="1）equals-方法"><a href="#1）equals-方法" class="headerlink" title="1）equals()方法"></a>1）equals()方法</h5><h6 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h6><p>两个对象具有等价关系，需要满足以下五个条件：</p><ul><li><p>自反性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>对称性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>传递性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure></li><li><p>一致性</p><ul><li>多次调用 equals() 方法结果不变</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>与 null 的比较</p><ul><li>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="等价与相等"><a href="#等价与相等" class="headerlink" title="等价与相等"></a>等价与相等</h6><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><h5 id="2）hashCode"><a href="#2）hashCode" class="headerlink" title="2）hashCode()"></a>2）hashCode()</h5><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p><p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p><h5 id="3）toString"><a href="#3）toString" class="headerlink" title="3）toString()"></a>3）toString()</h5><p>默认返回 ClassName@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><h5 id="4）clone"><a href="#4）clone" class="headerlink" title="4）clone()"></a>4）clone()</h5><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><p>clone() 方法并不是 Cloneable 接口的方法，Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><ul><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。</li></ul><h4 id="1-5-枚举类"><a href="#1-5-枚举类" class="headerlink" title="1.5 枚举类"></a>1.5 枚举类</h4><p>枚举类定义的是一个类，有着指定的几个实例。<br>比较两个枚举类型的值时，不需要调用 equals 方法，而直接使用”==”就可以了。</p><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2 对象"></a>2 对象</h3><h4 id="2-1-创建对象"><a href="#2-1-创建对象" class="headerlink" title="2.1 创建对象"></a>2.1 创建对象</h4><ol><li>用 new 语句创建对象</li><li>运用反射</li><li>调用对象的 clone() 方法</li><li>运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject() 方法</li></ol><p>(1) 和 (2) 都会明确的显式的调用构造函数；(3) 是在内存上对已有对象的影印，所以不会调用构造函数；(4) 是从文件中还原类的对象，也不会调用构造函数。</p><h4 id="2-2-对象克隆"><a href="#2-2-对象克隆" class="headerlink" title="2.2 对象克隆"></a>2.2 对象克隆</h4><p>有两种方式：</p><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法；</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul><h4 id="2-3-序列化"><a href="#2-3-序列化" class="headerlink" title="2.3 序列化"></a>2.3 序列化</h4><ul><li>对象序列化（Serializable）是指将对象转换为字节序列的过程，而反序列化则是根据字节序列恢复对象的过程。只有实现了 Serializable 和 Externalizable 接口的类的对象才能被序列化。</li><li>java.io.ObjectOutputStream 代表对象输出流，它的 writeObject(Objectobj) 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</li><li>java.io.ObjectInputStream 代表对象输入流，它的 readObject() 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</li></ul><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><h4 id="3-1-方法签名"><a href="#3-1-方法签名" class="headerlink" title="3.1 方法签名"></a>3.1 方法签名</h4><p>方法签名只有<strong>方法名</strong>和<strong>参数</strong>，没有返回值。也就是说，不能有两个名字相同、参数也相同而返回值不同的方法。</p><h4 id="3-2-隐式参数与显式参数"><a href="#3-2-隐式参数与显式参数" class="headerlink" title="3.2 隐式参数与显式参数"></a>3.2 隐式参数与显式参数</h4><p>隐式参数是出现在方法名前的类对象（this），显式参数位于方法名后面的括号中。</p><p>使用 this 可以区分开隐式参数的类对象的实例域和局部变量</p><h4 id="3-3-方法参数"><a href="#3-3-方法参数" class="headerlink" title="3.3 方法参数"></a>3.3 方法参数</h4><p>Java 方法参数是<strong>值传递</strong>，不是引用传递。</p><p>方法在执行时，先定义了局部变量，这些局部变量指向，传入参数的指向。对局部变量重新指向时，完全不影响原本传入参数的那些指向。</p><ul><li>值传递：方法接收的是调用者提供的值。</li><li>引用传递：方法接受的是调用所对应的变量地址。</li></ul><h4 id="3-4-参数变量可变的方法"><a href="#3-4-参数变量可变的方法" class="headerlink" title="3.4 参数变量可变的方法"></a>3.4 参数变量可变的方法</h4><p>Object… 参数类型与 Object[] 完全一样，省略号表明这个方法可以接收任意数量的的对象。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 对象与类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2020/08/18/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/08/18/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数学函数与常量"><a href="#1-数学函数与常量" class="headerlink" title="1 数学函数与常量"></a>1 数学函数与常量</h3><ul><li>Math.sqrt(x)：平方根</li><li>Math.pow(x, y)：幂运算，x 的 y 次幂</li><li>Math.floorMod(x, y)：求余</li></ul><h3 id="2-自增与自减运算符"><a href="#2-自增与自减运算符" class="headerlink" title="2 自增与自减运算符"></a>2 自增与自减运算符</h3><p>建议不要在表达式中使用 ++，容易带来疑惑和 bug</p><h3 id="3-关系和-boolean-运算符"><a href="#3-关系和-boolean-运算符" class="headerlink" title="3 关系和 boolean 运算符"></a>3 关系和 boolean 运算符</h3><ul><li><code>==</code></li><li><code>!=</code></li><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>&lt;=</code></li><li><code>&gt;=</code></li><li><code>&amp;&amp;</code>（短路）</li><li><code>||</code>（短路）</li><li><code>?:</code></li></ul><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4 位运算符"></a>4 位运算符</h3><ul><li><p>逻辑</p><ul><li>整型<ul><li><code>|</code> (或)</li><li><code>&amp;</code> (且)</li><li><code>~</code> (非)</li><li><code>^</code> (抑或)</li></ul></li><li>布尔值<ul><li>可用 <code>&amp;</code> 和 <code>|</code>，只是不短路</li></ul></li></ul></li><li><p>位移</p><ul><li><pre><code>&lt;&lt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （左移）</span><br><span class="line"></span><br><span class="line">  - &#96;&lt;&lt;&#96; 时 int 模 32，long 模 64，如 1 &lt;&lt; 35 等于 1 &lt;&lt; 3</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>&gt;&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （带符号右移）</span><br><span class="line"></span><br><span class="line">  - “符号扩展”：若值为正，则在高位插入 0；若值为负，则在高位插入 1。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>&gt;&gt;&gt;</code></pre><p>（无符号右移）</p><ul><li>“零扩展”：无论正负，都在高位插入0。</li></ul></li><li><p>不存在 <code>&lt;&lt;&lt;</code></p></li></ul></li></ul><h3 id="5-括号与运算符级别"><a href="#5-括号与运算符级别" class="headerlink" title="5 括号与运算符级别"></a>5 括号与运算符级别</h3><h3 id="6-枚举类型"><a href="#6-枚举类型" class="headerlink" title="6 枚举类型"></a>6 枚举类型</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/08/17/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E7%BB%84/"/>
      <url>/2020/08/17/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1. 一维数组"></a>1. 一维数组</h3><h4 id="1-1-声明"><a href="#1-1-声明" class="headerlink" title="1.1 声明"></a>1.1 声明</h4><p>一旦创建了数组就不能改变它的大小。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br></pre></td></tr></table></figure><h4 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h4><p>数字数组初始化为 0。boolean 数组初始化 false。对象数组初始化 null。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2. 多维数组"></a>2. 多维数组</h3><p>java 实际上没有多维数组，只有一维数组，多维数组被解释成“数组的数组”</p><h4 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1 声明"></a>2.1 声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n][]</span><br></pre></td></tr></table></figure><h4 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] A &#x3D; &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Arrays-类"><a href="#3-Arrays-类" class="headerlink" title="3. Arrays 类"></a>3. Arrays 类</h3><h4 id="3-1-填充-fill"><a href="#3-1-填充-fill" class="headerlink" title="3.1 填充 fill()"></a>3.1 填充 <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(type[] a,type v);</span><br></pre></td></tr></table></figure><h4 id="3-2-排序-sort"><a href="#3-2-排序-sort" class="headerlink" title="3.2 排序 sort()"></a>3.2 排序 <code>sort()</code></h4><p>优化的快排</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序排序 </span></span><br><span class="line">Arrays.sort(type[] a);</span><br><span class="line"><span class="comment">//给开始位到结束位排序</span></span><br><span class="line">Arrays.sort(type[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br></pre></td></tr></table></figure><h4 id="3-3-比较-equals"><a href="#3-3-比较-equals" class="headerlink" title="3.3 比较 equals()"></a>3.3 比较 <code>equals()</code></h4><p>比较元素是否相等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.equals(type[] a,type[] b);</span><br></pre></td></tr></table></figure><h4 id="3-4-查找-binarySearch"><a href="#3-4-查找-binarySearch" class="headerlink" title="3.4 查找 binarySearch()"></a>3.4 查找 <code>binarySearch()</code></h4><p>二分查找，数组一定要是先排好序，返回最后一个找到的位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.binarySearch(type[] a,type v);</span><br><span class="line"><span class="comment">//范围查找</span></span><br><span class="line">Arrays.binarySearch(type[] a,type v,<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br></pre></td></tr></table></figure><h4 id="3-5-拷贝-copyOf"><a href="#3-5-拷贝-copyOf" class="headerlink" title="3.5 拷贝 copyOf()"></a>3.5 拷贝 <code>copyOf()</code></h4><p>使用 Arrays 类的 copyOf 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度拷贝</span></span><br><span class="line"><span class="keyword">int</span>[] a = Arrays.copyOf(b,b.length);</span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="keyword">int</span>[] a = Arrays.copyOf(b,b.length*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//部分拷贝</span></span><br><span class="line">Arrays.copyOfRange(a,<span class="number">0</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="3-6-转字符串-toString"><a href="#3-6-转字符串-toString" class="headerlink" title="3.6 转字符串 toString()"></a>3.6 转字符串 <code>toString()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.toString(a)</span><br><span class="line"><span class="comment">//打印多维数组</span></span><br><span class="line">Arrays.deepToString()</span><br></pre></td></tr></table></figure><h4 id="3-7-转列表-asList"><a href="#3-7-转列表-asList" class="headerlink" title="3.7 转列表 asList()"></a>3.7 转列表 <code>asList()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2020/08/16/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/08/16/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-String-底层实现"><a href="#1-String-底层实现" class="headerlink" title="1 String 底层实现"></a>1 String 底层实现</h3><p>String 被声明为 final，因此它不可被继承。</p><p>底层是 char 或 byte 类型的 value 数组，value 数组也被声明为 final，这意味着数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><p>编辑器可让字符串共享在常量池。</p><h4 id="1-1-Java-8-char-数组"><a href="#1-1-Java-8-char-数组" class="headerlink" title="1.1 Java 8 - char 数组"></a>1.1 Java 8 - char 数组</h4><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Java-9-byte-数组"><a href="#1-2-Java-9-byte-数组" class="headerlink" title="1.2 Java 9 - byte 数组"></a>1.2 Java 9 - byte 数组</h4><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-不可变的好处"><a href="#1-3-不可变的好处" class="headerlink" title="1.3 不可变的好处"></a>1.3 不可变的好处</h4><ul><li>可以缓存 hash 值<ul><li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li></ul></li><li>String Pool 的需要<ul><li>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li></ul></li><li>安全性<ul><li>String 经常作为参数，String 不可变性可以保证参数不可变。</li><li>例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li></ul></li><li>线程安全<ul><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li></ul></li></ul><h3 id="2-StringBuilder-和-StringBuffer"><a href="#2-StringBuilder-和-StringBuffer" class="headerlink" title="2 StringBuilder 和 StringBuffer"></a>2 StringBuilder 和 StringBuffer</h3><h4 id="2-1-可变性与线程安全"><a href="#2-1-可变性与线程安全" class="headerlink" title="2.1 可变性与线程安全"></a>2.1 可变性与线程安全</h4><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 可变，不是线程安全的，效率比 StringBuffer 高</li><li>StringBuffer 可变，是线程安全的，内部使用 synchronized 进行同步</li></ul><h4 id="2-2-底层实现"><a href="#2-2-底层实现" class="headerlink" title="2.2 底层实现"></a>2.2 底层实现</h4><p>StringBuilder 和 StringBuffer 继承了 AbstractStringBuilder，AbstractStringBuilder 的 char 数组没有 final 关键字修饰，字符数组长度可变，所有 StringBuilder 和 StringBuffer 也是可变的</p><p>AbstractStringBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// StringBuilder 类继承 AbstractStringBuilder 抽象类</span></span><br><span class="line">    <span class="comment">// 创建长度 16 的字符数组</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-String-Pool-与引用"><a href="#3-String-Pool-与引用" class="headerlink" title="3 String Pool 与引用"></a>3 String Pool 与引用</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。</p><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li>new String()：会在堆新建对象</li><li>intern() 方法： String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</li><li>“”字面量：使用字面量的形式创建字符串，会自动地将字符串放入 String Pool 中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"Programming"</span>;<span class="comment">//先去常量池取，没有就新建对象放在常量池</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Programming"</span>);<span class="comment">//两个字符串对象，一个是常量池的"Programming"，一个是用 new 创建在堆上的对象</span></span><br><span class="line">String s3 = <span class="string">"Program"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s4 = <span class="string">"ming"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s5 = <span class="string">"Program"</span> + <span class="string">"ming"</span>;<span class="comment">//常量池</span></span><br><span class="line">String s6 = s3 + s4;<span class="comment">//堆</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s6.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s2 == s2.intern());<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="4-String-常用方法"><a href="#4-String-常用方法" class="headerlink" title="4 String 常用方法"></a>4 String 常用方法</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><h5 id="1）使用字符串常量直接初始化"><a href="#1）使用字符串常量直接初始化" class="headerlink" title="1）使用字符串常量直接初始化"></a>1）使用字符串常量直接初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; &quot;hello!&quot;;</span><br></pre></td></tr></table></figure><h5 id="2）使用构造方法创建并初始化"><a href="#2）使用构造方法创建并初始化" class="headerlink" title="2）使用构造方法创建并初始化"></a>2）使用构造方法创建并初始化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; new String(Object);</span><br></pre></td></tr></table></figure><p>初始化源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">// 本质是字符数组常量，所以不可变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-操作"><a href="#4-2-操作" class="headerlink" title="4.2 操作"></a>4.2 操作</h4><h5 id="1）截取字符串"><a href="#1）截取字符串" class="headerlink" title="1）截取字符串"></a>1）截取字符串</h5><ul><li>单点截取：subString(开始下标)</li><li>双点截取：subString(开始下标，结束下标)</li></ul><h5 id="2）拼接字符串"><a href="#2）拼接字符串" class="headerlink" title="2）拼接字符串"></a>2）拼接字符串</h5><ul><li>+ 号</li><li>join：用一个定界符分割，String.join(“定界符”,“待合并字符串”…)</li></ul><p>字符串的 + 操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象</p><p>一般情况进行字符串拼接用 + 就可以，但是如果是循环拼接，则需要用 StringBuilder 的 append 来实现。</p><p>若不使用 StringBuilder 的 append 方法而使用 + 来进行连接。那么每次在循环体内都将会在 Heap 中创造一个新的 String 对象，造成资源浪费。</p><h5 id="3）获取信息"><a href="#3）获取信息" class="headerlink" title="3）获取信息"></a>3）获取信息</h5><ul><li>下标：indexOf(子字符)，lastIndexOf(子字符)</li><li>字符：charAt(下标)</li><li>字节数组：getBytes()</li><li>字符数组：toCharArray()</li><li>长度：length()</li></ul><h5 id="4）替换字符串"><a href="#4）替换字符串" class="headerlink" title="4）替换字符串"></a>4）替换字符串</h5><ul><li>去掉前后空格：trim()</li><li>子字符串：split(字符串)，StringTokenizer()</li></ul><h5 id="5）判断字符串"><a href="#5）判断字符串" class="headerlink" title="5）判断字符串"></a>5）判断字符串</h5><ul><li>是否相等：.equals()</li><li>不区分大小写：.equalsIgnoreCase()</li><li>是否为空串：.length()==0 或 .equals(“”)</li><li>是否为null：== null</li><li>前缀：startsWith(前缀)</li><li>后缀：endsWith(后缀)</li><li>大小：compareTo()</li></ul><h5 id="6）字符串转换"><a href="#6）字符串转换" class="headerlink" title="6）字符串转换"></a>6）字符串转换</h5><ul><li>大/小写：<ul><li>大写：toLowerCase()</li><li>小写：toUpperCase()</li></ul></li><li>字符串转换为基本类型<ul><li>Long.parseLong(“1231”);</li><li>Double.parseDouble(“0.213”);</li></ul></li><li>基本类型转换为字符串<ul><li>基本数据类型变量 + “”</li><li>String.valueOf(其他类型的参数)；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>数据类型分为基本类型和对象类型。</p><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h3><p>Java 中的基本类型有 8 种，其中有 4 种整型、2 种浮点型、char 和 boolean。还有 void 和 reference 类型</p><ol><li>基本类型值存储在内存栈上。</li><li>基本类型所占空间大小固定。</li><li>所有数值类型都有正负号。</li></ol><h4 id="1-1-整型"><a href="#1-1-整型" class="headerlink" title="1.1 整型"></a>1.1 整型</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>long</td><td>Long</td><td>8 字节 64 bits</td><td>-2^63 ~ +2^63-1</td><td>0L</td><td>后缀加L或l</td></tr><tr><td>int</td><td>Integer</td><td>4 字节 32 bits</td><td>-2^31 ~ +2^31-1</td><td>0</td><td>最常用，范围超20亿</td></tr><tr><td>short</td><td>Short</td><td>2 字节 16 bits</td><td>-2^15 ~ +2^15-1</td><td>(short)0</td><td>控制占用存储空间的大数组</td></tr><tr><td>byte</td><td>Byte</td><td>1 字节 8 bits</td><td>-2^7 ~ +2^7-1</td><td>(byte)0</td><td>底层文件处理</td></tr></tbody></table><ol><li>十六进制前缀 0x 或0X</li><li>八进制前缀 0</li><li>二进制前缀 0b 或 0B(Java 7 开始)</li><li>数字加下划线更易读，如 1_000_000，编译器会去掉(Java 7 开始)</li><li>没有后缀标识的整数默认为 int 类型</li></ol><h4 id="1-2-浮点"><a href="#1-2-浮点" class="headerlink" title="1.2 浮点"></a>1.2 浮点</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>Double</td><td>8 字节 64 bits</td><td>大约-2^1024 ~ -2^-1074 —— 0 —— 2^-1074 ~ 2^1024（有效 15 位）</td><td>0.0d</td><td>后缀 D 或 d，最常用。</td></tr><tr><td>float</td><td>Float</td><td>4 字节 32 bits</td><td>大约-2^128 ~ -2^-149 —— 0 —— 2^-149 ~ 2^128（有效 6~7 位）</td><td>0.0f</td><td>后缀 F 或 f，单精度库或大量数据</td></tr></tbody></table><ol><li>没有后缀F的浮点数默认是 double</li><li>浮点数不能绝对精确，因为二进制种无法精确表示 1/10，不允许误差应使用 BigDecimal 类。</li></ol><p>浮点数的结构与整型不同，指数的底数为 2，尾数表示小数部分</p><table><thead><tr><th>类型</th><th>符号位（S）</th><th>指数位（E）</th><th>尾数位（M）</th></tr></thead><tbody><tr><td>float</td><td>1 bit</td><td>8 bits</td><td>23 bits</td></tr><tr><td>double</td><td>1 bit</td><td>11 bits</td><td>52 bits</td></tr></tbody></table><h4 id="1-3-字符"><a href="#1-3-字符" class="headerlink" title="1.3 字符"></a>1.3 字符</h4><table><thead><tr><th>类型</th><th>包装类</th><th>存储需求</th><th>取值范围</th><th>零值</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td>Character</td><td>2 字节 16 bits</td><td>int0-2^16-1 ,hex’\u0000’~’’\Uffff’</td><td>‘\u0000’</td><td>char 字面量要用单引号括起来。</td></tr></tbody></table><ul><li>转移序列 \u 可以出现在加引号的字符常量或字符串外（其它所有转义序列不可以）</li><li>警告：Unicode 转移序列会在解析代码前得到处理</li><li>警告：当心注释里的 \u，如“\u00A0”换行符，或“c:\user”，语法错误，因为没跟 4 个十六进制数</li><li>解决方案：字符串中用转义符“\”来去除“\u”造成的不必要影响</li></ul><h4 id="1-4-布尔"><a href="#1-4-布尔" class="headerlink" title="1.4 布尔"></a>1.4 布尔</h4><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。</p><p>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p><p>JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><p>整型和布尔之间不能转换，不能用 0 当作 false，可以使用条件表达式</p><h4 id="1-5-类型转换"><a href="#1-5-类型转换" class="headerlink" title="1.5 类型转换"></a>1.5 类型转换</h4><p>不要强制转换 boolean 类型，可用条件表达式</p><p>自动类型转换图示：byte -&gt; short(char) -&gt; int -&gt; long -&gt; float -&gt; double ，强制类型与之相反</p><h5 id="1）自动类型转换"><a href="#1）自动类型转换" class="headerlink" title="1）自动类型转换"></a>1）自动类型转换</h5><p>运算或方法调用时，系统会将较小的数据类型自动转换为较大的数据类型</p><ul><li>当使用 +、-、*、/、% 运算符对基本类型进行运算时，转换为较大的数据类型，如最大的小于 int，则转为 int</li></ul><h5 id="2）强制类型转换"><a href="#2）强制类型转换" class="headerlink" title="2）强制类型转换"></a>2）强制类型转换</h5><p>强制类型将较大的数据类型转化为较小的数据类型，可能导致精度损失。</p><ul><li>当使用 +=、-=、*=、/=、%= 运算符对基本类型进行运算时，运算符右边的数值将首先被强制转换成与运算符左边数值相同的类型，然后再执行运算，且运算结果与运算符左边数值类型相同。</li></ul><h3 id="2-包装类型"><a href="#2-包装类型" class="headerlink" title="2. 包装类型"></a>2. 包装类型</h3><ul><li>所有的基本类型都有一个与之对应的类。包装类都是声明为 final的，不可变，不可被继承。</li><li>对象引用存储在内存栈上，而对象本身的值存储在内存堆上。</li><li>对一个对象进行操作时，我们真正操作的是它的句柄。</li><li>自动装箱：基本类型自动转换成包装类，调用了 Integer.valueOf()</li><li>自动拆箱：包装类自动转换为基本类型，调用了 X.intValue()</li></ul><h4 id="2-1-大数值"><a href="#2-1-大数值" class="headerlink" title="2.1 大数值"></a>2.1 大数值</h4><ul><li>BigInteger 支持任意精度的整数。</li><li>BigDecimal 支持任意精度的浮点数字。</li><li>转换方法： valueOf</li><li>运算方法： add, multiply, divide 等</li></ul><h3 id="3-缓存池"><a href="#3-缓存池" class="headerlink" title="3. 缓存池"></a>3. 缓存池</h3><p>基本类型对应的缓冲池如下：</p><ul><li>boolean：true, false</li><li>byte、short、int、long：-128 ~ 127</li><li>char：\u0000 ~ \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p><h4 id="3-1-IntegerCache"><a href="#3-1-IntegerCache" class="headerlink" title="3.1 IntegerCache"></a>3.1 IntegerCache</h4><p>Integer 缓冲池 IntegerCache， 是静态类，上界可以通过参数调整。</p><p>加载的时候会初始化一个 int 数组，填上 -128 ~ 127 的值。</p><h4 id="3-2-valueOf-方法"><a href="#3-2-valueOf-方法" class="headerlink" title="3.2 valueOf() 方法"></a>3.2 valueOf() 方法</h4><p>valueOf() 方法会使用缓存池中的对象，多次调用会取得同一个对象的引用。</p><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 基础设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、类加载器"><a href="#一、类加载器" class="headerlink" title="一、类加载器"></a>一、类加载器</h2><h3 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1 类加载过程"></a>1 类加载过程</h3><p>虚拟机只加载程序执行时所需要的类文件。假设程序从 MyProgram.class 开始运行，下面是虚拟机执行的步骤：</p><ol><li>虚拟机有一个用于加载类文件的机制。</li><li>如果类拥有类型为另一个类的域，或者是拥有超类，那么这些类文件也会被加载。</li><li>接着，虚拟机执行类中的 main 方法。</li><li>如果 main 方法或者 main 调用的方法要用到更多的类，那么接下来就会加载这些类。</li></ol><p>每个Java程序至少拥有<strong>三个类加载器</strong>：</p><ul><li><p>启动类加载器(Bootstrap ClassLoader)</p><p>​    这个类加载器负责负责加载JDK中的核心类库，这个类加载器完全由JVM控制</p></li><li><p>扩展类加载器(Extendsion ClassLoader)</p><p>​    这个类加载器负责加载\lib\ext目录下的类库</p></li><li><p>应用程序类加载器(Application ClassLoader)</p><p>​    这个类加载器负责加载用户类路径(CLASSPATH)下的类库,一般我们编写的java类都是由这个类加载器加载</p></li></ul><h3 id="2-类加载器的层次结构"><a href="#2-类加载器的层次结构" class="headerlink" title="2 类加载器的层次结构"></a>2 类加载器的层次结构</h3><p>类加载器有一种父/子关系。除了引导类加载器外，每个类加载器都有一个父类加载器。父类加载失败子类才加载。</p><p>如果插件被打包为 JAR 文件，那就可以直接用 URLClassLoader 类的实例去加载这些类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"path"</span>);</span><br><span class="line">URLClassLoader pluginLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;url&#125;);</span><br><span class="line">Class&lt;?&gt; cl = pluginLoader.loadClass(<span class="string">"mypackage.MyClass"</span>);</span><br></pre></td></tr></table></figure><p>可以通过下面将其设置成为任何类加载器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">t.setContextClassLoader(loader);</span><br></pre></td></tr></table></figure><p>助手方法可以获取这个上下文类加载器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ClassLoader loader = t.getCOntextClassLoader();</span><br><span class="line">Class cl = loader.loaderClass(className);</span><br></pre></td></tr></table></figure><p>当调用由不同的类加载器加载的插件类的方法时，进行上下文类加载器的设置是一种好的思路；或者，让助手方法的调用者设置上下文类加载器。</p><h3 id="3-将类加载器作为命名空间"><a href="#3-将类加载器作为命名空间" class="headerlink" title="3 将类加载器作为命名空间"></a>3 将类加载器作为命名空间</h3><p>同一虚拟机中，可以有两个类的类名和包名都相同。类是由它的全名和类加载器来确定的。</p><h3 id="4-编写自己的类加载器"><a href="#4-编写自己的类加载器" class="headerlink" title="4 编写自己的类加载器"></a>4 编写自己的类加载器</h3><p>编写自己的类加载器，只需要继承 ClassLoader 类，然后覆盖下面这个方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findClass(String className)</span><br></pre></td></tr></table></figure><p>ClassLoader 超类的 loadClass 方法用于将类的加载操作委托给其父类加载器去进行，只有当该类尚未加载并且父类加载器也无法加载该类时，才调用 findClass 方法。</p><p>如果要实现该方法，必须做到以下几点：</p><ol><li>为来自本地文件系统或者其他来源的类加载其字节码</li><li>调用 ClassLoader 超类的 defineClass 方法，想虚拟机提供字节码。</li></ol><h3 id="5-字节码校验"><a href="#5-字节码校验" class="headerlink" title="5 字节码校验"></a>5 字节码校验</h3><p>当类加载器将新在加载的 Java 平台类的字节码传递给虚拟机，这些字节码首先要接受校验器的校验。校验器负责检查那些指令无法执行的明细那有破坏性的操作。出了系统类外，所有的类都要被校验。</p><p>下面是校验器执行的一些检查：</p><ul><li>变量要在使用之前进行初始化。</li><li>方法调用与对象引用类型之间要匹配。</li><li>访问私有类型和方法的规则没有被违反。</li><li>对本地变量的访问都落在运行时堆栈内。</li><li>运行时堆栈没有用溢出。</li></ul><h2 id="二、双亲委派原则"><a href="#二、双亲委派原则" class="headerlink" title="二、双亲委派原则"></a>二、双亲委派原则</h2><h3 id="1-双亲委派原则"><a href="#1-双亲委派原则" class="headerlink" title="1 双亲委派原则"></a>1 双亲委派原则</h3><p>一个类加载器受到类加载的请求，它会把这个请求转交到它的父加载器去请求，如果上级还有加载器，就继续把请求上传，直到启动类加载器。然后找到就返回给子加载器，直到第一个发出请求的类加载器。如果最后还是没有找到，就让子加载器自己去找</p><p><img src="https://imine141.github.io/images/1858901-20200325152628228-1073837913.png" alt="img"></p><h3 id="2-破坏双亲委派原则"><a href="#2-破坏双亲委派原则" class="headerlink" title="2 破坏双亲委派原则"></a>2 破坏双亲委派原则</h3><p>单一责任原则（SRP）不是绝对的。 它的存在有助于代码的可维护性和可读性。 但是您可能会不时看到解决方案，破坏SRP的模式，而且还可以。 其他原则也是如此，但是这次我想谈谈SRP。</p><p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。</p><h4 id="2-1-线程上下文类加载器（contextClassLoader）"><a href="#2-1-线程上下文类加载器（contextClassLoader）" class="headerlink" title="2.1 线程上下文类加载器（contextClassLoader）"></a>2.1 线程上下文类加载器（contextClassLoader）</h4><p>通过java.lang.Thread类中的<code>getContextClassLoader()</code>和 <code>setContextClassLoader(ClassLoader cl)</code>方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源，如下图所示，以jdbc.jar加载为例</p><p><img src="https://imine141.github.io/images/SouthEast.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式架构网络通信</title>
      <link href="/2020/08/07/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
      <url>/2020/08/07/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RPC（远程过程调用）"><a href="#一、RPC（远程过程调用）" class="headerlink" title="一、RPC（远程过程调用）"></a>一、RPC（远程过程调用）</h2><h4 id="1-RPC架构"><a href="#1-RPC架构" class="headerlink" title="1. RPC架构"></a>1. RPC架构</h4><ul><li><strong>客户端</strong>(Client)，服务的调用方。 </li><li><strong>客户端存根</strong>(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。 </li><li><strong>服务端</strong>(Server)，真正的服务提供者。 </li><li><strong>服务端存根</strong>(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法2</li></ul><h4 id="2-RPC调用过程"><a href="#2-RPC调用过程" class="headerlink" title="2.RPC调用过程"></a>2.RPC调用过程</h4><p><img src="E:%5Cproject%5CiMineBlog%5Csource%5Cimages%5C1608773784559.png" alt="调用过程"></p><p>RPC的目标是要把2、3、4、7、8、9这些步骤都封装起来。</p><p>注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。</p><p>在java中RPC框架比较多，常见的有Hessian、gRPC、Thrift、Dubbo 等，其实对于RPC框架而言，核心模块就是通讯和序列化</p><p>ps：RPC并不是一个具体的技术，而是指整个网络远程调用过程。</p><h2 id="二、RMI（远程方法调用）"><a href="#二、RMI（远程方法调用）" class="headerlink" title="二、RMI（远程方法调用）"></a>二、RMI（远程方法调用）</h2><p>Java RMI 指的是远程方法调用 (Remote Method Invocation),是java原生支持的远程调用</p><h4 id="1-RMI的架构"><a href="#1-RMI的架构" class="headerlink" title="1.RMI的架构"></a>1.RMI的架构</h4><p>客户端：</p><ul><li><p>存根/桩(Stub)：远程对象在客户端上的代理； </p></li><li><p>远程引用层(Remote Reference Layer)：解析并执行远程引用协议； </p></li><li><p>传输层(Transport)：发送调用、传递远程方法参数、接收远程方法执行结果。</p></li></ul><p>服务端：</p><ul><li>骨架(Skeleton)：读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值； </li><li>远程引用层(Remote Reference Layer)：处理远程引用后向骨架发送远程方法调用；</li><li>传输层(Transport)：监听客户端的入站连接，接收并转发调用到远程引用层。</li></ul><p>注册表(Registry):</p><ul><li>以URL形式注册远程对象，并向客户端回复对远程对象的引用。</li></ul><p><img src="E:%5Cproject%5CiMineBlog%5Csource%5Cimages%5C1608774595079.png" alt="rmi"></p><h3 id="RMI和RPC的区别"><a href="#RMI和RPC的区别" class="headerlink" title="RMI和RPC的区别"></a>RMI和RPC的区别</h3><p><strong>1：方法调用方式不同：</strong></p><ul><li>RMI中是通过在客户端的Stub对象作为远程接口进行远程方法的调用。每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用。</li><li>RPC中是通过网络服务协议向远程主机发送请求，请求包含了一个参数集和一个文本值，通常形成“classname.methodname(参数集)”的形式。RPC远程主机就去搜索与之相匹配的类和方法，找到后就执行方法并把结果编码，通过网络协议发回。</li></ul><p><strong>2：适用语言范围不同：</strong></p><ul><li>RMI只用于Java；</li><li>RPC是网络服务协议，与操作系统和语言无关。</li></ul><p><strong>3：调用结果的返回形式不同：</strong></p><ul><li>Java是面向对象的，所以RMI的调用结果可以是对象类型或者基本数据类型；</li><li>RMI的结果统一由外部数据表示，这种语言抽象了字节序类和数据类型结构之间的差异。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 分布式理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统设计策略</title>
      <link href="/2020/08/07/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/"/>
      <url>/2020/08/07/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>在分布式环境下，有几个问题是普遍关心的，我们称之为设计策略:</p><p>如何检测当前节点还活着?<br>如何保障高可用?<br>容错处理<br>负载均衡</p><h2 id="一、心跳检测"><a href="#一、心跳检测" class="headerlink" title="一、心跳检测"></a>一、心跳检测</h2><p>没有检测到心跳的时候，不代表节点死亡，可能是忙碌中。</p><p>通过下面两种方式来检测：</p><ul><li>周期检测心跳机制</li><li>累计失效检测机制</li></ul><h4 id="周期检测心跳机制"><a href="#周期检测心跳机制" class="headerlink" title="周期检测心跳机制"></a>周期检测心跳机制</h4><p>Server端每间隔 t 秒向Node集群发起监测请求，设定超时时间，如果超过超时时间，则判断“死亡”。</p><h4 id="累计失效检测机制"><a href="#累计失效检测机制" class="headerlink" title="累计失效检测机制"></a>累计失效检测机制</h4><p>在周期检测心跳机制的基础上，统计一定周期内节点的返回情况(包括超时及正确返回)，以此计算节点的“死亡”概率。另外，对于宣告“濒临死亡”的节点可以发起有限次数的重试，以作进一步判断。</p><p>通过周期检测心跳机制、累计失效检测机制可以帮助判断节点是否“死亡”，如果判断“死亡”，可以把该节点踢出集群</p><h2 id="二、高可用设计"><a href="#二、高可用设计" class="headerlink" title="二、高可用设计"></a>二、高可用设计</h2><p>系统高可用性的常用设计模式包括三种:主备(Master-SLave)、互备(Active-Active)和集群(Cluster)模式。</p><h4 id="1-主备模式"><a href="#1-主备模式" class="headerlink" title="1.主备模式"></a>1.主备模式</h4><p>当主机宕机时，备机接管主机的一切工作</p><h4 id="2-互备模式"><a href="#2-互备模式" class="headerlink" title="2.互备模式"></a>2.互备模式</h4><p>互备模式指两台主机同时运行各自的服务工作且相互监测情况</p><h4 id="3-集群模式"><a href="#3-集群模式" class="headerlink" title="3.集群模式"></a>3.集群模式</h4><p>多个节点在运行，同时可以通过主控节点分担服务请求</p><h2 id="三、容错性"><a href="#三、容错性" class="headerlink" title="三、容错性"></a>三、容错性</h2><p>容错的处理是保障分布式环境下相应系统的高可用或者健壮性，典型的案例就是对于缓存穿透问题的解决方案</p><p>我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据 库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，或者有人恶意攻击</p><p>如频繁发起为id为“-1”的条件进行查询，可能DB就挂掉了。</p><p>那这种问题有什么好办法解决呢?</p><p>一个比较巧妙的方法是，可以将这个不存在的key预先设定一个值。比如，key=“null”。在返回这个null值的时候， 我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是null，则可以认为这时候key有值 了，从而避免了透传到数据库，把大量的类似请求挡在了缓存之中。</p><h2 id="四、负载均衡"><a href="#四、负载均衡" class="headerlink" title="四、负载均衡"></a>四、负载均衡</h2>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 分布式理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式算法</title>
      <link href="/2020/08/06/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/08/06/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、分布式理论-一致性算法-Paxos"><a href="#一、分布式理论-一致性算法-Paxos" class="headerlink" title="一、分布式理论:一致性算法 Paxos"></a>一、分布式理论:一致性算法 Paxos</h2><h3 id="1-Paxos解决了什么问题？"><a href="#1-Paxos解决了什么问题？" class="headerlink" title="1. Paxos解决了什么问题？"></a>1. Paxos解决了什么问题？</h3><p>Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致</p><h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h3><p><strong>提案proposal</strong></p><ul><li>提案编号（proposal ID）</li><li>提案的值（value）</li></ul><p><strong>Paxos的三种角色</strong></p><ul><li>Proposer提案人</li><li>Acceptor决策者</li><li>Learners终决策的学习者 （就是最终将决策完的value，落实到下来。到物理机）    </li></ul><h3 id="3、Paxos的流程"><a href="#3、Paxos的流程" class="headerlink" title="3、Paxos的流程"></a>3、Paxos的流程</h3><h4 id="提案要求"><a href="#提案要求" class="headerlink" title="提案要求"></a>提案要求</h4><p>对于任意的Mn和Vn,如果提案[Mn,Vn]被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个： </p><ul><li>要么S中每个Acceptor都没有接受过编号小于Mn的提案。  </li><li>要么S中所有Acceptor批准的所有编号小于Mn的提案中，编号大的那个提案的value值为Vn</li></ul><h4 id="proposer生成提案"><a href="#proposer生成提案" class="headerlink" title="proposer生成提案"></a>proposer生成提案</h4><p> <strong>第一</strong>，Proposer选择一个新的提案编号N，然后向某个Acceptor集合（半数以上）发送请求，要求该集合中的每个 Acceptor做出如下响应（response）</p><p>（a）Acceptor向Proposer承诺保证不再接受任何编号小于N的提案。</p><p>（b）如果Acceptor已经接受过提案，那么就向Proposer反馈已经接受过的编号小于N的，但为大编号的提案的值</p><p>我们将该请求称为编号为N的<strong>Prepare请求</strong></p><p><strong>第二</strong>，如果Proposer收到了半数以上的Acceptor的响应，那么它就可以生成编号为N，Value为V的提案[N,V]。这里的V是所有的响应中编号大的提案的Value。如果所有的响应中都没有提案，那 么此时V就可以由Proposer 自己选择。 </p><p>生成提案后，Proposer将该提案发送给半数以上的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong></p><h4 id="accept接受提案"><a href="#accept接受提案" class="headerlink" title="accept接受提案"></a>accept接受提案</h4><p>一个Acceptor可能会受到来自Proposer的两种请求，分别是Prepare请求和Accept请求，对这两类请求作出响应的条件分别如</p><ul><li>Prepare请求：Acceptor可以在任何时候响应一个Prepare请求</li><li>Accept请求：在不违背Accept现有承诺的前提下，可以任意响应Accept请求 </li></ul><h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p>Acceptor忽略编号小于当前最大变好的Prepare请求</p><p><img src="E:%5Cproject%5CiMineBlog%5Csource%5Cimages%5C1608776443408.png" alt="1608776443408"></p><h3 id="4-Learner学习被选定value"><a href="#4-Learner学习被选定value" class="headerlink" title="4. Learner学习被选定value"></a>4. Learner学习被选定value</h3><p><strong>方案一：</strong> </p><p>Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准，因此，简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Learner</p><p>很显然，这种做法虽然可以让Learner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Learner逐个进行一次通信，通信的次数至少为二者个数的乘积</p><p><strong>方案二：</strong></p><p>另一种可行的方案是，我们可以让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的Learner（称为主Learner）, 各个Learner之间可以通过消息通信来互相感知提案的选定情况，基于这样的前提，当主Learner被通知一个提案已经被选定时，它会负责通知其他的learner</p><p>在这种方案中，Acceptor首先会将得到批准的提案发送给主Learner,再由其同步给其他Learner。因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的learner，但其通信次数却大大减少了，通常只是 Acceptor和Learner的个数总和，但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障  </p><p><strong>方案三：</strong></p><p>在讲解方案二的时候，我们提到，方案二大的问题在于主Learner存在单点问题，即主Learner随时可能出现故 障，因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的 Learner集合，该集合中每个Learner都可以在一个提案被选定后通知其他的Learner。这个Learner集合中的 Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高 </p><h3 id="5-如何保障Paxos算法的活性"><a href="#5-如何保障Paxos算法的活性" class="headerlink" title="5. 如何保障Paxos算法的活性"></a>5. 如何保障Paxos算法的活性</h3><p>假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的提案，导致终陷入死循环，没有 value被选定</p><p><strong>解决</strong>：通过选取主Proposer，并规定只有主Proposer才能提出议案。这样一来只要主Proposer和过半的Acceptor 能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准，这样通过选择一个主Proposer，整套Paxos算法就能够保持活性</p><h2 id="三、分布式理论-一致性算法-Raft"><a href="#三、分布式理论-一致性算法-Raft" class="headerlink" title="三、分布式理论:一致性算法 Raft"></a>三、分布式理论:一致性算法 Raft</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>Raft</strong> 是一种为了管理复制日志的一致性算法。 </p><p>Raft将一致性算法分解成了3模块 </p><ol><li>领导人选举</li><li>日志复制 </li><li>安全性</li></ol><p><strong>领导人角色</strong></p><ul><li>领导者(leader)：处理客户端交互，日志复制等动作，一般一次只有一个领导者 </li><li>候选者(candidate)：候选者就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者 </li><li>跟随者(follower)：类似选民，完全被动的角色，这样的服务器等待被通知投票</li></ul><p><strong>节点异常</strong></p><ul><li>leader不可用</li><li>follower不可用</li><li>多个candidate或多个leader</li><li>新节点加入集群</li></ul><h3 id="异常的解决"><a href="#异常的解决" class="headerlink" title="异常的解决"></a>异常的解决</h3><p><strong>1. leader 不可用；</strong></p><ul><li>一般情况下，leader 节点定时发送 heartbeat 到 follower 节点。</li><li>由于某些异常导致 leader 不再发送 heartbeat ，或 follower 无法收到 heartbeat 。</li><li>当某一 follower 发生 election timeout 时，其状态变更为 candidate，并向其他 follower发起投票。</li><li>当超过半数的 follower 接受投票后，这一节点将成为新的 leader，leader 的步进数加1并开始向follower同步日志</li><li>当一段时间之后，如果之前的 leader 再次加入集群，则两个 leader 比较彼此的步进数，步进数低的leader将切换自己的状态为follower。</li><li>较早前leader中不一致的日志将被清除，并与现有 leader中的日志保持一致。</li></ul><p><strong>2. follower 不可用；</strong> </p><ul><li>集群中的某个 follower 节点发生异常，不再同步日志以及接收 heartbeat。</li><li>经过一段时间之后，原来的 follower 节点重新加入集群。</li><li>这一节点的日志将从当时的 leader 处同步。</li></ul><p><strong>3. 多个 candidate 或多个 leader；</strong> </p><ul><li>初始状态下集群中的所有节点都处于 follower 状态。</li><li>两个节点同时成为 candidate 发起选举。</li><li>两个 candidate 都只得到了少部分 follower 的接受投票。</li><li>candidate 继续向其他的 follower 询问。</li><li>由于一些 follower 已经投过票了，所以均返回拒绝接受。</li><li>candidate 也可能向一个 candidate 询问投票。</li><li>在步进数相同的情况下，candidate 将拒绝接受另一个 candidate 的请求。</li><li>由于第一次未选出 leader，candidate 将随机选择一个等待间隔（150ms ~ 300ms）再次发起投    票。</li><li>如果得到集群中半数以上的 follower 的接受，这一 candidate 将成为 leader。</li><li>稍后另一个 candidate 也将再次发起投票。</li><li>由于集群中已经选出 leader，candidate 将收到拒绝接受的投票。</li><li>在被多数节点拒绝之后，并已知集群中已存在 leader 后，这一 candidate 节点将终止投票请求、切换为 follower，从 leader 节点同步日志。</li></ul><h3 id="日志复制过程"><a href="#日志复制过程" class="headerlink" title="日志复制过程"></a>日志复制过程</h3><ul><li>客户端的每一个请求都包含被复制状态机执行的指令。 </li><li>leader把这个指令作为一条新的日志条目添加到日志中，然后并行发起 RPC 给其他的服务器，让他们复制这条信息。</li><li>跟随者响应ACK,如果 follower 宕机或者运行缓慢或者丢包，leader会不断的重试，直到所有的 follower 终都复制了所有的日志条目。 </li><li>通知所有的Follower提交日志，同时领导人提交这条日志到自己的状态机中，并返回给客户端</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 分布式理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式理论</title>
      <link href="/2020/08/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
      <url>/2020/08/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-分布式概念"><a href="#1-分布式概念" class="headerlink" title="1. 分布式概念"></a>1. 分布式概念</h2><p>分布式系统，就是一个业务拆分成多个子业务，分布在不同的服务器节点，共同构成的系统称为分布式系统</p><p><strong>分布式与集群的区别</strong></p><ul><li><p>集群：多个人在一起作同样的事 。 </p></li><li><p>分布式 ：多个人在一起作不同的事 。</p></li></ul><p><strong>分布式系统的特点</strong></p><ul><li>分布性 </li><li>对等性</li><li>并发性</li><li>缺乏全局时钟</li><li>故障总是会发生</li></ul><p><strong>分布式的演变过程</strong></p><ul><li>阶段一：单应用架构 （包括应用、数据库都在一起）</li><li>阶段二：应用服务器与数据库服务器分离（应用服务器与数据库拆分）</li><li>阶段三：应用服务器集群（将应用服务器拆分为集群）</li><li>阶段四：应用服务器负载客户</li><li>阶段五：数据库读写分离</li><li>阶段六：添加搜索引擎缓解读库压力</li><li>阶段七：添加缓存机制缓解读库压力</li><li>阶段八：数据库水平/垂直拆分</li><li>阶段九：应用拆分</li><li>阶段十：服务化</li></ul><h2 id="2-分布式面临的问题"><a href="#2-分布式面临的问题" class="headerlink" title="2. 分布式面临的问题"></a><strong>2. 分布式面临的问题</strong></h2><p><strong>1) 通信异常</strong></p><p>就是网络情况不好，出现消息丢失和消息延迟等现象</p><p><strong>2) 网络分区</strong></p><p>因为网络异常，分布式系统中部分节点之间的网络延迟不断增大，最终只有部分节点可以正常通讯，另外的节点不能正常通讯，这个时候就会发生网络分区。这样分布式系统就会出现局部小集群，这就是<strong>脑裂问题</strong>。小集群回去执行原来整个系统要完成的事情。会产生对分布式一致性的挑战</p><p><strong>3) 节点故障</strong></p><p>节点故障是分布式系统下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或”僵死”现象，根据经验来说，每个节点都有可能出现故障，并且经常发生</p><p><strong>4) 三态</strong></p><p> 三态是，成功，失败，超时。分布式系统中，由于网络是不可靠的，虽然绝大部分情况下，网络通信能够接收到成功或失败的响应，但当网络出现异常的情况下，就会出现超时现象，通常有以下两种情况:</p><ol><li><p>由于网络原因，该请求并没有被成功的发送到接收方，而是在发送过程就发生了丢失现象。</p></li><li><p>该请求成功的被接收方接收后，并进行了处理，但在响应反馈给发送方过程中，发生了消息丢失现象。</p></li></ol><h2 id="3-分布式理论：一致性"><a href="#3-分布式理论：一致性" class="headerlink" title="3. 分布式理论：一致性"></a>3. 分布式理论：一致性</h2><p><strong>1）分布式一致性</strong></p><p>分布式数据一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。</p><p><strong>2）副本一致性</strong></p><p>因为分布式系统会存在网络延迟等问题，在副本拷贝时，就会出现同步不一致的问题</p><p><strong>3）数据一致性分类</strong></p><ul><li><p><strong>强一致性</strong></p><p>用户要求写什么，读出来就是什么，用户体验好，但实现起来困难</p></li><li><p><strong>弱一致性</strong></p><p>数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到 </p></li><li><p><strong>最终一致性 （最终一致性就是弱一致性）</strong></p></li><li><p><strong>读写一致性</strong></p><p>用户读取自己写入结果的一致性，保证用户永远能够第一时间看到自己更新的内容。 比如我们发一条朋友圈，朋友圈的内容是不是第一时间被朋友看见不重要，但是一定要显示在自己的列表上.</p><p><strong>解决方案:</strong></p><p>​    <strong>方案1</strong>:一种方案是对于一些特定的内容我们每次都去主库读取。 (问题主库压力大) </p><p>​    <strong>方案2</strong>:我们设置一个更新时间窗口，在刚刚更新的一段时间内，我们默认都从主库读取，过了这个窗口之后，我们会挑选最近有过更新的从库进行读取 </p><p>​    <strong>方案3</strong>:我们直接记录用户更新的时间戳，在请求的时候把这个时间戳带上，凡是最后更新时间小于这个时间戳的从库都不予以响应。</p></li><li><p><strong>单调读一致性</strong></p><p>本次读到的数据不能比上次读到的旧。</p><p>由于主从节点更新数据的时间不一致，导致用户在不停地刷新的时候，有时候能刷出来，再次刷新之后会发现数据不见了，再刷新又可能再刷出来，就好像遇见灵异事件一样</p><p><strong>解决方案:</strong></p><p>就是根据用户ID计算一个hash值，再通过hash值映射到机器。同一个用户不管怎么刷新，都只会被映射到同 一台机器上。这样就保证了不会读到其他从库的内容，带来用户体验不好的影响。</p></li><li><p><strong>因果一致性</strong></p><p>指的是:如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</p></li><li><p><strong>最终一致性</strong></p><p>最终一致性是所有分布式一致性模型当中最弱的。可以认为是没有任何优化的“最”弱一致性，它的意思是说，我不考虑所有的中间状态的影响，只保证当没有新的更新之后，经过一段时间之后，最终系统内所有副本的数据是正确的。 它最大程度上保证了系统的并发能力，也因此，在高并发的场景下，它也是使用最广的一致性模型。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 分布式理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式定理</title>
      <link href="/2020/08/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E7%90%86/"/>
      <url>/2020/08/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-分布式理论：CAP定理"><a href="#1-分布式理论：CAP定理" class="headerlink" title="1. 分布式理论：CAP定理"></a>1. 分布式理论：CAP定理</h2><p><strong>CAP 理论含义</strong>是，一个分布式系统不可能同时满足一致性（C:Consistency)，可用性（A: Availability）和分区容错 性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的2个。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>C 一致性</td><td>分布式系统当中的一致性指的是所有节点的数据一致，或者说是所有副本的数据一致</td></tr><tr><td>A 可用性</td><td>Reads and writes always succeed. 也就是说系统一直可用，而且服务一直保持正常</td></tr><tr><td>P 分区容错性</td><td>系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务</td></tr></tbody></table><h4 id="C-如何实现一致性"><a href="#C-如何实现一致性" class="headerlink" title="C - 如何实现一致性?"></a>C - 如何实现一致性?</h4><ol><li>写入主数据库后要数据同步到从数据库</li><li>写入主数据库后,在向从数据库同步期间要将从数据库锁定, 等待同步完成后在释放锁,以免在写新数据后,向从数据<br>库查询到旧的数据.</li></ol><h4 id="A-如何实现可用性"><a href="#A-如何实现可用性" class="headerlink" title="A - 如何实现可用性?"></a>A - 如何实现可用性?</h4><ol><li>写入主数据库后要将数据同步到从数据库</li><li>由于要保证数据库的可用性,不可以将数据库中资源锁定</li><li>即使数据还没有同步过来,从数据库也要返回查询数据, 哪怕是旧数据,但不能返回错误和超时</li></ol><h4 id="P-如何实现分区容错性"><a href="#P-如何实现分区容错性" class="headerlink" title="P - 如何实现分区容错性?"></a>P - 如何实现分区容错性?</h4><ol><li>尽量使用异步取代同步操作,举例 使用异步方式将数据从主数据库同步到从数据库, 这样节点之间能有效的实现松耦合;</li><li>添加数据库节点,其中一个从节点挂掉,由其他从节点提供服务</li></ol><h4 id="CAP只能3选2"><a href="#CAP只能3选2" class="headerlink" title="CAP只能3选2"></a>CAP只能3选2</h4><ul><li><p>舍弃A(可用性)，保留CP(一致性和分区容错性)</p><p>一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个 时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。</p></li><li><p>舍弃C(一致性)，保留AP(可用性和分区容错性)</p><p>这种是大部分的分布式系统的设计，保证高可用和分区容错，但是会牺牲一致性。</p></li><li><p>舍弃P(分区容错性)，保留CA(一致性和可用性)</p><p>如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在</p></li></ul><h2 id="2-分布式理论：BASE-理论"><a href="#2-分布式理论：BASE-理论" class="headerlink" title="2.分布式理论：BASE 理论"></a>2.分布式理论：BASE 理论</h2><h4 id="BASE："><a href="#BASE：" class="headerlink" title="BASE："></a>BASE：</h4><ul><li>Basically Available(基本可用)</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul><h4 id="1-Basically-Available-基本可用"><a href="#1-Basically-Available-基本可用" class="headerlink" title="1.Basically Available(基本可用)"></a>1.Basically Available(基本可用)</h4><ul><li>响应时间上的损失：响应时间增加</li><li>功能损失：服务降级</li></ul><h4 id="2-Soft-state（软状态）"><a href="#2-Soft-state（软状态）" class="headerlink" title="2.Soft state（软状态）"></a>2.Soft state（软状态）</h4><p>允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本之间进行数据同步的过程中存在延迟。</p><h4 id="3-Eventually-consistent（最终一致性）"><a href="#3-Eventually-consistent（最终一致性）" class="headerlink" title="3.Eventually consistent（最终一致性）"></a>3.Eventually consistent（最终一致性）</h4><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><h2 id="3-分布式理论：一致性协议-2PC"><a href="#3-分布式理论：一致性协议-2PC" class="headerlink" title="3.分布式理论：一致性协议 2PC"></a>3.分布式理论：一致性协议 2PC</h2><h4 id="1-什么是2PC？"><a href="#1-什么是2PC？" class="headerlink" title="1. 什么是2PC？"></a>1. 什么是2PC？</h4><ul><li>2 两个阶段</li><li>p 准备阶段</li><li>c 提交阶段</li></ul><h4 id="2-2PC（二阶段提交）流程"><a href="#2-2PC（二阶段提交）流程" class="headerlink" title="2. 2PC（二阶段提交）流程"></a>2. 2PC（二阶段提交）流程</h4><p><strong>阶段一：准备阶段</strong></p><ol><li>事务询问，协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。 </li><li>执行事务  (写本地的Undo/Redo日志) </li><li>各参与者向协调者反馈事务询问的响应 </li></ol><p><strong>阶段二：提交阶段</strong></p><ol><li>发送提交请求：协调者向所有参与者发出 commit 请求。 </li><li>事务提交：参与者收到 commit 请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。 </li><li>反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 信息。 </li><li>完成事务：协调者接收到所有参与者反馈的 Ack 信息后，完成事务。</li></ol><h4 id="3-2PC的缺点"><a href="#3-2PC的缺点" class="headerlink" title="3. 2PC的缺点"></a>3. 2PC的缺点</h4><ul><li>同步阻塞：一个参与者提交阶段，只有等到所有参与者都提交了，才能做其他操作</li><li>单点问题：协调者挂了</li><li>数据不一致：commit失败</li><li>过于保守：参与者挂了，只能通过协调者的策略来处理</li></ul><h2 id="4-分布式理论：一致性协议-3PC"><a href="#4-分布式理论：一致性协议-3PC" class="headerlink" title="4.分布式理论：一致性协议 3PC"></a>4.分布式理论：一致性协议 3PC</h2><p>3PC （将2PC的“提交事务请求”分为了两步），三阶段引入超时机制。同时在协调者和参与者中都引入超时机制，参与者会在协调者超时后，自动提交事务。</p><h4 id="1-3pc（三阶段提交）过程"><a href="#1-3pc（三阶段提交）过程" class="headerlink" title="1. 3pc（三阶段提交）过程"></a>1. 3pc（三阶段提交）过程</h4><p><strong>阶段一 CanCommit</strong></p><ul><li>事务询问</li><li>参与者反馈响应</li></ul><p><strong>阶段二 PreCommit</strong></p><ul><li>发送预提交请求</li><li>事务预提交</li><li>各参与者反馈结果</li></ul><p><strong>阶段三 DoCommit</strong>    </p><ul><li>发送提交请求</li><li>事务提交</li><li>反馈提交结果</li><li>完成事务</li></ul><h4 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h4><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><p><strong>总结</strong>：3pc相对于2pc，添加了超时机制，precommit中保障了各个节点状态是一致的。<strong>但是，无论是2pc 还是 3pc 都无法完全解决分布式一致性的问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 分布式理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发</title>
      <link href="/2020/08/01/Effective%20java/%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/08/01/Effective%20java/%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="第-78-条：同步访问共享的可变数据"><a href="#第-78-条：同步访问共享的可变数据" class="headerlink" title="第 78 条：同步访问共享的可变数据"></a>第 78 条：同步访问共享的可变数据</h3><h3 id="第-79-条：避免过度同步"><a href="#第-79-条：避免过度同步" class="headerlink" title="第 79 条：避免过度同步"></a>第 79 条：避免过度同步</h3><h3 id="第-80-条：executor-和-task-优先于线程"><a href="#第-80-条：executor-和-task-优先于线程" class="headerlink" title="第 80 条：executor 和 task 优先于线程"></a>第 80 条：executor 和 task 优先于线程</h3><ul><li>Executor.newCachedThreadPool：小程序，轻载的服务器</li><li>Executor.newFixedThreadPool：大负载的服务器</li><li>ThreadPoolExecutor：最大限度的控制</li><li>ScheduledThreadPoolExecutor：代替 java.util.Timer</li></ul><h3 id="第-81-条：并发工具优先于-wait-和-notify"><a href="#第-81-条：并发工具优先于-wait-和-notify" class="headerlink" title="第 81 条：并发工具优先于 wait 和 notify"></a>第 81 条：并发工具优先于 wait 和 notify</h3><p>java.util.concurrent 中更高级的工具分三类：Executor Framework，并发集合（Concurrent Collection）以及同步器（Synchronizer）。</p><p>优先使用 ConcurrentHashMap，而不是 Collections.synchronizedMap 或者 Hashtable</p><p>最常用的同步器是 CountDownLatch 和 Semaphore，不常用的是 Barrier 和 Exchanger。</p><p>对于间歇式定时,应该始终使用 System.nanoTime 而不是 System.cucurrentTimeMills。</p><h3 id="第-82-条：线程安全性的文档化"><a href="#第-82-条：线程安全性的文档化" class="headerlink" title="第 82 条：线程安全性的文档化"></a>第 82 条：线程安全性的文档化</h3><p>一个类为了可被多个线程安全使用，必须在文档中清楚地说明它所支持的线程安全性级别。</p><h3 id="第-83-条：慎用延迟初始化"><a href="#第-83-条：慎用延迟初始化" class="headerlink" title="第 83 条：慎用延迟初始化"></a>第 83 条：慎用延迟初始化</h3><p>对于延迟初始化，最好建议“除非绝对必要，否则就不要那么做”。延迟化降低了初始化类或者创建实例的开销，却增加了访问被延迟初始化的域的开销。</p><p>如果域只是在类的实例部分被访问，并且初始化这个域的开销很高，可能就值得进行延迟初始化。</p><ul><li>静态域：lazy initialization holder class 模式。</li><li>实例域：双重检查模式。</li></ul><h3 id="第-84-条：不要依赖于线程调度器"><a href="#第-84-条：不要依赖于线程调度器" class="headerlink" title="第 84 条：不要依赖于线程调度器"></a>第 84 条：不要依赖于线程调度器</h3><p>不要让应用程序的并发性依赖于线程调度器</p><p>不要依赖 Thread.yield 和线程优先级</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2020/07/31/Effective%20java/%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/07/31/Effective%20java/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="第-69-条：只针对异常的情况才使用异常"><a href="#第-69-条：只针对异常的情况才使用异常" class="headerlink" title="第 69 条：只针对异常的情况才使用异常"></a>第 69 条：只针对异常的情况才使用异常</h3><p>如果在 try、catch、finally 块中都抛出了异常，只是只有一个异常可被传播到外界。</p><p>请不要在 try 块中发出对 return、break 或 continue 的调用，万一无法避免，一定要确保 finally 的存在不会改变函数的返回值（比如说抛异常、return 以及其他任何引起程序退出的调用）。因为那样会引起流程混乱或返回值不确定，如果有返回值最好在 try 与 finally 外返回。</p><p>如果构造器调用的代码需要抛出异常，就不要在构造器处理它，而是直接在构造器声明上 throws 出来</p><h3 id="第-70-条：对可恢复的情况使用受检异常-对编程错误使用运用时异常"><a href="#第-70-条：对可恢复的情况使用受检异常-对编程错误使用运用时异常" class="headerlink" title="第 70 条：对可恢复的情况使用受检异常,对编程错误使用运用时异常"></a>第 70 条：对可恢复的情况使用受检异常,对编程错误使用运用时异常</h3><h3 id="第-71-条：避免不必要地使用受检异常"><a href="#第-71-条：避免不必要地使用受检异常" class="headerlink" title="第 71 条：避免不必要地使用受检异常"></a>第 71 条：避免不必要地使用受检异常</h3><h3 id="第-72-条：优先使用标准异常"><a href="#第-72-条：优先使用标准异常" class="headerlink" title="第 72 条：优先使用标准异常"></a>第 72 条：优先使用标准异常</h3><h3 id="第-73-条：抛出与抽象对象相对应的异常"><a href="#第-73-条：抛出与抽象对象相对应的异常" class="headerlink" title="第 73 条：抛出与抽象对象相对应的异常"></a>第 73 条：抛出与抽象对象相对应的异常</h3><p>处理底层异常最好的方法首选是阻止底层异常的发生，如果不能阻止或者处理底层异常时，一般的做法是使用异常转换（包括异常链转换），除非底层方法碰巧可以保证抛出的异常对高层也合适才可以将底层异常直接从底层传播到高层。</p><h3 id="第-74-条：每个方法抛出的异常都要有文档描述"><a href="#第-74-条：每个方法抛出的异常都要有文档描述" class="headerlink" title="第 74 条：每个方法抛出的异常都要有文档描述"></a>第 74 条：每个方法抛出的异常都要有文档描述</h3><p>如果一个方法可能抛出多个异常类，则不要使用“快捷方式”声明它会抛出这此异常类的某个超类。永远不要声明一个方法“throws Exception”，或者更糟的是声明“throws Throwable”。</p><p>要为你编写的每个方法所能摆好出的每个异常建立文档，对于未受检和受检异常，以及对于抽象的和具体的方法也都一样。</p><h3 id="第-75-条：异常信息中要包含足够详细的异常细节消息"><a href="#第-75-条：异常信息中要包含足够详细的异常细节消息" class="headerlink" title="第 75 条：异常信息中要包含足够详细的异常细节消息"></a>第 75 条：异常信息中要包含足够详细的异常细节消息</h3><h3 id="第-76-条：努力使失败保持原子性"><a href="#第-76-条：努力使失败保持原子性" class="headerlink" title="第 76 条：努力使失败保持原子性"></a>第 76 条：努力使失败保持原子性</h3><p>作为方法规范的一部分，任何一个异常都不应该改变对象调用该方法之前的状态，如果这条规则被违反，则API文档中应该清楚的指明对象将会处于什么样的状态。</p><h3 id="第-77-条：不要忽略异常"><a href="#第-77-条：不要忽略异常" class="headerlink" title="第 77 条：不要忽略异常"></a>第 77 条：不要忽略异常</h3><p>空的 catch 块至少应该包含一条说明，用来解释为什么忽略这个异常是合适的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法</title>
      <link href="/2020/07/30/Effective%20java/%E6%96%B9%E6%B3%95/"/>
      <url>/2020/07/30/Effective%20java/%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="第-49-条：检查参数的有效性"><a href="#第-49-条：检查参数的有效性" class="headerlink" title="第 49 条：检查参数的有效性"></a>第 49 条：检查参数的有效性</h3><p>不仅需要检查参数的有效性，还需要在函数的文档中给予明确的说明，如在参数非法的情况下，会抛出哪些异常，或导致函数返回哪些错误值等</p><h3 id="第-50-条：必要时进行保护性拷贝"><a href="#第-50-条：必要时进行保护性拷贝" class="headerlink" title="第 50 条：必要时进行保护性拷贝"></a>第 50 条：必要时进行保护性拷贝</h3><p>如果不能够容忍对象进入数据结构之后发生变，就必须对该对象进行保护性拷贝，并且让拷贝之后的对象而不是原始对象进入到数据结构中。</p><h3 id="第-51-条：谨慎设计方法签名"><a href="#第-51-条：谨慎设计方法签名" class="headerlink" title="第 51 条：谨慎设计方法签名"></a>第 51 条：谨慎设计方法签名</h3><ul><li>谨慎地选择方法的名称</li><li>避免过长的参数列表，如果多于四个了就该考虑重构这个方法了</li><li>对于参数类型、要优先使用接口而不是类。</li><li>对于 boolean 参数，优先使用两个元素的枚举类型。</li></ul><h3 id="第-52-条：慎用重载"><a href="#第-52-条：慎用重载" class="headerlink" title="第 52 条：慎用重载"></a>第 52 条：慎用重载</h3><p>对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。</p><ol><li>安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。</li><li>如果方法使用可变参数，保守的策略是根本不要重载它。</li><li>在 Java 1.5 之后，需要对自动装箱机制保持警惕。</li></ol><p>对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。我们应当保证：当传递同样的参数时，所有重载方法的行为必须一致。</p><h3 id="第-53-条：慎用可变参数"><a href="#第-53-条：慎用可变参数" class="headerlink" title="第 53 条：慎用可变参数"></a>第 53 条：慎用可变参数</h3><p>有的时候在重视性能的情况下，使用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。</p><h3 id="第-54-条：返回零长度的数组或者集合，而不是-null"><a href="#第-54-条：返回零长度的数组或者集合，而不是-null" class="headerlink" title="第 54 条：返回零长度的数组或者集合，而不是 null"></a>第 54 条：返回零长度的数组或者集合，而不是 null</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final Cheese[] EMPTY_CHEESE_ARRAY&#x3D; new Cheese[0];</span><br><span class="line">Collections.emptyList();</span><br><span class="line">Collections.emptySet();</span><br><span class="line">Collections.emptyMap();</span><br></pre></td></tr></table></figure><h3 id="第-55-条-返回-Optional-类型"><a href="#第-55-条-返回-Optional-类型" class="headerlink" title="第 55 条: 返回 Optional 类型"></a>第 55 条: 返回 Optional 类型</h3><h3 id="第-56-条：为所有导出的API元素编写文档注释"><a href="#第-56-条：为所有导出的API元素编写文档注释" class="headerlink" title="第 56 条：为所有导出的API元素编写文档注释"></a>第 56 条：为所有导出的API元素编写文档注释</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambdas 与 Streams</title>
      <link href="/2020/07/29/Effective%20java/Lambdas%20%E4%B8%8E%20Streams/"/>
      <url>/2020/07/29/Effective%20java/Lambdas%20%E4%B8%8E%20Streams/</url>
      
        <content type="html"><![CDATA[<h3 id="第-42-条：lambdas-优于匿名类"><a href="#第-42-条：lambdas-优于匿名类" class="headerlink" title="第 42 条：lambdas 优于匿名类"></a>第 42 条：lambdas 优于匿名类</h3><p>从 Java 8 开始，lambda 是迄今为止表示小函数对象的最佳方式。 除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象。</p><p>lambda 没有名称和文档，如果超过三行，不要使用 lambda 表达式。</p><h3 id="第-43-条-方法引用优于-lambdas"><a href="#第-43-条-方法引用优于-lambdas" class="headerlink" title="第 43 条: 方法引用优于 lambdas"></a>第 43 条: 方法引用优于 lambdas</h3><p>如果方法引用看起来更简短更清晰，请使用它们；否则，还是坚持 lambda。</p><table><thead><tr><th>方法引用类型</th><th>举例</th><th>等同的 Lambda</th></tr></thead><tbody><tr><td>Static</td><td>Integer::parseInt</td><td>str -&gt; Integer.parseInt(str)</td></tr><tr><td>Bound</td><td>Instant.now()::isAfter</td><td>Instant then = Instant.now(); t -&gt; then.isAfter(t)</td></tr><tr><td>Unbound</td><td>String::toLowerCase</td><td>str -&gt; str.toLowerCase()</td></tr><tr><td>Class Constructor</td><td>TreeMap&lt;K,V&gt;::new</td><td>() -&gt; new TreeMap&lt;K,V&gt;</td></tr><tr><td>Array Constructor</td><td>int[]::new</td><td>len -&gt; new int[len]</td></tr></tbody></table><h3 id="第-44-条-优先使用标准的函数式接口"><a href="#第-44-条-优先使用标准的函数式接口" class="headerlink" title="第 44 条: 优先使用标准的函数式接口"></a>第 44 条: 优先使用标准的函数式接口</h3><p>设计API时必须考虑 lambda 表达式。 在输入上接受函数式接口类型并在输出中返回它们。 一般来说，最好使用 java.util.function.Function 中提供的标准接口</p><table><thead><tr><th>接口</th><th>方法</th><th>示例</th><th>表示</th></tr></thead><tbody><tr><td>UnaryOperator</td><td>T apply(T t)</td><td>String::toLowerCase</td><td>方法的结果和参数类型相同</td></tr><tr><td>BinaryOperator</td><td>T apply(T t1, T t2)</td><td>BigInteger::add</td><td>方法的结果和参数类型相同</td></tr><tr><td>Predicate</td><td>boolean test(T t)</td><td>Collection::isEmpty</td><td>方法接受一个参数并返回一个布尔值</td></tr><tr><td>Function&lt;T,R&gt;</td><td>R apply(T t)</td><td>Arrays::asList</td><td>参数和返回类型不同</td></tr><tr><td>Supplier</td><td>T get()</td><td>Instant::now</td><td>一个不接受参数和返回值(或“供应”)的方法</td></tr><tr><td>Consumer</td><td>void accept(T t)</td><td>System.out::println</td><td>接受一个参数而不返回任何东西</td></tr></tbody></table><h3 id="第-45-条-明智审慎地使用-Stream"><a href="#第-45-条-明智审慎地使用-Stream" class="headerlink" title="第 45 条: 明智审慎地使用 Stream"></a>第 45 条: 明智审慎地使用 Stream</h3><p>在没有显式类型的情况下，仔细命名 lambda 参数对于流管道的可读性至关重要。</p><p>使用辅助方法对于流管道中的可读性比在迭代代码中更为重要</p><p>重构现有代码以使用流，并仅在有意义的情况下在新代码中使用它们。</p><p>如果不确定一个任务是通过流还是迭代更好地完成，那么尝试这两种方法，看看哪一种效果更好。</p><h3 id="第-46-条-优先考虑流中无副作用的函数"><a href="#第-46-条-优先考虑流中无副作用的函数" class="headerlink" title="第 46 条: 优先考虑流中无副作用的函数"></a>第 46 条: 优先考虑流中无副作用的函数</h3><h3 id="第-47-条-返回类型优先选择集合而不是流"><a href="#第-47-条-返回类型优先选择集合而不是流" class="headerlink" title="第 47 条: 返回类型优先选择集合而不是流"></a>第 47 条: 返回类型优先选择集合而不是流</h3><p>如果返回集合是可行的，请执行此操作。如果返回集合是不可行的，则返回流或可迭代的。</p><p>如果在将来的 Java 版本中，Stream 接口声明被修改为继承 Iterable，那么可随意返回流。</p><h3 id="第-48-条-谨慎使用流并行"><a href="#第-48-条-谨慎使用流并行" class="headerlink" title="第 48 条: 谨慎使用流并行"></a>第 48 条: 谨慎使用流并行</h3><p>不恰当地并行化流的代价可能是程序失败或性能灾难。使用并行流之前，请确保您的代码在并行运行时保持正确，并在实际情况下进行仔细的性能度量。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举和注解</title>
      <link href="/2020/07/28/Effective%20java/%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/07/28/Effective%20java/%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="第-34-条：用-enum-代替-int-常量"><a href="#第-34-条：用-enum-代替-int-常量" class="headerlink" title="第 34 条：用 enum 代替 int 常量"></a>第 34 条：用 enum 代替 int 常量</h3><p>当需要一组固定常量的时候，应该使用 enum 代替 int 常量。</p><h3 id="第-35-条：用实例域代替序数"><a href="#第-35-条：用实例域代替序数" class="headerlink" title="第 35 条：用实例域代替序数"></a>第 35 条：用实例域代替序数</h3><p>应该给 enum 添加 int 域，而不是使用 ordinal() 方法来导出与枚举关联的序数值。(几乎不应使用 ordinal() 方法，除非在编写像 EnumMap 这样的基于枚举的通用数据结构)</p><h3 id="第36条：用-EnumSet-代替位域"><a href="#第36条：用-EnumSet-代替位域" class="headerlink" title="第36条：用 EnumSet 代替位域"></a>第36条：用 EnumSet 代替位域</h3><ul><li>EnumSet 实现了 Set 接口</li><li>若枚举类型个数小于 64 个，则整个 EnumSet 就用单个 long 来表示，性能上比得上位运算</li><li>总而言之因为枚举类型要用在集合(Set)中,所以没有理由用位域来表示.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;WRONG</span><br><span class="line">public class Text&#123;</span><br><span class="line">    private static final int STYLE_BOLD &#x3D; 1 &lt;&lt; 0;</span><br><span class="line">    private static final int STYLE_ITALIC &#x3D; 1 &lt;&lt; 1;</span><br><span class="line">    private static final int STYLE_UNDERLINE &#x3D; 1 &lt;&lt; 2;</span><br><span class="line">    </span><br><span class="line">    public void applyStyles(int styles) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;use</span><br><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;RIGHT</span><br><span class="line">public class Text&#123;</span><br><span class="line">    public enum Style&#123;STYLE_BOLD, STYLE_ITALIC, STYLE_UNDERLINE&#125;</span><br><span class="line">    </span><br><span class="line">    public void applyStyles(Set&lt;Style&gt; styles) &#123;...&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;use</span><br><span class="line">text.applyStyles(EnumSet.of(STYLE_BOLD, STYLE_ITALIC));</span><br></pre></td></tr></table></figure><h3 id="第-37-条：用-EnumMap-代替序数索引"><a href="#第-37-条：用-EnumMap-代替序数索引" class="headerlink" title="第 37 条：用 EnumMap 代替序数索引"></a>第 37 条：用 EnumMap 代替序数索引</h3><p>序数索引是指依赖于枚举成员在枚举中的序数来进行数组索引</p><p>应该使用 EnumMap 来实现，EnumMap 内部是采用数组实现的，具有 Map 的丰富功能和类型安全以及数组的效率</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;Plant.Type, Set&lt;Plant&gt;&gt; plants &#x3D; new EnumMap&lt;Plant.Type, Set&lt;Plant&gt;&gt;(Plant.Type.class); </span><br><span class="line"></span><br><span class="line">for(Plant.Type type : Plant.Type.valuse())&#123;</span><br><span class="line">    plants.put(type, new HashSet&lt;Plant&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(Plant p : garden)&#123;</span><br><span class="line">    plants.get(p.type).add(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第-38-条：用接口模拟可以伸缩的枚举"><a href="#第-38-条：用接口模拟可以伸缩的枚举" class="headerlink" title="第 38 条：用接口模拟可以伸缩的枚举"></a>第 38 条：用接口模拟可以伸缩的枚举</h3><p>由于在 Java 中 enum 不是可扩展的，在某些情况下，可能需要对枚举进行扩展，比如操作类型（±*/等），就可以考虑：</p><ol><li>定义一个接口，比如<code>public interface Operation{…};</code></li><li>使枚举继承接口：比如<code>public enum BasicOperation implements Operation{…}</code></li><li>使用时的 API 写成接口(比如，<code>T extends Enum &amp; Operation)</code>，而不是实现（比如<code>BasicOperation</code>）</li><li>当需要扩展<code>BasicOperation</code>枚举时，就可以另写一个枚举，且 implements 接口<code>Operation</code></li></ol><h3 id="第-39-条：注解优先于命名模式"><a href="#第-39-条：注解优先于命名模式" class="headerlink" title="第 39 条：注解优先于命名模式"></a>第 39 条：注解优先于命名模式</h3><h3 id="第-40-条：坚持使用-Override-注解"><a href="#第-40-条：坚持使用-Override-注解" class="headerlink" title="第 40 条：坚持使用 Override 注解"></a>第 40 条：坚持使用 Override 注解</h3><h3 id="第-41-条：用标记接口实现类型"><a href="#第-41-条：用标记接口实现类型" class="headerlink" title="第 41 条：用标记接口实现类型"></a>第 41 条：用标记接口实现类型</h3><p>标记接口可以在编译时就检查到相应的类型问题，而标记注解则要到运行时。</p><ul><li>如果标记是应用到任何程序元素而不是类或者接口,就必须使用注解. 因为只有 类和接口可以用来实现或者扩展接口</li><li>如果标记只应用给类和接口,就应该 优先使用标记接口而非注解</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2020/07/27/Effective%20java/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2020/07/27/Effective%20java/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="第-26-条：请不要在新代码中使用原生态类型"><a href="#第-26-条：请不要在新代码中使用原生态类型" class="headerlink" title="第 26 条：请不要在新代码中使用原生态类型"></a>第 26 条：请不要在新代码中使用原生态类型</h3><p>原生态类型只为了与引入泛型之前的遗留代码进行兼容和互用而提供的。</p><p>List 原生态类型</p><p>List<T> 泛型</p><h3 id="第-27-条：消除非受检警告"><a href="#第-27-条：消除非受检警告" class="headerlink" title="第 27 条：消除非受检警告"></a>第 27 条：消除非受检警告</h3><p>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，只有在这种情况下才可以用一个 @SuppressWarnings(“unchecked”) 注解来禁止这条警告。</p><h3 id="第-28-条：列表优先于数组"><a href="#第-28-条：列表优先于数组" class="headerlink" title="第 28 条：列表优先于数组"></a>第 28 条：列表优先于数组</h3><h3 id="第-29-条：优先考虑泛型"><a href="#第-29-条：优先考虑泛型" class="headerlink" title="第 29 条：优先考虑泛型"></a>第 29 条：优先考虑泛型</h3><h3 id="第-30-条：优先考虑泛型方法"><a href="#第-30-条：优先考虑泛型方法" class="headerlink" title="第 30 条：优先考虑泛型方法"></a>第 30 条：优先考虑泛型方法</h3><h3 id="第-31-条：利用有限制通配符来提升API的灵活性"><a href="#第-31-条：利用有限制通配符来提升API的灵活性" class="headerlink" title="第 31 条：利用有限制通配符来提升API的灵活性"></a>第 31 条：利用有限制通配符来提升API的灵活性</h3><p> 限定通配符包括两种： </p><ol><li>表示类型的上界，格式为：&lt;？ extends T&gt;，即类型必须为T类型或者T子类</li><li>表示类型的下界，格式为：&lt;？ super T&gt;，即类型必须为T类型或者T的父类 </li></ol><h3 id="第-32-条-明智地结合泛型和可变参数"><a href="#第-32-条-明智地结合泛型和可变参数" class="headerlink" title="第 32 条: 明智地结合泛型和可变参数"></a>第 32 条: 明智地结合泛型和可变参数</h3><h3 id="第-33-条：优先考虑类型安全的异构容器"><a href="#第-33-条：优先考虑类型安全的异构容器" class="headerlink" title="第 33 条：优先考虑类型安全的异构容器"></a>第 33 条：优先考虑类型安全的异构容器</h3><p>异构容器</p><p>异构容器是指能够容纳不同类型对象的容器。像我们通常用的<code>List</code>、<code>Map</code>等容器，它们的原生态类型本身就是异构容器，一旦给它们设置了泛型参数，例如<code>List</code>、<code>Map</code>，它们就不再是异构容器。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和接口</title>
      <link href="/2020/07/26/Effective%20java/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/07/26/Effective%20java/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="第-15-条：使类和成员的可访问性最小化"><a href="#第-15-条：使类和成员的可访问性最小化" class="headerlink" title="第 15 条：使类和成员的可访问性最小化"></a>第 15 条：使类和成员的可访问性最小化</h3><p>公有静态 final 域暴露常量，要么包含基本类型值，要么包含指向不可变对象的引用</p><h3 id="第-16-条：在公有类中使用访问方法而非公有域"><a href="#第-16-条：在公有类中使用访问方法而非公有域" class="headerlink" title="第 16 条：在公有类中使用访问方法而非公有域"></a>第 16 条：在公有类中使用访问方法而非公有域</h3><ul><li>公有类不应该暴露可变域，因为其客户端代码遍布各处，将来极难改变内部表示法</li><li>公有类暴露不可变域危害较小，事实上也不应该</li><li>包级私有或私有嵌套类，直接暴露数据域并没有本质错误</li></ul><h3 id="第-17-条：使可变性最小化"><a href="#第-17-条：使可变性最小化" class="headerlink" title="第 17 条：使可变性最小化"></a>第 17 条：使可变性最小化</h3><p>如果类不能被做成不可变，仍然应该尽可能限制它的可变性，降低对象可以存在的状态数！构造器应该创建完全初始化的对象，并建立所有的约束关系，不要在构造器或静态工厂之外再提供公有的初始化方法，除非有足够的理由！</p><h3 id="第-18-条：复合优先于继承"><a href="#第-18-条：复合优先于继承" class="headerlink" title="第 18 条：复合优先于继承"></a>第 18 条：复合优先于继承</h3><p>在包内部使用继承是安全的，跨越包边界的继承是危险的</p><h3 id="第-19-条：要么为继承而设计，并提供文档说明，要么就禁止继承"><a href="#第-19-条：要么为继承而设计，并提供文档说明，要么就禁止继承" class="headerlink" title="第 19 条：要么为继承而设计，并提供文档说明，要么就禁止继承"></a>第 19 条：要么为继承而设计，并提供文档说明，要么就禁止继承</h3><p>对于专门为继承而设计且有良好文档说明的类</p><ul><li>该类文档必须有文档说明它可覆盖方法的自用性</li><li>该类必须通过某种形式提供适当的钩子，以便能进入它的内部工作流程中</li><li>构造器，clone 或者 readObject 绝不能调用可被覆盖的方法，不管是直接还是间接</li></ul><p>并非为了安全进行子类化而设计和编写文档的类，要禁止子类化</p><ul><li>将类声明为 final</li><li>将构造器变成 private 或 package-private，并增加一些公有的静态工厂来替代构造器</li></ul><h3 id="第-20-条：接口优于抽象类"><a href="#第-20-条：接口优于抽象类" class="headerlink" title="第 20 条：接口优于抽象类"></a>第 20 条：接口优于抽象类</h3><p>接口与抽象类的区别</p><ul><li>抽象类允许包含某些方法的实现，接口不允许</li><li>为实现抽象类定义类型，类必须成为抽象类的子类，而接口则不用关心类层次</li><li>现有类容易被更新以实现新接口，一般无法更新现有类来扩展新抽象类</li><li>接口是定义 mixin 的理想选择，mixin 用来表明类提供了某些可供选择的行为，允许任选功能混合到类型主要功能中</li><li>接口允许构造非层次结构的类型框架</li></ul><h3 id="第-21-条-为子类设计接口"><a href="#第-21-条-为子类设计接口" class="headerlink" title="第 21 条: 为子类设计接口"></a>第 21 条: 为子类设计接口</h3><p>编写一个默认方法并不总是可能的，它保留了每个可能的实现的所有不变量。</p><p>在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败。</p><h3 id="第-22-条：接口只用于定义类型"><a href="#第-22-条：接口只用于定义类型" class="headerlink" title="第 22 条：接口只用于定义类型"></a>第 22 条：接口只用于定义类型</h3><p>常量接口模式是对接口的不良使用，是反面典型，不值得效仿！</p><p>关键原因：如果类实现常量接口，将来版本中类修改了，不需要这些常量了，它还依然必须实现这个接口，以确保二进制兼容性！</p><h3 id="第-23-条：类层次优于标签类"><a href="#第-23-条：类层次优于标签类" class="headerlink" title="第 23 条：类层次优于标签类"></a>第 23 条：类层次优于标签类</h3><p>类层次！首先，定义一个抽象类作为根类，提取公用方法到抽象类中！然后，为每种原始标签类定义根类的具体子类，子类包含特定域和方法！</p><h3 id="第-24-条：优先考虑静态成员类，而不是非静态类"><a href="#第-24-条：优先考虑静态成员类，而不是非静态类" class="headerlink" title="第 24 条：优先考虑静态成员类，而不是非静态类"></a>第 24 条：优先考虑静态成员类，而不是非静态类</h3><h3 id="第-25-条-将源文件限制为单个顶级类"><a href="#第-25-条-将源文件限制为单个顶级类" class="headerlink" title="第 25 条: 将源文件限制为单个顶级类"></a>第 25 条: 将源文件限制为单个顶级类</h3><p>虽然 Java 编译器允许在单个源文件中定义多个顶级类，但这样做没有任何好处，并且存在重大风险。 风险源于在源文件中定义多个顶级类使得为类提供多个定义成为可能。 使用哪个定义会受到源文件传递给编译器的顺序的影响。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对所有对象都通用的方法</title>
      <link href="/2020/07/25/Effective%20java/%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/07/25/Effective%20java/%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="第-10-条：覆盖-equals-时请遵守通用约定"><a href="#第-10-条：覆盖-equals-时请遵守通用约定" class="headerlink" title="第 10 条：覆盖 equals 时请遵守通用约定"></a>第 10 条：覆盖 equals 时请遵守通用约定</h3><ul><li>自反性 - 对象必须等于其自身</li><li>对称性 - 任何两个对象对于它们是否相等的问题都必须保持一致，Timestamp 违反了，不值得效仿</li><li>传递性 - 如果对象 A 等于B，B 等于 C，那么 A 一定等于 C</li><li>一致性 - 相等的对象永远相等，不相等的对象永远不相等</li><li>非空性 - 所有的对象都必须不等于 null</li></ul><h3 id="第-11-条：覆盖-equals-时总要覆盖-hashCode"><a href="#第-11-条：覆盖-equals-时总要覆盖-hashCode" class="headerlink" title="第 11 条：覆盖 equals 时总要覆盖 hashCode"></a>第 11 条：覆盖 equals 时总要覆盖 hashCode</h3><ul><li>程序一次执行期间，只要对象的 equals 比较用到的信息没有被修改，则对该对象调用多次 hashCode 都必须返回同一值</li><li>程序多次执行过程，每次执行返回的 hashCode 可以不一致</li><li>相等的对象必须有相等的散列码</li><li>不相等的对象不一定要产生不同的散列码，但是通常倾向于为不相等对象产生不相等的散列码</li></ul><p>注意，如果一个类是不可变的，同时计算散列码开销也大，则可把散列码缓存在对象内部！不要试图从散列码计算中排除掉一个对象的关键部分来提高性能！</p><h3 id="第-12-条：始终要覆盖toString"><a href="#第-12-条：始终要覆盖toString" class="headerlink" title="第 12 条：始终要覆盖toString"></a>第 12 条：始终要覆盖toString</h3><p>java.lang.Object 提供了 toString 方法的一个实现：类名 + ‘@’ + 散列码无符号 16 进制表示！</p><p>无论是否指定格式，都为 toString 返回值中包含的所有信息提供一种编程式的访问途径！如果没有，则会迫使程序员编写额外代码解析字符串，既降低性能，又容易解析出错导致系统不稳定！</p><h3 id="第-13-条：谨慎地覆盖-clone"><a href="#第-13-条：谨慎地覆盖-clone" class="headerlink" title="第 13 条：谨慎地覆盖 clone"></a>第 13 条：谨慎地覆盖 clone</h3><p>Object 的 clone 方法是受保护的！Cloneable 接口没有包含任何方法！Cloneable 改变了超类中受保护的方法的行为！对于实现了 Cloneable 的类，我们总是希望它提供一个功能适当的公有的 clone 方法！此方法首先调用 super.clone，然后修正任何需要修正的域！</p><p>实现对象拷贝更好的办法</p><ul><li>拷贝构造器 - 唯一参数类型是包含该构造器的类，<code>public Yum(Yum yum);</code></li><li>拷贝工厂 - <code>public static Yum newInstance(Yum yum);</code></li></ul><h3 id="第-14-条：考虑实现-Comparable-接口"><a href="#第-14-条：考虑实现-Comparable-接口" class="headerlink" title="第 14 条：考虑实现 Comparable 接口"></a>第 14 条：考虑实现 Comparable 接口</h3><p>包含 compareTo 方法的对象与指定对象比较，当该对象小于、等于或者大于指定对象时，分别返回一个负整数、零或者正整数！compareTo 要满足自反性、对称性和传递性！</p><p>注意，比较整数基本类型域可使用关系操作符&lt;和&gt;，浮点域可使用 Double.compare 或者 Float.compare！</p><p>通常在 compareTo 中为了简化代码，会以两数作差表示比较大小的结果，这种方法有风险！记住！一个有符号的 32 位的整数还没有大到足以表达任意两个32位整数的差！如一个很大的正整数减去一个很大负整数将会溢出，并返回一个负值，导致错误结果！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建和销毁对象</title>
      <link href="/2020/07/24/Effective%20java/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/07/24/Effective%20java/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="第-1-条-：-考虑使用静态工厂方法替代构造方法"><a href="#第-1-条-：-考虑使用静态工厂方法替代构造方法" class="headerlink" title="第 1 条 ： 考虑使用静态工厂方法替代构造方法"></a>第 1 条 ： 考虑使用静态工厂方法替代构造方法</h3><p>静态工厂方法实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态工厂方法的优点：</p><ul><li>有方法名，比构造方法更加容易理解</li><li>不用重复创建新对象</li><li>可以返回子类型</li><li>返回对象的类可以根据输入参数的不同而不同</li><li>静态方法更适于做服务型接口</li></ul><p>静态工厂方法的缺点：</p><ul><li>可能无法被子类实例化（私有的构造器）</li><li>不利于检索（比较难找到对应代码）</li></ul><h3 id="第2条：当构造方法参数过多时使用-builder-模式"><a href="#第2条：当构造方法参数过多时使用-builder-模式" class="headerlink" title="第2条：当构造方法参数过多时使用 builder 模式"></a>第2条：当构造方法参数过多时使用 builder 模式</h3><p>可选参数比较多时，可用下面几种方法</p><ol><li>可伸缩构造方法模式，但是当有很多参数时，很难编写，并读懂它。</li><li>使用javaBean模式，通过setter方法设置参数，但构造变得困难，而且变得不安全</li><li>Builder模式，不直接生成对象，而是先得到builder对象，通过builder的类似setter方法设置参数，最后调用build方法生成不可变对象</li></ol><p>缺点：Builder 模式比重叠构造器更冗长，只在参数很多的时候才使用，比如四个或者更多。</p><p>Builder方法实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123; </span><br><span class="line">        <span class="comment">// Required parameters </span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values </span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sodium= <span class="number">0</span>; = <span class="number">0</span>; = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize; </span><br><span class="line">            <span class="keyword">this</span>.servings = servings; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">            calories = val; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">            fat = val; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">            sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            carbohydrate = val; <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123; </span><br><span class="line">        servingSize = builder.servingSize; </span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第3条：使用私有构造方法或枚举类实现-Singleton-属-性"><a href="#第3条：使用私有构造方法或枚举类实现-Singleton-属-性" class="headerlink" title="第3条：使用私有构造方法或枚举类实现 Singleton 属 性"></a>第3条：使用私有构造方法或枚举类实现 Singleton 属 性</h3><p>Java 1.5 之前，实现单例是通过“构造器私有化，静态公有 final 实例对象”，或直接获取，或通过方法获取。</p><p>Java 1.5 之后，实现单例的最佳方法，是编写“单元素的枚举”类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无偿提供序列化，防止多次实例化。</p><h3 id="第4条：使用私有构造器执行非实例化"><a href="#第4条：使用私有构造器执行非实例化" class="headerlink" title="第4条：使用私有构造器执行非实例化"></a>第4条：使用私有构造器执行非实例化</h3><p>一些工具类不希望被实例化，将构造函数私有，避免外部调用，并在构造函数中抛异常，避免内部调用。</p><h3 id="第5条：依赖注入优于硬连接资源（hardwiring-resources）"><a href="#第5条：依赖注入优于硬连接资源（hardwiring-resources）" class="headerlink" title="第5条：依赖注入优于硬连接资源（hardwiring resources）"></a>第5条：依赖注入优于硬连接资源（hardwiring resources）</h3><p>行为参数化是依赖注入的有用变体，将<code>Lexicon dictionary</code>作为参数，相对硬编码更加灵活。</p><p>对于行为参数化的类，可以通过策略模式和lambda表达式灵活实现</p><h3 id="第6条：避免创建不必要的对象"><a href="#第6条：避免创建不必要的对象" class="headerlink" title="第6条：避免创建不必要的对象"></a>第6条：避免创建不必要的对象</h3><p>最好能重用对象而不是在每次需要的时候就创建一个相同功能的新对象。如果对象是不可变的，它就始终可以被重用。</p><p>优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱，比如：下面这个程序会有大量装箱成Long</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long sum = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">sum += i;</span><br></pre></td></tr></table></figure><p>使用 Byte.valueOf 来创建包装类型，因为 -128~127 的数会缓存起来，要从缓冲池中取，Short、Integer、Long 也是这样。 </p><h3 id="第-7-条：消除过期的对象引用"><a href="#第-7-条：消除过期的对象引用" class="headerlink" title="第 7 条：消除过期的对象引用"></a>第 7 条：消除过期的对象引用</h3><p>不需要对所有对象显式置空，以下情形考虑资源手工处理：</p><ul><li>类是自己管理内存，如例子中的 Stack 类。</li><li>使用对象缓存机制时，需要考虑被从缓存中换出的对象，或是长期不会被访问到的对象。</li><li>事件监听器和相关回调。使用弱引用</li></ul><h3 id="第-8-条：避免使用终结方法"><a href="#第-8-条：避免使用终结方法" class="headerlink" title="第 8 条：避免使用终结方法"></a>第 8 条：避免使用终结方法</h3><p>finalizer 不保证会被及时的执行，甚至不一定执行。</p><p>除非是作为安全网，或者为终止非关键的本地资源，否则请不要使用终结方法。</p><h3 id="第-9-条-用-try-with-resources-代替-try-finally"><a href="#第-9-条-用-try-with-resources-代替-try-finally" class="headerlink" title="第 9 条: 用 try-with-resources 代替 try-finally"></a>第 9 条: 用 try-with-resources 代替 try-finally</h3><p>实现 AutoCloseable 接口的类应使用 try-with-resources，因其可同时处理多个资源，不用嵌套</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> effective java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effectivejava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC</title>
      <link href="/2020/07/22/Spring/Web/Spring%20MVC/"/>
      <url>/2020/07/22/Spring/Web/Spring%20MVC/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring-MVC-概览"><a href="#1-Spring-MVC-概览" class="headerlink" title="1 Spring MVC 概览"></a>1 Spring MVC 概览</h3><p>Spring 提供了一个功能齐全的 MVC 框架用于构建 Web 应用程序。Spring 框架可以很容易的和其他的 MVC 框架融合(如 Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。</p><ul><li>DispatcherServlet<ul><li>Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。</li></ul></li><li>WebApplicationContext<ul><li>WebApplicationContext 继承了 ApplicationContext，并添加了一些 web 应用程序需要的功能。和普通的 ApplicationContext 不同，WebApplicationContext 可以用来处理主题样式，它也知道如何找到相应的 servlet。</li></ul></li><li>Controller<ul><li>控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。</li><li>@Controller 注解表示该类扮演控制器的角色。Spring 不需要继承任何控制器基类或应用 Servlet API。</li></ul></li><li>@RequestMapping 注解用于将 URL 映射到任何一个类或者一个特定的处理方法上。</li></ul><h4 id="1-1-Spring-MVC-运行原理"><a href="#1-1-Spring-MVC-运行原理" class="headerlink" title="1.1 Spring MVC 运行原理"></a>1.1 Spring MVC 运行原理</h4><p><img src="https://imine141.github.io/images/1545011851570.png" alt="img"></p><ol><li>Spring MVC 通过一个单独的前端控制器（DispatcherServlet）过滤分发请求。</li><li>DispatcherServlet 根据处理器映射（HandlerMapping）和请求携带的 URL 决定将请求发送给某个控制器（Controller）。</li><li>控制器从请求中取得信息，然后委托业务逻辑组件处理。将处理结果打包在模型（model）中，然后指定一个视图（view）的逻辑名称，然后将请求和模型、视图名称一起发送回 DispatcherServlet。</li><li>DispatcherServlet 用视图名称查找对应的视图解析器（ViewResolver），负责将逻辑名称转换成对应的页面实现。</li><li>最后一步就是视图的实现。视图会使用模型数据填充到视图实现中，然后将结果放在 HTTP 响应对象中。</li></ol><h4 id="1-2-Spring-MVC-配置"><a href="#1-2-Spring-MVC-配置" class="headerlink" title="1.2 Spring MVC 配置"></a>1.2 Spring MVC 配置</h4><h5 id="1）配置前端控制器"><a href="#1）配置前端控制器" class="headerlink" title="1）配置前端控制器"></a>1）配置前端控制器</h5><p>继承了 AbstractAnnotationConfigDispatcherServletInitializer，会在项目运行初始化被自动发现并加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 根容器</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123; </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; RootConfig<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Spring mvc 容器，指定配置类</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123; </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; WebConfig<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// DispatcherServlet 映射,从"/"开始</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> String[] getServletMappings() &#123; </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppInitializer 类需要实现三个方法，RootConfig 和 WebConfig 是两个关键配置类，而 getServletMappings 只需要返回一个 String 的列表，{“/”}的意思是监听访问 url 下所有的请求。</p><h5 id="2）配置视图解析器"><a href="#2）配置视图解析器" class="headerlink" title="2）配置视图解析器"></a>2）配置视图解析器</h5><p>@EnableWebMvc：启动 Spring MVC 特性<br>configer.enable()：静态资源的请求将转交给 servlert 容器的 default servlet 处理。</p><ul><li>setPrefix() 方法用于设置视图路径的前缀；</li><li>setSuffix() 用于设置视图路径的后缀；</li><li>setExposeContextBeansAsAttributes(true) 使得可以在 JSP 页面中通过 ${ } 访问容器中的 bean</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span><span class="comment">//启动Spring MVC</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"org.test.spittr.web"</span>)<span class="comment">//启动组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123; </span><br><span class="line">             <span class="comment">// 配置JSP视图解析器</span></span><br><span class="line">             InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">             resolver.setPrefix(<span class="string">"/WEB-INF/views/"</span>);</span><br><span class="line">             resolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">             <span class="comment">// 可以在JSP页面中通过$&#123;&#125;访问beans</span></span><br><span class="line">             resolver.setExposeContextBeansAsAttributes(<span class="keyword">true</span>);</span><br><span class="line">             <span class="keyword">return</span> resolver;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable(); <span class="comment">//配置静态文件处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）配置-Bean"><a href="#3）配置-Bean" class="headerlink" title="3）配置 Bean"></a>3）配置 Bean</h5><p>RootConfig 在设置扫描机制的时候，将之前 WebConfig 设置过的那个包排除了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123; <span class="string">"org.test.spittr.controller"</span> &#125;, excludeFilters = &#123;</span><br><span class="line">             <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RootConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-编写-Controller"><a href="#2-编写-Controller" class="headerlink" title="2 编写 Controller"></a>2 编写 Controller</h3><h4 id="2-1-控制器类"><a href="#2-1-控制器类" class="headerlink" title="2.1 控制器类"></a>2.1 控制器类</h4><p>控制器类就是含有被 @RequestMapping 注解修饰的方法的类。@Controller 是 @Component 的别名，返回一个视图逻辑名称。</p><p>@RequestMapping 可加在类上和方法上，可同时映射多个路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(value = &#123; <span class="string">"/"</span>, <span class="string">"/homepage"</span> &#125;, method = RequestMethod.GET)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-请求参数"><a href="#2-2-请求参数" class="headerlink" title="2.2 请求参数"></a>2.2 请求参数</h4><p>Spring MVC 提供了三种方式，可以让客户端给控制器的 handler 传入参数：</p><h5 id="1）查询参数"><a href="#1）查询参数" class="headerlink" title="1）查询参数"></a>1）查询参数</h5><p>@RequestParam，可设默认和非必填</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">spittles</span><span class="params">(@RequestParam(<span class="string">"max"</span>)</span> <span class="keyword">long</span> max, </span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"count"</span>, defaultValue = <span class="string">"20"</span>)</span> <span class="keyword">int</span> count) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> spittleRepository.findSpittles(max, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）表单参数"><a href="#2）表单参数" class="headerlink" title="2）表单参数"></a>2）表单参数</h5><ul><li>“redirect:”前缀：解析为重定向的规则， 而不是视图的名称。</li><li>“forward:”前缀：请求将会前往（forward） 指定的 URL 路径， 而不再是重定向。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/register"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/spitter/"</span> + spitter.getUsername();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）路径参数"><a href="#3）路径参数" class="headerlink" title="3）路径参数"></a>3）路径参数</h5><p>@PathVariable，如果函数参数和占位符名称相同，可省略注解的参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"abc/&#123;spittleId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showSpittle</span><span class="params">(@PathVariable(<span class="string">"spittleId"</span>)</span> <span class="keyword">long</span> spittleId,Model model) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-校验参数"><a href="#2-3-校验参数" class="headerlink" title="2.3 校验参数"></a>2.3 校验参数</h4><p>Java Validation API 定义了多个注解， 这些注解可以放到属性上，从而限制这些属性的值。</p><table><thead><tr><th>注 解</th><th>描 述</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>所注解的元素必须是 Boolean 类型， 并且值为 false</td></tr><tr><td>@AssertTrue</td><td>所注解的元素必须是 Boolean 类型， 并且值为 true</td></tr><tr><td>@DecimalMax</td><td>所注解的元素必须是数字， 并且它的值要小于或等于给定的 BigDecimalString 值</td></tr><tr><td>@DecimalMin</td><td>所注解的元素必须是数字， 并且它的值要大于或等于给定的 BigDecimalString 值</td></tr><tr><td>@Digits</td><td>所注解的元素必须是数字， 并且它的值必须有指定的位数</td></tr><tr><td>@Future</td><td>所注解的元素的值必须是一个将来的日期</td></tr><tr><td>@Max</td><td>所注解的元素必须是数字， 并且它的值要小于或等于给定的值</td></tr><tr><td>@Min</td><td>所注解的元素必须是数字， 并且它的值要大于或等于给定的值</td></tr><tr><td>@NotNull</td><td>所注解元素的值必须不能为 null</td></tr><tr><td>@Null</td><td>所注解元素的值必须为 null</td></tr><tr><td>@Past</td><td>所注解的元素的值必须是一个已过去的日期</td></tr><tr><td>@Pattern</td><td>所注解的元素的值必须匹配给定的正则表达式</td></tr><tr><td>@Size</td><td>所注解的元素的值必须是 String、 集合或数组， 并且它的长度要符合给定的范围</td></tr></tbody></table><h5 id="校验-bean-对象"><a href="#校验-bean-对象" class="headerlink" title="校验 bean 对象"></a>校验 bean 对象</h5><p>@Valid 注解标注要检验的参数，Errors 参数要紧跟其后面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/register"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(@Valid Spitter spitter, Errors errors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(errors.hasErrors())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/spitter/"</span> + spitter.getUsername();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-其他注解"><a href="#2-4-其他注解" class="headerlink" title="2.4 其他注解"></a>2.4 其他注解</h4><ul><li>@RequestBody：将方法参数直接绑定到 HTTP 请求 Body 上</li><li>@ResponseBody：将返回值作为响应体</li><li>@RestController：避免重复写 @ResponseBody</li><li>@CookieValue</li><li>@RequestHeader</li></ul><p>Spring 4.3 中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝ 来帮助简化常用的 HTTP 方法的映射 并更好地表达被注解方法的语义</p><ul><li>@GetMapping 是一个组合注解：是 @RequestMapping(method = RequestMethod.GET) 的缩写</li><li>@PostMapping 是一个组合注解：是 @RequestMapping(method = RequestMethod.POST) 的缩写</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 进阶</title>
      <link href="/2020/07/21/Spring/Web/Spring%20MVC%20%E8%BF%9B%E9%98%B6/"/>
      <url>/2020/07/21/Spring/Web/Spring%20MVC%20%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-替代配置"><a href="#1-替代配置" class="headerlink" title="1 替代配置"></a>1 替代配置</h3><h4 id="1-1-自定义-DispatcherServlet"><a href="#1-1-自定义-DispatcherServlet" class="headerlink" title="1.1 自定义 DispatcherServlet"></a>1.1 自定义 DispatcherServlet</h4><p>除了三个必须重载的抽象方法，AbstractAnnotationConfigDispatcherServletInitializer 还有很多方法可以重载，以实现额外配置。</p><p>例如，通过对 customizeRegistration() 的重写，就可以对 DispatcherServlet 进行额外的配置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(Dynamic registration)</span> </span>&#123;</span><br><span class="line">    registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(<span class="string">"/tmp/spittr/uploads"</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletRegistration.Dynamic 作为入参，可以做很多事情，比如调用 setLoadOnStartup() 来设置加载时优先级，调用 setInitParameter() 来设置初始化参数，调用 setMultipartConfig() 来设置 Servlet3.0 的多路支持。</p><h4 id="1-2-添加额外的-servlet-和-filter"><a href="#1-2-添加额外的-servlet-和-filter" class="headerlink" title="1.2 添加额外的 servlet 和 filter"></a>1.2 添加额外的 servlet 和 filter</h4><p>实现 WebApplicationInitializer 接口是在注册 servlet、filter、listener 时比较推荐的方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 定义servlet</span></span><br><span class="line">        Dynamic myServlet = servletContext.addServlet(<span class="string">"myServlet"</span>, MyServlet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 映射servlet</span></span><br><span class="line">        myServlet.addMapping(<span class="string">"/custom/**"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册一个filter</span></span><br><span class="line">        javax.servlet.FilterRegistration.Dynamic filter = servletContext.addFilter(<span class="string">"myFilter"</span>, MyFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 添加映射</span></span><br><span class="line">        filter.addMappingForUrlPatterns(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="string">"/custom/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如仅需要注册一个 filter 并将其映射到 DispatcherServlet，重写 AbstractAnnotationConfigDispatcherServletInitializer 的 getServletFilters() 方法是一个捷径。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Filter[] &#123; <span class="keyword">new</span> MyFilter() &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 getServletFilters() 返回的 filter 会自动地映射到 DispatcherServlet。</p><h3 id="2-处理-multipart-表单数据"><a href="#2-处理-multipart-表单数据" class="headerlink" title="2 处理 multipart 表单数据"></a>2 处理 multipart 表单数据</h3><p>Multipart/form-data 将表单分割成独立的部分，每个部分都有各自的类型，可以处理二进制数据</p><h4 id="2-1-配置-multipart-解析器"><a href="#2-1-配置-multipart-解析器" class="headerlink" title="2.1 配置 multipart 解析器"></a>2.1 配置 multipart 解析器</h4><p>Spring 提供了两种 MultipartResolver 实现类：</p><ul><li>CommonsMultipartResolver：使用 Jakarta Commons FileUpload 来解析 multipart 请求；</li><li>StandardServletMultipartResolver：依靠 Servlet 3.0 支持来解析（Spring 3.1及以上）；</li></ul><p>推荐 StandardServletMultipartResolver，它使用 servlet 容器中现有的支持，并且不需要其他附加的项目依赖。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardServletMultipartResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置-multipart-详情"><a href="#配置-multipart-详情" class="headerlink" title="配置 multipart 详情"></a>配置 multipart 详情</h5><p>MultipartConfigElement</p><ol><li>继承自 WebMvcConfigurerAdapter 的 servlet 初始化类中配置的 DispatcherServlet，在 servlet 注册时通过调用 setMultipartConfig() 方法来配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DispatcherServlet ds = <span class="keyword">new</span> DispatcherServlet();</span><br><span class="line">Dynamic registration = context.addServlet(<span class="string">"appServlet"</span>, ds);</span><br><span class="line">registration.addMapping(<span class="string">"/"</span>);</span><br><span class="line">registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(<span class="string">"/tmp/spittr/uploads"</span>));</span><br></pre></td></tr></table></figure><ol><li>继承自 AbstractAnnotationConfigDispatcherServletInitializer 的 servlet 初始化类，重写 customizeRegistration() 方法来进行配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(Dynamic registration)</span> </span>&#123;</span><br><span class="line">    registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(<span class="string">"/tmp/spittr/uploads"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-处理-multipart-请求"><a href="#2-2-处理-multipart-请求" class="headerlink" title="2.2 处理 multipart 请求"></a>2.2 处理 multipart 请求</h4><h5 id="1）表单"><a href="#1）表单" class="headerlink" title="1）表单"></a>1）表单</h5><p><code>标签 enctype=“multipart/form-data” 属性</code>type=“file”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;POST&quot; th:object&#x3D;&quot;$&#123;spitter&#125;&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;profilePicture&quot; accept&#x3D;&quot;image&#x2F;jpeg,image&#x2F;png,image&#x2F;gif&quot; &#x2F;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="2）controller"><a href="#2）controller" class="headerlink" title="2）controller"></a>2）controller</h5><p>使用 <strong>@RequestPart</strong> 注解 byte 数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(@RequestPart(<span class="string">"profilePicture"</span>)</span> <span class="keyword">byte</span>[] profilePicture, @Valid Spitter spitter,Errors errors) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）接收-MultipartFile"><a href="#3）接收-MultipartFile" class="headerlink" title="3）接收 MultipartFile"></a>3）接收 MultipartFile</h5><p>Spring 提供了 MultipartFile 接口获取富对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(@RequestPart(<span class="string">"profilePicture"</span>)</span> MultipartFile profilePicture, ...) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MultipartFile 提供获取上传文件的方法，同时提供了很多其他方法，比如原始文件名称、大小和内容类型等。另外还提供了一个 InputStream 可以将文件数据作为数据流读取。</p><p>transferTo() 写入到文件系统</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">profilePicture.transferTo(<span class="keyword">new</span> File(<span class="string">"/data/spittr/"</span> + profilePicture.getOriginalFilename()));</span><br></pre></td></tr></table></figure><h5 id="4）接收-Part"><a href="#4）接收-Part" class="headerlink" title="4）接收 Part"></a>4）接收 Part</h5><p>Servlet 3.0 的容器上，可以选择 Part，大多数情况下 Part 接口和 MultipartFile 没什么区别。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/register"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(@RequestPart(<span class="string">"profilePicture"</span>)</span> Part profilePicture, ...) </span>&#123;</span><br></pre></td></tr></table></figure><p>如果使用 Part 作为参数，就不再需要配置 StandardServletMultipartResolverbean，它只需在使用 MultipartFile 时进行配置。</p><h3 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3 异常处理"></a>3 异常处理</h3><p>servlet 请求的输出只能是 servlet 响应。如果请求出现异常，需要将异常转换为 servlet 响应。</p><p>Spring 提供了一些将异常转化为响应的方法：</p><ul><li>某些 Spring 异常会自动的映射为特定的 HTTP 状态码；</li><li>使用<code>@ResponseStatus</code>注解将一个异常映射为 HTTP 状态码；</li><li>使用<code>ExceptionHandler</code>注解的方法可以用来处理异常</li></ul><h4 id="3-1-ResponseStatus"><a href="#3-1-ResponseStatus" class="headerlink" title="3.1 @ResponseStatus"></a>3.1 @ResponseStatus</h4><p>内置映射之外，可用<code>@ResponseStatus</code>注解将一个异常映射为 HTTP 状态码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(value=HttpStatus.NOT_FOUND, reason=<span class="string">"Spittle Not Found"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleNotFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-ExceptionHandler"><a href="#3-2-ExceptionHandler" class="headerlink" title="3.2 @ExceptionHandler"></a>3.2 @ExceptionHandler</h4><p>@ExceptionHandler 注解的方法在有指定异常抛出时执行，在同一个 controller 里通用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(DuplicateSpittleException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">String</span> <span class="title">handleDuplicateSpittle</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error/duplicate"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-ControllerAdvice"><a href="#3-3-ControllerAdvice" class="headerlink" title="3.3 @ControllerAdvice"></a>3.3 @ControllerAdvice</h4><p>控制器增强类，即使用<code>@ControllerAdvice</code>进行注解的类，由以下方法构成：</p><ul><li>@ExceptionHandler 注解的</li><li>@InitBinder 注解的</li><li>@ModelAttribute 注解的</li></ul><p>应用于所有 controller 的所有 @RequestMapping 注解的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(ValidationException exception)</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"bad request, "</span> + exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bad request, "</span> + exception.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;BaseException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;?&gt; <span class="title">handleBaseException</span>(<span class="title">final</span> <span class="title">Exception</span> <span class="title">ex</span>, <span class="title">WebRequest</span> <span class="title">request</span>) </span>&#123;</span><br><span class="line">        BaseException baseEx = (BaseException) ex;</span><br><span class="line">        <span class="keyword">return</span> handleExceptionInternal(ex, ErrorResponse.of(baseEx), <span class="keyword">new</span> HttpHeaders(), baseEx.getHttpStatus(), request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResponseEntity&lt;Object&gt; <span class="title">handleMethodArgumentNotValid</span><span class="params">(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleExceptionInternal(ex, ErrorResponse.of(ex), headers, HttpStatus.BAD_REQUEST, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResponseEntity&lt;Object&gt; <span class="title">handleMissingServletRequestParameter</span><span class="params">(MissingServletRequestParameterException ex, HttpHeaders headers, HttpStatus status, WebRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handleExceptionInternal(ex, <span class="keyword">new</span> ErrorResponse(ex.getMessage(), <span class="string">"missing_request_parameter"</span>), headers, status, request);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_NULL)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorResponse</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String code;</span><br><span class="line">        List&lt;String&gt; errors;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ErrorResponse</span><span class="params">(String message, String code)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.code = code;</span><br><span class="line">            <span class="keyword">this</span>.message = message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ErrorResponse</span><span class="params">(String message, String code, List&lt;String&gt; errors)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.message = message;</span><br><span class="line">            <span class="keyword">this</span>.code = code;</span><br><span class="line">            <span class="keyword">this</span>.errors = errors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorResponse <span class="title">of</span><span class="params">(BaseException ex)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ErrorResponse(ex.getMessage(), ex.getCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorResponse <span class="title">of</span><span class="params">(MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; errors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (FieldError error : ex.getBindingResult().getFieldErrors()) &#123;</span><br><span class="line">                errors.add(error.getField() + <span class="string">": "</span> + error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (ObjectError error : ex.getBindingResult().getGlobalErrors()) &#123;</span><br><span class="line">                errors.add(error.getObjectName() + <span class="string">": "</span> + error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ErrorResponse(<span class="string">"输入不合法"</span>, <span class="string">"bad_request"</span>, errors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorResponse <span class="title">of</span><span class="params">(Map&lt;String, Object&gt; errorAttributes)</span> </span>&#123; <span class="comment">//其他异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ErrorResponse((String) errorAttributes.get(<span class="string">"message"</span>), (String) errorAttributes.get(<span class="string">"error"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getErrors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> errors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> HttpStatus httpStatus = HttpStatus.BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String code = <span class="string">"unknown_error"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InternalServerErrorException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalServerErrorException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        httpStatus = HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">        code = <span class="string">"internal_server_error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalServerErrorException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"系统内部发生未知异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalServerErrorException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalServerErrorException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-跨-redirect-传递数据"><a href="#4-跨-redirect-传递数据" class="headerlink" title="4 跨 redirect 传递数据"></a>4 跨 redirect 传递数据</h3><p>一般的，处理函数结束后，方法中的 model 数据都会作为 request 属性复制到 request 中，并且 request 会传递到视图中进行解析。</p><ul><li>forward 时，使用同一个 request，request 属性保留。</li><li>redirect 时，终止老 request，开启新 request。request 属性清空。</li></ul><p>redirect 时不能使用 model 传递数据了。但是还有其他方法：</p><ul><li>将数据转换为路径参数或者查询参数</li><li>在 flash 属性中发送数据</li></ul><h4 id="4-1-使用-URL-模版重定向"><a href="#4-1-使用-URL-模版重定向" class="headerlink" title="4.1 使用 URL 模版重定向"></a>4.1 使用 URL 模版重定向</h4><p>使用路径参数和查询参数传递简单数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(Spitter spitter, Model model)</span> </span>&#123;</span><br><span class="line">    spitterRepository.save(spitter);</span><br><span class="line">    model.addAttribute(<span class="string">"username"</span>, spitter.getUsername());</span><br><span class="line">    model.addAttribute(<span class="string">"spitterId"</span>, spitter.getId());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/spitter/&#123;username&#125;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>username 作为路径参数，spitterId 转为查询参数</p><h4 id="4-2-使用-flash-属性"><a href="#4-2-使用-flash-属性" class="headerlink" title="4.2 使用 flash 属性"></a>4.2 使用 flash 属性</h4><p>Spring 通过 Model 的子接口 RedirectAttributes 设置 flash 属性。</p><p>重定向前，所有的 flash 属性都会拷贝到 session 中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(Spitter spitter, RedirectAttributes model)</span> </span>&#123;</span><br><span class="line">    spitterRepository.save(spitter);</span><br><span class="line">    model.addAttribute(<span class="string">"username"</span>, spitter.getUsername());</span><br><span class="line">    model.addFlashAttribute(<span class="string">"spitter"</span>, spitter);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/spitter/&#123;username&#125;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重定向后，存储在 session 中的 flash 属性会从 session 中移出到 model 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showSpitterProfile</span><span class="params">(@PathVariable(<span class="string">"username"</span>)</span> String username, Model model) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!model.containsAttribute(<span class="string">"spitter"</span>)) &#123;</span><br><span class="line">        Spitter spitter = spitterRepository.findByUsername(username);</span><br><span class="line">        model.addAttribute(spitter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"profile"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2020/07/21/Spring/Web/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2020/07/21/Spring/Web/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>常用的跨域解决方案有 JSONP 和 CORS， spingboot 2.0 开始不推荐使用 JSONP。</p><h2 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1 CORS"></a>1 CORS</h2><h3 id="1-1-属性含义"><a href="#1-1-属性含义" class="headerlink" title="1.1 属性含义"></a>1.1 属性含义</h3><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>value</td><td>指定所支持域的集合， 表示所有域都支持，默认值为 。这些值对应于 HTTP 请求头中的 Access-Control-Allow-Origin</td></tr><tr><td>origins</td><td>@AliasFor(“value”)，与 value 属性一样</td></tr><tr><td>allowedHeaders</td><td>允许请求头中的 headers，在预检请求 Access-Control-Allow-Headers 响应头中展示</td></tr><tr><td>exposedHeaders</td><td>响应头中允许访问的 headers，在实际请求的 Access-Control-Expose-Headers</td></tr><tr><td>methods</td><td>支持的 HTTP 请求方法列表，默认和 Controller 中的方法上标注的一致。</td></tr><tr><td>allowCredentials</td><td>表示浏览器在跨域请求中是否携带凭证，比如 cookies。在预检请求的 Access-Control-Allow-Credentials</td></tr><tr><td>maxAge</td><td>预检请求响应的最大缓存时间，单位为秒。在预检请求的 Access-Control-Max-Age 响应头中展示</td></tr></tbody></table><h3 id="1-2-实现方法"><a href="#1-2-实现方法" class="headerlink" title="1.2 实现方法"></a>1.2 实现方法</h3><h4 id="1）-CrossOrigin-注解"><a href="#1）-CrossOrigin-注解" class="headerlink" title="1） CrossOrigin 注解"></a>1） CrossOrigin 注解</h4><p>在 Spring Boot 中为我们提供了一个注解 @CrossOrigin 来实现跨域，这个注解可以加在类或者方法上。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/xxx"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@CrossOrigin</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"xxx"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）实现-WebMvcConfigurer-接口"><a href="#2）实现-WebMvcConfigurer-接口" class="headerlink" title="2）实现 WebMvcConfigurer 接口"></a>2）实现 WebMvcConfigurer 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">168000</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）过滤器"><a href="#3）过滤器" class="headerlink" title="3）过滤器"></a>3）过滤器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> CorsFilter(source));</span><br><span class="line">        bean.setOrder(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Jsonp"><a href="#2-Jsonp" class="headerlink" title="2 Jsonp"></a>2 Jsonp</h2><blockquote><p>spingboot2.0 已不支持 JSONP</p></blockquote><p>通过 jsonp 调用，对格式重新封装，解决前端跨域。<br>如：请求<code>http://xxxx?&amp;callback=exec</code>, 那么返回的jsonp格式为<code>exec({&quot;code&quot;:0, &quot;message&quot;:&quot;success&quot;});</code>。</p><p>继承<code>AbstractJsonpResponseBodyAdvice</code>，加入<code>@ControllerAdvice</code>注解,basePackages 标识要被处理的 controller。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(basePackages = <span class="string">"xxx.controller"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonpAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractJsonpResponseBodyAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] jsonpQueryParamNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonpAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"callback"</span>, <span class="string">"jsonp"</span>);</span><br><span class="line">        <span class="keyword">this</span>.jsonpQueryParamNames = <span class="keyword">new</span> String[]&#123;<span class="string">"callback"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeBodyWriteInternal</span><span class="params">(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();</span><br><span class="line">　　　　　</span><br><span class="line">　　　　<span class="comment">//如果不存在callback这个请求参数，直接返回，不需要处理为jsonp</span></span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(servletRequest.getParameter(<span class="string">"callback"</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">　　　　<span class="comment">//按设定的请求参数处理返回结果为jsonp格式</span></span><br><span class="line">        <span class="keyword">for</span> (String name : <span class="keyword">this</span>.jsonpQueryParamNames) &#123;</span><br><span class="line">            String value = servletRequest.getParameter(name);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                MediaType contentTypeToUse = getContentType(contentType, request, response);</span><br><span class="line">                response.getHeaders().setContentType(contentTypeToUse);</span><br><span class="line">                bodyContainer.setJsonpFunction(value);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring RestTemplate</title>
      <link href="/2020/07/21/Spring/Web/Spring%20RestTemplate/"/>
      <url>/2020/07/21/Spring/Web/Spring%20RestTemplate/</url>
      
        <content type="html"><![CDATA[<p>RestTemplate 属于 Spring-Web，是 Spring 的同步客户端HTTP访问的中心类。简化了与 HTTP 服务器的通信，并应用了 RESTful 原则。</p><p>RestTemplate 默认依赖 JDK 的 HttpURLConnection 来建立 HTTP 连接。 可切换到使用不同的 HTTP 库，例如 Apache HttpComponents，Netty 和 OkHttp。</p><h3 id="1-组成"><a href="#1-组成" class="headerlink" title="1 组成"></a>1 组成</h3><p>RestTemplate 包含以下几个部分：</p><ul><li>HttpMessageConverter：对象转换器</li><li>ClientHttpRequestFactory：客户端连接器，默认是 JDK 的 HttpURLConnection</li><li>ResponseErrorHandler：异常处理</li><li>ClientHttpRequestInterceptor：请求拦截器</li></ul><p><img src="https://imine141.github.io/images/1545011851872.png" alt="img"></p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><p>初始化时，可以传入 ClientHttpRequestFactory，自定义参数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RestTemplate restTemplate()&#123;</span><br><span class="line">    SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">    &#x2F;&#x2F;设置超时时间</span><br><span class="line">    requestFactory.setConnectTimeout(1000);</span><br><span class="line">    requestFactory.setReadTimeout(1000);</span><br><span class="line">    RestTemplate restTemplate &#x3D; new RestTemplate(requestFactory);</span><br><span class="line">    return restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;</span><br></pre></td></tr></table></figure><h3 id="3-访问服务"><a href="#3-访问服务" class="headerlink" title="3 访问服务"></a>3 访问服务</h3><h4 id="3-1-HTTP-方法"><a href="#3-1-HTTP-方法" class="headerlink" title="3.1 HTTP 方法"></a>3.1 HTTP 方法</h4><p>使用 java.net.URI 代替 String 形式的 URI，不会被 URL 编码两次<br>以 get 和 post 为例，更多见 <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener">官网api</a></p><h5 id="1）GET"><a href="#1）GET" class="headerlink" title="1）GET"></a>1）GET</h5><ul><li>getForObject()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables)</span></span></span><br></pre></td></tr></table></figure><ul><li>getForEntity()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(URI url,Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url,Class&lt;T&gt; responseType,Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url,Class&lt;T&gt; responseType,Map&lt;String,?&gt; uriVariables)</span></span></span><br></pre></td></tr></table></figure><h5 id="2）POST"><a href="#2）POST" class="headerlink" title="2）POST"></a>2）POST</h5><ul><li>postForObject()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(URI url,Object request,Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">postForObject</span><span class="params">(String url,Object request,Class&lt;T&gt; responseType,Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">postForObject</span><span class="params">(String url,Object request,Class&lt;T&gt; responseType,Map&lt;String,?&gt; uriVariables)</span></span></span><br></pre></td></tr></table></figure><ul><li>postForEntity()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url,@NullableObject request,Class&lt;T&gt; responseType,Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url,Object request,Class&lt;T&gt; responseType,Map&lt;String,?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(URI url,Object request,Class&lt;T&gt; responseType)</span></span></span><br></pre></td></tr></table></figure><h5 id="3）实例"><a href="#3）实例" class="headerlink" title="3）实例"></a>3）实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.add(<span class="string">"X-Auth-Token"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, String&gt; postParameters = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">postParameters.add(<span class="string">"parameter1"</span>, <span class="string">"111"</span>);</span><br><span class="line">postParameters.add(<span class="string">"parameter2"</span>, <span class="string">"222"</span>);</span><br><span class="line">postParameters.add(<span class="string">"parameter3"</span>, <span class="string">"333"</span>);</span><br><span class="line"></span><br><span class="line">HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = <span class="keyword">new</span> HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(postParameters, headers);</span><br><span class="line"></span><br><span class="line">Object result = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = restTemplate.postForObject(<span class="string">"http://demo"</span>, requestEntity, ParseResultVo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RestClientException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4 异常处理"></a>4 异常处理</h3><h5 id="1）捕获-HttpServerErrorException"><a href="#1）捕获-HttpServerErrorException" class="headerlink" title="1）捕获 HttpServerErrorException"></a>1）捕获 HttpServerErrorException</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retryCount = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        responseEntity = restTemplate.exchange(requestEntity, String<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HttpServerErrorException e) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (retryCount == <span class="number">3</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125;  </span><br><span class="line">        retryCount++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）自定义异常处理"><a href="#2）自定义异常处理" class="headerlink" title="2）自定义异常处理"></a>2）自定义异常处理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomErrorHandler</span> <span class="keyword">extends</span> <span class="title">DefaultResponseErrorHandler</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasError</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(ClientHttpResponse response, HttpStatus statusCode)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(statusCode.isError())&#123;</span><br><span class="line">            <span class="keyword">switch</span> (statusCode.series()) &#123;</span><br><span class="line">                <span class="keyword">case</span> CLIENT_ERROR:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HttpClientErrorException(statusCode, response.getStatusText(), response.getHeaders(), <span class="keyword">this</span>.getResponseBody(response), <span class="keyword">this</span>.getCharset(response));</span><br><span class="line">                <span class="keyword">case</span> SERVER_ERROR:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HttpServerErrorException(statusCode, response.getStatusText(), response.getHeaders(), <span class="keyword">this</span>.getResponseBody(response), <span class="keyword">this</span>.getCharset(response));</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnknownHttpStatusCodeException(statusCode.value(), response.getStatusText(), response.getHeaders(), <span class="keyword">this</span>.getResponseBody(response), <span class="keyword">this</span>.getCharset(response));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientConfig</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();  </span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> CustomErrorHandler());  </span><br><span class="line">        <span class="keyword">return</span> restTemplate;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-设置连接池"><a href="#5-设置连接池" class="headerlink" title="5 设置连接池"></a>5 设置连接池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientConfig</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">httpRequestFactory</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient());  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate(httpRequestFactory());  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClient <span class="title">httpClient</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder.&lt;ConnectionSocketFactory&gt; create()  </span><br><span class="line">        .register(<span class="string">"http"</span>, PlainConnectionSocketFactory.getSocketFactory())  </span><br><span class="line">        .register(<span class="string">"https"</span>, SSLConnectionSocketFactory.getSocketFactory())  </span><br><span class="line">        .build();  </span><br><span class="line">    PoolingHttpClientConnectionManager connectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager(registry);  </span><br><span class="line">    connectionManager.setMaxTotal(<span class="number">200</span>);  </span><br><span class="line">    connectionManager.setDefaultMaxPerRoute(<span class="number">20</span>);  </span><br><span class="line">  </span><br><span class="line">    RequestConfig requestConfig = RequestConfig.custom()  </span><br><span class="line">        .setSocketTimeout(<span class="number">8000</span>)  </span><br><span class="line">        .setConnectTimeout(<span class="number">8000</span>)  </span><br><span class="line">        .setConnectionRequestTimeout(<span class="number">8000</span>)  </span><br><span class="line">        .build();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> HttpClientBuilder.create()  </span><br><span class="line">        .setDefaultRequestConfig(requestConfig)  </span><br><span class="line">        .setConnectionManager(connectionManager)  </span><br><span class="line">        .setConnectionManagerShared(<span class="keyword">true</span>)<span class="comment">//设置共享连接池</span></span><br><span class="line">        .build();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-处理文件"><a href="#6-处理文件" class="headerlink" title="6 处理文件"></a>6 处理文件</h3><h4 id="6-1-发送文件"><a href="#6-1-发送文件" class="headerlink" title="6.1 发送文件"></a>6.1 发送文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MultiValueMap&lt;String, Object&gt; multiPartBody = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();  </span><br><span class="line">multiPartBody.add(<span class="string">"file"</span>, <span class="keyword">new</span> ClassPathResource(<span class="string">"/tmp/user.txt"</span>));  </span><br><span class="line">RequestEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = RequestEntity  </span><br><span class="line">        .post(uri)  </span><br><span class="line">        .contentType(MediaType.MULTIPART_FORM_DATA)  </span><br><span class="line">        .body(multiPartBody);</span><br></pre></td></tr></table></figure><h4 id="6-2-下载文件"><a href="#6-2-下载文件" class="headerlink" title="6.2 下载文件"></a>6.2 下载文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小文件  </span></span><br><span class="line">RequestEntity requestEntity = RequestEntity.get(uri).build();  </span><br><span class="line">ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; responseEntity = restTemplate.exchange(requestEntity, <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line"><span class="keyword">byte</span>[] downloadContent = responseEntity.getBody();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 大文件  </span></span><br><span class="line">ResponseExtractor&lt;ResponseEntity&lt;File&gt;&gt; responseExtractor = <span class="keyword">new</span> ResponseExtractor&lt;ResponseEntity&lt;File&gt;&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;File&gt; <span class="title">extractData</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        File rcvFile = File.createTempFile(<span class="string">"rcvFile"</span>, <span class="string">"zip"</span>);  </span><br><span class="line">        FileCopyUtils.copy(response.getBody(), <span class="keyword">new</span> FileOutputStream(rcvFile));  </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(response.getStatusCode()).headers(response.getHeaders()).body(rcvFile);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">File getFile = <span class="keyword">this</span>.restTemplate.execute(targetUri, HttpMethod.GET, <span class="keyword">null</span>, responseExtractor);</span><br></pre></td></tr></table></figure><h3 id="7-Spring-Boot"><a href="#7-Spring-Boot" class="headerlink" title="7 Spring Boot"></a>7 Spring Boot</h3><p>RestTemplateBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRestTemplateCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> RestTemplateBuilder()  </span><br><span class="line">                .detectRequestFactory(<span class="keyword">false</span>)  </span><br><span class="line">                .basicAuthorization(<span class="string">"username"</span>, <span class="string">"password"</span>)  </span><br><span class="line">                .uriTemplateHandler(<span class="keyword">new</span> OkHttp3ClientHttpRequestFactory())  </span><br><span class="line">                .errorHandler(<span class="keyword">new</span> CustomResponseErrorHandler())  </span><br><span class="line">                .configure(restTemplate);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestClientService</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRestClientService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder  </span><br><span class="line">            .basicAuthorization(<span class="string">"username"</span>, <span class="string">"password"</span>)  </span><br><span class="line">            .setConnectTimeout(<span class="number">3000</span>)  </span><br><span class="line">            .setReadTimeout(<span class="number">5000</span>)  </span><br><span class="line">            .rootUri(<span class="string">"http://api.example.com/"</span>)  </span><br><span class="line">            .errorHandler(<span class="keyword">new</span> CustomResponseErrorHandler())  </span><br><span class="line">            .additionalMessageConverters(<span class="keyword">new</span> CustomHttpMessageConverter())  </span><br><span class="line">            .uriTemplateHandler(<span class="keyword">new</span> OkHttp3ClientHttpRequestFactory())  </span><br><span class="line">            .build();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">site</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://rensanning.iteye.com/"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-参数设置"><a href="#8-参数设置" class="headerlink" title="8 参数设置"></a>8 参数设置</h3><h4 id="8-1-指定转换器"><a href="#8-1-指定转换器" class="headerlink" title="8.1 指定转换器"></a>8.1 指定转换器</h4><p>RestTemplate 默认注册了一组 HttpMessageConverter 用来处理一些不同的 contentType 的请求。</p><p>StringHttpMessageConverter 来处理 text/plain;</p><p>MappingJackson2HttpMessageConverter 来处理 application/json;</p><p>MappingJackson2XmlHttpMessageConverter 来处理 application/xml。</p><p>可实现 org.springframework.http.converter.HttpMessageConverter 接口自己写一个转换器。</p><p>替换例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取RestTemplate默认配置好的所有转换器</span></span><br><span class="line">List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的MappingJackson2HttpMessageConverter在第7个 先把它移除掉</span></span><br><span class="line">messageConverters.remove(<span class="number">6</span>); </span><br><span class="line"><span class="comment">//添加上GSON的转换器</span></span><br><span class="line">messageConverters.add(<span class="number">6</span>, <span class="keyword">new</span> GsonHttpMessageConverter());</span><br></pre></td></tr></table></figure><h4 id="8-2-设置底层连接方式"><a href="#8-2-设置底层连接方式" class="headerlink" title="8.2 设置底层连接方式"></a>8.2 设置底层连接方式</h4><p>通过构造参数设置，以切换 HttpClient 为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成一个设置了连接超时时间、请求超时时间、异常最大重试次数的 httpClient</span></span><br><span class="line">RequestConfig config = RequestConfig.custom().setConnectionRequestTimeout(<span class="number">10000</span>).setConnectTimeout(<span class="number">10000</span>).setSocketTimeout(<span class="number">30000</span>).build();</span><br><span class="line"></span><br><span class="line">HttpClientBuilder builder = HttpClientBuilder.create().setDefaultRequestConfig(config).setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler(<span class="number">5</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">HttpClient httpClient = builder.build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用httpClient创建一个 ClientHttpRequestFactory 的实现</span></span><br><span class="line">ClientHttpRequestFactory requestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClientHttpRequestFactory作为参数构造一个使用作为底层的 RestTemplate</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(requestFactory);</span><br></pre></td></tr></table></figure><h4 id="8-3-设置拦截器"><a href="#8-3-设置拦截器" class="headerlink" title="8.3 设置拦截器"></a>8.3 设置拦截器</h4><p>拦截器需要我们实现 org.springframework.http.client.ClientHttpRequestInterceptor 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span></span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(HttpRequest request, <span class="keyword">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        String checkTokenUrl = request.getURI().getPath(); </span><br><span class="line">        <span class="comment">//请求方法名 POST、GET等</span></span><br><span class="line">        String methodName = request.getMethod().name(); </span><br><span class="line">        <span class="comment">//请求内容</span></span><br><span class="line">        String requestBody = <span class="keyword">new</span> String(body); </span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">        <span class="keyword">return</span> execution.execute(request, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 RestTemplate 实例的时候，添加拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向restTemplate中添加自定义的拦截器</span></span><br><span class="line">restTemplate.getInterceptors().add(<span class="keyword">new</span> TokenInterceptor());</span><br></pre></td></tr></table></figure><h4 id="8-4-使用-Proxy"><a href="#8-4-使用-Proxy" class="headerlink" title="8.4 使用 Proxy"></a>8.4 使用 Proxy</h4><h5 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SimpleClientHttpRequestFactory requestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">    Proxy proxy = <span class="keyword">new</span> Proxy(Proxy.Type.HTTP, <span class="keyword">new</span> InetSocketAddress(<span class="string">"your.proxy.server"</span>, <span class="number">8080</span>));</span><br><span class="line">    requestFactory.setProxy(proxy);</span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(requestFactory);</span><br><span class="line">    <span class="keyword">return</span> restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="System-properties"><a href="#System-properties" class="headerlink" title="System properties"></a>System properties</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = System.getProperties();</span><br><span class="line">props.put(<span class="string">"https.proxyHost"</span>, <span class="string">"your.proxy.server"</span>);</span><br><span class="line">props.put(<span class="string">"https.proxyPort"</span>, <span class="string">"8080"</span>);</span><br><span class="line">props.put(<span class="string">"http.proxyHost"</span>, <span class="string">"your.proxy.server"</span>);</span><br><span class="line">props.put(<span class="string">"http.proxyPort"</span>, <span class="string">"8080"</span>);</span><br><span class="line"></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">String tt = restTemplate.getForObject(<span class="string">"https://baike.baidu.com/"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(tt);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ehcache 3.8 简单持久化</title>
      <link href="/2020/07/20/Spring/Data/Ehcache%203.8%20%E7%AE%80%E5%8D%95%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2020/07/20/Spring/Data/Ehcache%203.8%20%E7%AE%80%E5%8D%95%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1 引入依赖"></a>1 引入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.ehcache&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ehcache&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-持久化配置"><a href="#2-持久化配置" class="headerlink" title="2 持久化配置"></a>2 持久化配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhcacheHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CacheManager <span class="title">getCacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isAvailable())&#123;</span><br><span class="line">            cacheManager = CacheManagerBuilder.newCacheManagerBuilder()</span><br><span class="line">                    .with(CacheManagerBuilder.persistence(<span class="keyword">new</span> File(<span class="string">"java.io.tmpdir"</span>, <span class="string">"EhcacheData"</span>)))</span><br><span class="line">                    .withCache(<span class="string">"xxxCache"</span>,</span><br><span class="line">                            CacheConfigurationBuilder.newCacheConfigurationBuilder(Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">ResourcePoolsBuilder</span>.<span class="title">newResourcePoolsBuilder</span>()</span></span><br><span class="line"><span class="class">                                            .<span class="title">heap</span>(2000, <span class="title">EntryUnit</span>.<span class="title">ENTRIES</span>)</span></span><br><span class="line"><span class="class">                                            .<span class="title">offheap</span>(1, <span class="title">MemoryUnit</span>.<span class="title">MB</span>)</span></span><br><span class="line"><span class="class">                                            .<span class="title">disk</span>(20, <span class="title">MemoryUnit</span>.<span class="title">MB</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                            )</span></span><br><span class="line"><span class="class">                    ).<span class="title">build</span>(<span class="title">true</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isAvailable())&#123;</span><br><span class="line">            cacheManager.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> != cacheManager &amp;&amp; cacheManager.getStatus().equals(Status.AVAILABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3 使用示例"></a>3 使用示例</h3><p>存放</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheManager persistentCacheManager = EhcacheHelper.getCacheManager();</span><br><span class="line">    Cache&lt;Long, String&gt; persistentCache = persistentCacheManager.getCache(<span class="string">"threeTieredCache"</span>, Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i ++)&#123;</span><br><span class="line">        persistentCache.put(i, <span class="string">"这是第:-"</span> + i + <span class="string">"-条信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    persistentCache.forEach( cc -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"persistentCache,主键：&#123;&#125;，值：&#123;&#125;"</span>,cc.getKey(),cc.getValue());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    persistentCacheManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheManager persistentCacheManager = EhcacheHelper.getCacheManager();</span><br><span class="line">    Cache&lt;Long, String&gt; persistentCache = persistentCacheManager.getCache(<span class="string">"threeTieredCache"</span>, Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Iterator&lt;Cache.Entry&lt;Long,String&gt;&gt; iterator = persistentCache.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        ++ count;</span><br><span class="line">        Cache.Entry&lt;Long,String&gt; entry = iterator.next();</span><br><span class="line">        log.info(<span class="string">"threeTieredCache,主键：&#123;&#125;，值：&#123;&#125;"</span>,entry.getKey(),entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"信息的总条数为：&#123;&#125;"</span>,count);</span><br><span class="line">    persistentCacheManager.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-关闭钩子"><a href="#4-关闭钩子" class="headerlink" title="4 关闭钩子"></a>4 关闭钩子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SkuSyncApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 hook 线程添加到运行时环境中去</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                EhcacheHelper.close();</span><br><span class="line">                System.out.println(<span class="string">"ShutdownHook ==&gt; Ehcache closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transaction</title>
      <link href="/2020/07/20/Spring/Data/Transaction/"/>
      <url>/2020/07/20/Spring/Data/Transaction/</url>
      
        <content type="html"><![CDATA[<p>Spring 事务的本质是数据库对事务的支持。</p><p><code>@EnableTransactionManagement</code> 开启对事务注解的解析</p><h3 id="1-声明式事务"><a href="#1-声明式事务" class="headerlink" title="1 声明式事务"></a>1 声明式事务</h3><h4 id="1-1-Transactional-注解"><a href="#1-1-Transactional-注解" class="headerlink" title="1.1 @Transactional 注解"></a>1.1 @Transactional 注解</h4><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>事务管理器</td></tr><tr><td>propagation</td><td>Propagation</td><td>传播级别</td></tr><tr><td>isolation</td><td>Isolation</td><td>隔离级别</td></tr><tr><td>readOnly</td><td>boolean</td><td>读/写与只读事务</td></tr><tr><td>timeout</td><td>int</td><td>事务超时(秒)</td></tr><tr><td>rollbackFor</td><td>Class</td><td>触发事务回滚的类，默认只对未检查异常有效</td></tr><tr><td>noRollbackFor</td><td>Class</td><td>设置不需要进行回滚的异常类数组</td></tr></tbody></table><h4 id="1-2-Transactional-特性"><a href="#1-2-Transactional-特性" class="headerlink" title="1.2 Transactional 特性"></a>1.2 Transactional 特性</h4><ul><li>类上添加 @Transactional，在每个方法单开一个事务，管理方式相同。</li><li>@Transactional 注解只在 public 方法上起作用。</li><li>默认只对未检查异常回滚</li><li>只读事务只在事务启动时应用，否则即使配置也会被忽略。</li></ul><h4 id="1-3-传播级别"><a href="#1-3-传播级别" class="headerlink" title="1.3 传播级别"></a>1.3 传播级别</h4><ul><li>PROPAGATION_REQUIRED<br>（默认设置）存在则加入，没有则创建</li><li>PROPAGATION_REQUIRES_NEW<br>创建新事务，如当前事务存在，则挂起当前事务</li><li>PROPAGATION_SUPPORTS<br>存在则加入；没有则以非事务的方式运行</li><li>PROPAGATION_NOT_SUPPORTED<br>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>PROPAGATION_MANDATORY<br>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>PROPAGATION_NEVER<br>以非事务方式运行，如果当前存在事务，则抛出异常</li><li>PROPAGATION_NESTED<br>存在则创建嵌套事务；没有则创建</li></ul><h4 id="1-4-隔离级别"><a href="#1-4-隔离级别" class="headerlink" title="1.4 隔离级别"></a>1.4 隔离级别</h4><ul><li>ISOLATION_DEFAULT<br>（默认设置）使用底层数据库的默认隔离级别。</li><li>ISOLATION_READ_UNCOMMITTED<br>可读取修改还没有提交的数据</li><li>ISOLATION_READ_COMMITTED<br>只能读取已经提交的数据。推荐。</li><li>ISOLATION_REPEATABLE_READ<br>可重复读，每次返回相同。</li><li>ISOLATION_SERIALIZABLE<br>逐个执行事务，性能低。</li></ul><h3 id="2-编程式事务"><a href="#2-编程式事务" class="headerlink" title="2 编程式事务"></a>2 编程式事务</h3><h4 id="2-1-TransactionTemplate"><a href="#2-1-TransactionTemplate" class="headerlink" title="2.1 TransactionTemplate"></a>2.1 TransactionTemplate</h4><p>在 doIntransaction 里处理逻辑。如果出异常了，就执行 isRollbackOnly 方法进行回滚。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">transactionTemplate.execute((TransactionStatus transactionStatus) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        transactionStatus.isRollbackOnly();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-2-TransactionManager"><a href="#2-2-TransactionManager" class="headerlink" title="2.2 TransactionManager"></a>2.2 TransactionManager</h4><p>手动 commit，异常就 rollback</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    userRepository.save(user);</span><br><span class="line">    transactionManager.commit(status);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    transactionManager.rollback(status);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic DataSource</title>
      <link href="/2020/07/19/Spring/Data/Dynamic%20DataSource/"/>
      <url>/2020/07/19/Spring/Data/Dynamic%20DataSource/</url>
      
        <content type="html"><![CDATA[<h2 id="一、AOP-实现"><a href="#一、AOP-实现" class="headerlink" title="一、AOP 实现"></a>一、AOP 实现</h2><p>AOP 实现多数据源，可读写分离</p><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1 配置文件"></a>1 配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dynamic-db.master.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> </span>= com.mysql.jdbc.Driver</span><br><span class="line">dynamic-db.master.jdbc-url = jdbc:mysql:<span class="comment">//somehost:3306/sometable?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">dynamic-db.master.username = xxx</span><br><span class="line">dynamic-db.master.password = xxx</span><br><span class="line"></span><br><span class="line">dynamic-db.slave.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> </span>= com.mysql.jdbc.Driver</span><br><span class="line">dynamic-db.slave.jdbc-url = jdbc:mysql:<span class="comment">//somehost:3306/sometable?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">dynamic-db.slave.username = xxx</span><br><span class="line">dynamic-db.slave.password = xxx</span><br></pre></td></tr></table></figure><h3 id="2-ContextHolder"><a href="#2-ContextHolder" class="headerlink" title="2 ContextHolder"></a>2 ContextHolder</h3><p>管理 DataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储当前 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; CONTEXT_HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有 DataSource 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; dataSourceKeys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSourceKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        CONTEXT_HOLDER.set(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前 DataSource，默认为 master</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSourceKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String key = CONTEXT_HOLDER.get();</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="string">"master"</span> : key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空当前 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSourceKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CONTEXT_HOLDER.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否当前 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containDataSourceKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSourceKeys.contains(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-注册动态配置"><a href="#3-注册动态配置" class="headerlink" title="3 注册动态配置"></a>3 注册动态配置</h3><p>继承 AbstractRoutingDataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将当前DataSource加入应用上下文</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicDataSourceContextHolder.getDataSourceKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-加载配置"><a href="#4-加载配置" class="headerlink" title="4 加载配置"></a>4 加载配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"master"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-db.master"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">master</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"slave"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-db.slave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置动态 DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dynamicDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dynamicDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DynamicRoutingDataSource dynamicRoutingDataSource = <span class="keyword">new</span> DynamicRoutingDataSource();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//所有DataSource</span></span><br><span class="line">        Map&lt;Object, Object&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        dataSourceMap.put(<span class="string">"master"</span>, master());</span><br><span class="line">        dataSourceMap.put(<span class="string">"slave"</span>, slave());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置默认DataSource</span></span><br><span class="line">        dynamicRoutingDataSource.setDefaultTargetDataSource(master());</span><br><span class="line">        <span class="comment">//设置所有DataSource</span></span><br><span class="line">        dynamicRoutingDataSource.setTargetDataSources(dataSourceMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将所有DataSource的key放入，以供判断</span></span><br><span class="line">        DynamicDataSourceContextHolder.dataSourceKeys.addAll(dataSourceMap.keySet());</span><br><span class="line">        <span class="keyword">return</span> dynamicRoutingDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据源添加到 SqlSession 工厂；获取 mybatis 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"mybatis"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dynamicDataSource());</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据源添加到事物管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dynamicDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-注解"><a href="#5-注解" class="headerlink" title="5 注解"></a>5 注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TargetDataSource &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Aspect"><a href="#6-Aspect" class="headerlink" title="6 Aspect"></a>6 Aspect</h3><p>要用 @Order(0) 注解让这个切面的优先级最高，以免被其他切面（如事务管理器）影响</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//切换</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"@annotation(targetDataSource))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchDataSource</span><span class="params">(JoinPoint point, TargetDataSource targetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DynamicDataSourceContextHolder.containDataSourceKey(targetDataSource.value()))&#123;</span><br><span class="line">            DynamicDataSourceContextHolder.setDataSourceKey(targetDataSource.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还原</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"@annotation(targetDataSource))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreDataSource</span><span class="params">(JoinPoint point, TargetDataSource targetDataSource)</span> </span>&#123;</span><br><span class="line">        DynamicDataSourceContextHolder.clearDataSourceKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-实例"><a href="#7-实例" class="headerlink" title="7 实例"></a>7 实例</h3><p>读写分离</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterMsgMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@InsertProvider</span>(type = InterMsgProvider<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"insert"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(InterMsg interMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetDataSource</span>(<span class="string">"slave"</span>)</span><br><span class="line">    <span class="meta">@SelectProvider</span>(type = InterMsgProvider<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"findMessages"</span>)</span><br><span class="line">    <span class="function">List&lt;InterMsg&gt; <span class="title">findMessages</span><span class="params">(Long userId, Integer limit, Long lastId, Long currentTime)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、普通配置"><a href="#二、普通配置" class="headerlink" title="二、普通配置"></a>二、普通配置</h2><h3 id="1-配置文件-1"><a href="#1-配置文件-1" class="headerlink" title="1 配置文件"></a>1 配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dynamic-db.master.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> </span>= com.mysql.jdbc.Driver</span><br><span class="line">dynamic-db.master.jdbc-url = jdbc:mysql:<span class="comment">//somehost:3306/sometable?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">dynamic-db.master.username = xxx</span><br><span class="line">dynamic-db.master.password = xxx</span><br><span class="line"></span><br><span class="line">dynamic-db.slave.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span> </span>= com.mysql.jdbc.Driver</span><br><span class="line">dynamic-db.slave.jdbc-url = jdbc:mysql:<span class="comment">//somehost:3306/sometable?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">dynamic-db.slave.username = xxx</span><br><span class="line">dynamic-db.slave.password = xxx</span><br></pre></td></tr></table></figure><h3 id="2-DataSourceConfig"><a href="#2-DataSourceConfig" class="headerlink" title="2 DataSourceConfig"></a>2 DataSourceConfig</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开启 数据库下划线转驼峰</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>) <span class="comment">//默认单例会使多数据源失效</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"mybatis.configuration"</span>)</span><br><span class="line">    <span class="keyword">public</span> org.apache.ibatis.session.<span class="function">Configuration <span class="title">globalConfiguration</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"masterDataSource"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-db.master"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">master</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"slaveDataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-db.slave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多数据源事务管理</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"tranMagMaster"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">bfTransactionManager</span><span class="params">(@Qualifier(<span class="string">"masterDataSource"</span>)</span>DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"tranMagSlave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">bfscrmTransactionManager</span><span class="params">(@Qualifier(<span class="string">"slaveDataSource"</span>)</span>DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-JdbcTemplatesConfig"><a href="#3-JdbcTemplatesConfig" class="headerlink" title="3 JdbcTemplatesConfig"></a>3 JdbcTemplatesConfig</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplatesConfig</span> <span class="keyword">extends</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持JdbcTemplate实现多数据源</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"masterJdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">masterJdbcTemplate</span><span class="params">(@Qualifier(<span class="string">"masterDataSource"</span>)</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"slaveJdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">slaveJdbcTemplate</span><span class="params">(@Qualifier(<span class="string">"slaveDataSource"</span>)</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-MybatisConfigMaster"><a href="#3-MybatisConfigMaster" class="headerlink" title="3 MybatisConfigMaster"></a>3 MybatisConfigMaster</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.xxx.mapper.master"</span>, </span><br><span class="line">        sqlSessionTemplateRef = <span class="string">"masterSqlSessionTemplate"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigMaster</span> <span class="keyword">extends</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">masterSqlSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            sqlSessionFactoryBean.setConfiguration(globalConfiguration());</span><br><span class="line">            sqlSessionFactoryBean.setDataSource(masterDataSource());</span><br><span class="line">            sqlSessionFactory = sqlSessionFactoryBean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">masterSqlSessionTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(masterSqlSessionFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-MybatisConfigSlave"><a href="#4-MybatisConfigSlave" class="headerlink" title="4 MybatisConfigSlave"></a>4 MybatisConfigSlave</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.xxx.mapper.slave"</span>, </span><br><span class="line">        sqlSessionTemplateRef = <span class="string">"slaveSqlSessionTemplate"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfigSlave</span> <span class="keyword">extends</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">slaveSqlSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            sqlSessionFactoryBean.setConfiguration(globalConfiguration());</span><br><span class="line">            sqlSessionFactoryBean.setDataSource(slaveDataSource());</span><br><span class="line">            sqlSessionFactory = sqlSessionFactoryBean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">slaveSqlSessionTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(slaveSqlSessionFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-使用"><a href="#5-使用" class="headerlink" title="5 使用"></a>5 使用</h3><p>在 @MapperScan 配置的目录下写 mapper 就行了</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cache</title>
      <link href="/2020/07/19/Spring/Data/Spring%20Cache/"/>
      <url>/2020/07/19/Spring/Data/Spring%20Cache/</url>
      
        <content type="html"><![CDATA[<p>Spring 自身并没有实现缓存解决方案， 但是它对缓存功能提供了声明式的支持， 能够与多种流行的缓存实现进行集成。</p><p>Spring 的缓存抽象在很大程度上是围绕切面构建的。 在 Spring 中启用缓存时，会创建一个切面， 它触发一个或更多的 Spring 的缓存注解。</p><h3 id="1-启用对缓存的支持"><a href="#1-启用对缓存的支持" class="headerlink" title="1 启用对缓存的支持"></a>1 启用对缓存的支持</h3><p>配置类上添加<code>@EnableCaching</code>启用 Spring 对注解驱动缓存的支持。</p><p>在方法上添加<code>@Cacheable</code>和<code>@CacheEvict</code>注解使用 Spring 的缓存抽象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentMapCacheManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-配置缓存管理器"><a href="#1-1-配置缓存管理器" class="headerlink" title="1.1 配置缓存管理器"></a>1.1 配置缓存管理器</h4><p>缓存管理器是 Spring 缓存抽象的核心， 它能够与多个流行的缓存实现进行集成。</p><p>Spring 3.1 内置五个缓存管理器实现</p><ul><li>SimpleCacheManager</li><li>NoOpCacheManager</li><li>ConcurrentMapCacheManager</li><li>CompositeCacheManager</li><li>EhCacheCacheManager</li></ul><p>Spring Data 又提供了两个缓存管理器：</p><ul><li>RedisCacheManager（来自于 Spring Data Redis 项目）</li><li>GemfireCacheManager（来自于 Spring Data GemFire 项目）</li></ul><h5 id="1）使用单个"><a href="#1）使用单个" class="headerlink" title="1）使用单个"></a>1）使用单个</h5><p>Redis 可以用来为 Spring 缓存抽象机制存储缓存条目， Spring Data Redis 提供了 RedisCacheManager， 这是 CacheManager 的一个实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager(redisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisConnectionFactory jedisConnectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">        jedisConnectionFactory.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> jedisConnectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisCF)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;String, String&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisCF);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）使用多个"><a href="#2）使用多个" class="headerlink" title="2）使用多个"></a>2）使用多个</h5><p>CompositeCacheManager 要通过一个或更多的缓存管理器来进行配置， 它会迭代这些缓存管理器， 以查找之前所缓存的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        net.sf.ehcache.CacheManager cm,</span></span></span><br><span class="line"><span class="function"><span class="params">        javax.cache.CacheManager jcm)</span> </span>&#123;</span><br><span class="line">    CompositeCacheManager cacheManager = <span class="keyword">new</span> CompositeCacheManager();</span><br><span class="line">    List&lt;CacheManager&gt; managers = <span class="keyword">new</span> ArrayList&lt;CacheManager&gt;();</span><br><span class="line">    managers.add(<span class="keyword">new</span> JCacheCacheManager(jcm));</span><br><span class="line">    managers.add(<span class="keyword">new</span> EhCacheCacheManager(cm))</span><br><span class="line">    managers.add(<span class="keyword">new</span> RedisCacheManager(redisTemplate()));</span><br><span class="line">    cacheManager.setCacheManagers(managers);</span><br><span class="line">    <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-为方法添加注解以支持缓存"><a href="#2-为方法添加注解以支持缓存" class="headerlink" title="2 为方法添加注解以支持缓存"></a>2 为方法添加注解以支持缓存</h3><p>所有注解都能运用在方法或类上。 放在类上时， 缓存行为会应用到这个类的所有方法上。</p><table><thead><tr><th>注 解</th><th>描 述</th></tr></thead><tbody><tr><td>@Cacheable</td><td>（读）调用前，先在缓存中查找方法的返回值。如有则返回，否则调用，返回值会放到缓存之中</td></tr><tr><td>@CachePut</td><td>（写）方法始终被调用，返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>（删）在缓存中清除一个或多个条目</td></tr><tr><td>@Caching</td><td>这是一个分组的注解， 能够同时应用多个其他的缓存注解</td></tr></tbody></table><h4 id="2-1-填充缓存"><a href="#2-1-填充缓存" class="headerlink" title="2.1 填充缓存"></a>2.1 填充缓存</h4><p>@Cacheable 和 @CachePut 都有一个名 value 属性，缓存名称</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(</span><br><span class="line">            SELECT_SPITTLE_BY_ID,</span><br><span class="line">            <span class="keyword">new</span> SpittleRowMapper(),</span><br><span class="line">            id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1）将值放到缓存之中"><a href="#1）将值放到缓存之中" class="headerlink" title="1）将值放到缓存之中"></a>1）将值放到缓存之中</h5><p>有 @CachePut 注解的方法始终都会被调用， 而且它的返回值也会放到缓存中。</p><p>适合用在保存、修改操作上，即刻缓存。</p><h5 id="2）自定义缓存-key"><a href="#2）自定义缓存-key" class="headerlink" title="2）自定义缓存 key"></a>2）自定义缓存 key</h5><p>@Cacheable 和 @CachePut 都有一个名为 key 属性， 这个属性能够替换默认的 key， 它是通过一个 SpEL 表达式计算得到的。</p><p>在为缓存编写 SpEL 表达式的时候， Spring 暴露了一些很有用的元数据。</p><table><thead><tr><th>表 达 式</th><th>描 述</th></tr></thead><tbody><tr><td>#root.args</td><td>传递给缓存方法的参数， 形式为数组</td></tr><tr><td>#root.caches</td><td>该方法执行时所对应的缓存， 形式为数组</td></tr><tr><td>#root.target</td><td>目标对象#root.targetClass 目标对象的类， 是#root.target.class的简写形式</td></tr><tr><td>#root.method</td><td>缓存方法</td></tr><tr><td>#root.methodName</td><td>缓存方法的名字， 是#root.method.name的简写形式</td></tr><tr><td>#result</td><td>方法调用的返回值（不能用在@Cacheable注解上）</td></tr><tr><td>#Argument</td><td>任意的方法参数名（如#argName） 或参数索引（如#a0或#p0）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut</span>(value=<span class="string">"spittleCache"</span>, key=<span class="string">"#result.id"</span>)</span><br><span class="line"><span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="3）条件化缓存"><a href="#3）条件化缓存" class="headerlink" title="3）条件化缓存"></a>3）条件化缓存</h5><p>@Cacheable 和 @CachePut 提供了两个属性用以实现条件化缓存： unless 和 condition。</p><p>unless 为 true 阻止添加到缓存中，condition 为 false 缓存被禁用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"spittleCache"</span> unless=<span class="string">"#result.message.contains('NoCache')"</span>)</span><br><span class="line"><span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-2-移除缓存条目"><a href="#2-2-移除缓存条目" class="headerlink" title="2.2 移除缓存条目"></a>2.2 移除缓存条目</h4><p>带有 @CacheEvict 注解的方法被调用，在缓存中移除。</p><p>适用于删除操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">long</span> spittleId)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data MongoDB</title>
      <link href="/2020/07/18/Spring/Data/Spring%20Data%20MongoDB/"/>
      <url>/2020/07/18/Spring/Data/Spring%20Data%20MongoDB/</url>
      
        <content type="html"><![CDATA[<p>文档数据库适合处理没什么关联关系的独立实体</p><p>Spring Data MongoDB 提供了三种方式在 Spring 应用中使用 MongoDB：</p><ul><li>通过注解实现对象-文档映射；</li><li>使用 MongoTemplate 实现基于模板的数据库访问；</li><li>自动化的运行时 Repository 生成功能。</li></ul><h3 id="1-启用-MongoDB"><a href="#1-启用-MongoDB" class="headerlink" title="1 启用 MongoDB"></a>1 启用 MongoDB</h3><p>@EnableMongoRepositories 注解启用 MongoDB</p><h4 id="1-1-方法一"><a href="#1-1-方法一" class="headerlink" title="1.1 方法一"></a>1.1 方法一</h4><p>MongoFactoryBean、MongoTemplate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span>(basePackages=<span class="string">"orders.db"</span>)<span class="comment">//Enable MongoDB repositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//MongoClient bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MongoFactoryBean <span class="title">mongo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MongoFactoryBean mongo = <span class="keyword">new</span> MongoFactoryBean();</span><br><span class="line">        mongo.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="keyword">return</span> mongo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MongoTemplate bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MongoOperations <span class="title">mongoTemplate</span><span class="params">(Mongo mongo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoTemplate(mongo, <span class="string">"OrdersDB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-方法二"><a href="#1-2-方法二" class="headerlink" title="1.2 方法二"></a>1.2 方法二</h4><p>配置类扩展 AbstractMongoConfiguration 并重载 getDatabaseName() 和 mongo() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span>(<span class="string">"orders.db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMongoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDatabaseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OrdersDB"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mongo <span class="title">mongo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//认证</span></span><br><span class="line">        MongoCredential credential =</span><br><span class="line">            MongoCredential.createMongoCRCredential(</span><br><span class="line">                env.getProperty(<span class="string">"mongo.username"</span>),</span><br><span class="line">                <span class="string">"OrdersDB"</span>,</span><br><span class="line">                env.getProperty(<span class="string">"mongo.password"</span>).toCharArray());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient(</span><br><span class="line">                <span class="keyword">new</span> ServerAddress(<span class="string">"localhost"</span>, <span class="number">37017</span>),</span><br><span class="line">                Arrays.asList(credential));</span><br><span class="line">        <span class="comment">//无需认证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient(<span class="string">"mongodbserver"</span>, <span class="number">27017</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-注解-MongoDB-持久化"><a href="#2-注解-MongoDB-持久化" class="headerlink" title="2 注解 MongoDB 持久化"></a>2 注解 MongoDB 持久化</h3><p>Spring Data MongoDB 提供了一些将 Java 类型映射为 MongoDB 文档的注解。</p><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Document</td><td>标示映射到 MongoDB 文档上的领域对象</td></tr><tr><td>@Id</td><td>标示某个域为ID域</td></tr><tr><td>@DbRef</td><td>标示某个域要引用其他的文档， 这个文档有可能位于另外一个数据库中</td></tr><tr><td>@Field</td><td>为文档域指定自定义的元数据</td></tr><tr><td>@Version</td><td>标示某个属性用作版本域</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"client"</span>)</span><br><span class="line">    <span class="keyword">private</span> String customer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Item&gt; items = <span class="keyword">new</span> LinkedHashSet&lt;Item&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用-MongoTemplate-访问-MongoDB"><a href="#3-使用-MongoTemplate-访问-MongoDB" class="headerlink" title="3 使用 MongoTemplate 访问 MongoDB"></a>3 使用 MongoTemplate 访问 MongoDB</h3><p>MongoOperations 是 MongoTemplate 所实现的接口， 不使用具体实现是一个好的做法， 尤其是在注入的时候</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MongoOperations mongo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> orderCount = mongo.getCollection(<span class="string">"order"</span>).count();</span><br><span class="line"></span><br><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">... <span class="comment">// set properties and add line items</span></span><br><span class="line">mongo.save(order, <span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line">String orderId = ...;</span><br><span class="line">Order order = mongo.findById(orderId, Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Order&gt; chucksOrders = mongo.find(Query.query(</span><br><span class="line">Criteria.where(<span class="string">"client"</span>).is(<span class="string">"Chuck Wagon"</span>)), Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Order&gt; chucksWebOrders = mongo.find(Query.query(</span><br><span class="line">Criteria.where(<span class="string">"customer"</span>).is(<span class="string">"Chuck Wagon"</span>)</span><br><span class="line">.and(<span class="string">"type"</span>).is(<span class="string">"WEB"</span>)), Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">mongo.remove(order);</span><br></pre></td></tr></table></figure><h3 id="4-编写-MongoDB-Repository"><a href="#4-编写-MongoDB-Repository" class="headerlink" title="4 编写 MongoDB Repository"></a>4 编写 MongoDB Repository</h3><p>扩展 MongoRepository。任何扩展 Repository 的接口将会在运行时自动生成实现。</p><p>MongoRepository 接口有两个参数， 第一个是带有 @Document 注解的对象类型， 也就是该 Repository 要处理的类型。 第二个参数是带有 @Id 注解的属性类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Order</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data Redis</title>
      <link href="/2020/07/18/Spring/Data/Spring%20Data%20Redis/"/>
      <url>/2020/07/18/Spring/Data/Spring%20Data%20Redis/</url>
      
        <content type="html"><![CDATA[<p>Spring Data Redis 包含了多个模板实现， 用来完成 Redis 数据库的数据存取功能。</p><h3 id="1-连接到Redis"><a href="#1-连接到Redis" class="headerlink" title="1 连接到Redis"></a>1 连接到Redis</h3><p>Spring Data Redis 为四种 Redis 客户端实现提供了连接工厂：</p><ul><li>JedisConnectionFactory</li><li>JredisConnectionFactory</li><li>LettuceConnectionFactory</li><li>SrpConnectionFactory</li></ul><p>配置为 bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">redisCF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JedisConnectionFactory cf = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">    cf.setHostName(<span class="string">"redis-server"</span>);</span><br><span class="line">    cf.setPort(<span class="number">7379</span>);</span><br><span class="line">    cf.setPassword(<span class="string">"foobared"</span>);</span><br><span class="line">    <span class="keyword">return</span> cf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-RedisTemplate"><a href="#2-使用-RedisTemplate" class="headerlink" title="2 使用 RedisTemplate"></a>2 使用 RedisTemplate</h3><p>Spring Data Redis 提供了两个模板：</p><ul><li>RedisTemplate</li><li>StringRedisTemplate</li></ul><p>RedisTemplate 简化 Redis 数据访问， 持久化各种类型的 key 和 value。StringRedisTemplate 扩展了 RedisTemplate，只关注 String 类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisTemplate&lt;String, Product&gt; redisTemplate(RedisConnectionFactory cf) &#123;</span><br><span class="line">    RedisTemplate&lt;String, Product&gt; redis &#x3D; new RedisTemplate&lt;String, Product&gt;();</span><br><span class="line">    redis.setConnectionFactory(cf);</span><br><span class="line">    return redis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用-key-和-value-的序列化器"><a href="#3-使用-key-和-value-的序列化器" class="headerlink" title="3 使用 key 和 value 的序列化器"></a>3 使用 key 和 value 的序列化器</h3><p>Spring Data Redis 提供了多个这样的序列化器， 包括：</p><ul><li>GenericToStringSerializer： 使用 Spring 转换服务进行序列化；</li><li>JacksonJsonRedisSerializer： 使用 Jackson 1， 将对象序列化为 JSON；</li><li>Jackson2JsonRedisSerializer： 使用 Jackson 2， 将对象序列化为 JSON；</li><li>JdkSerializationRedisSerializer： 使用 Java 序列化；</li><li>OxmSerializer： 使用 Spring O/X 映射的编排器和解排器（marshaler 和 unmarshaler） 实现序列化， 用于 XML 序列化；</li><li>StringRedisSerializer： 序列化 String 类型的 key 和 value。</li></ul><p>RedisTemplate 会使用 JdkSerializationRedisSerializer，StringRedisTemplate 默认会使用 StringRedisSerializer。setKeySerializer() 和 setValueSerializer() 方法可以分别设置序列化器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="comment">// 使用 Jackson2JsonRedisSerialize 替换默认序列化</span></span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">    <span class="comment">// 设置 value 的序列化规则和 key 的序列化规则</span></span><br><span class="line">    redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JdbcTemplate</title>
      <link href="/2020/07/17/Spring/Data/JdbcTemplate/"/>
      <url>/2020/07/17/Spring/Data/JdbcTemplate/</url>
      
        <content type="html"><![CDATA[<p>为了避免业务层模块强依赖于某种类型的数据库，Spring 数据库访问层以接口形式对外提供服务。</p><p>使用 Spring JDBC 的异常体系，描述能力强，且平台无关。</p><h3 id="1-数据访问模板化"><a href="#1-数据访问模板化" class="headerlink" title="1 数据访问模板化"></a>1 数据访问模板化</h3><p>数据访问过程中的固定步骤和变量分为两类：</p><ul><li>模板（templates）：处理数据访问的固定部分——事务控制、 管理资源以及处理异 常。</li><li>回调（callbacks）：处理应用程序相关的数据访问——语句、 绑定参数以及整理结果集</li></ul><p><img src="https://imine141.github.io/images/1545011852055.png" alt=""></p><p>针对不同的持久化平台， Spring提供了多个可选的模板。</p><table><thead><tr><th>ORM 持久化技术</th><th>模板类（org.springframework.*）</th></tr></thead><tbody><tr><td>JDBC</td><td>jdbc.core.JdbcTemplate</td></tr><tr><td>JCA CCI</td><td>jca.cci.core.CciTemplate</td></tr><tr><td>Hibernate</td><td>orm.hibernate5.HibernateTemplate</td></tr><tr><td>iBATIS</td><td>orm.ibatis.SqlMapClientTemplate</td></tr><tr><td>JDO</td><td>orm.jdo.JdoTemplate</td></tr><tr><td>JPA</td><td>orm.jpa.JpaTemplate</td></tr></tbody></table><h3 id="2-配置-DataSource"><a href="#2-配置-DataSource" class="headerlink" title="2 配置 DataSource"></a>2 配置 DataSource</h3><p>使用 JdbcTemplate 需设置 DataSource，提供了多种配置方式：</p><ol><li>JDBC 驱动；</li><li>JNDI 查询；</li><li>数据库连接池；</li></ol><p>生产环境建议使用从连接池获取连接的数据源；如果有可能，倾向于通过应用服务器的 JNDI 来获取数据源。</p><h4 id="2-1-JNDI-数据源"><a href="#2-1-JNDI-数据源" class="headerlink" title="2.1 JNDI 数据源"></a>2.1 JNDI 数据源</h4><p>在 Spring 应用部署的服务器中配置数据源，通过 JNDI 获取。数据源配置在应用外部，允许在访问数据库的时再查找数据源，且支持热切换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JndiObjectFactoryBean <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JndiObjectFactoryBean jndiObjectFB = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">    jndiObjectFB.setJndiName(<span class="string">"/jdbc/xxxx"</span>);</span><br><span class="line">    jndiObjectFB.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">    jndiObjectFB.setProxyInterface(javax.sql.DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> jndiObjectFB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-数据库连接池"><a href="#2-2-数据库连接池" class="headerlink" title="2.2 数据库连接池"></a>2.2 数据库连接池</h4><p>有多项开源数据源连接池实现：Apache Commons DBCP、c3p0、BoneCP</p><p>以 <a href="http://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="noopener">DBCP</a> 为例，BasicDataSource 配置连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BasicDataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BasicDataSource ds = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">  ds.setDriverClassName(<span class="string">"org.h2.Driver"</span>);</span><br><span class="line">  ds.setUrl(<span class="string">"jdbc:h2:tcp://localhost/~/xxxx"</span>);</span><br><span class="line">  ds.setUsername(<span class="string">"sa"</span>);</span><br><span class="line">  ds.setPassword(<span class="string">""</span>);</span><br><span class="line">  ds.setInitialSize(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、JDBC-驱动"><a href="#2-3、JDBC-驱动" class="headerlink" title="2.3、JDBC 驱动"></a>2.3、JDBC 驱动</h4><p>通过 JDBC 驱动定义数据源是最简单的配置方式。 org.springframework.jdbc.datasource 包中提供了三个数据源类：</p><ol><li>DriverManagerDataSource：每次请求连接时都返回新的连接，用过的连接会马上关闭并释放资源；</li><li>SimpleDriverDataSource：与 DriverManagerDataSource 类似，但直接使用JDBC驱动，免去了类在特定环境（如 OSGi 容器）中可能遇到的类加载问题。</li><li>SingleConnectionDataSource：每次都返回同一个连接对象，可以理解为只有 1 个连接的数据源连接池。</li></ol><p>跟之前配置 DBCP 的 BasicDataSource 类似，例如配置 DriverManagerDataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DriverManagerDataSource ds = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">  ds.setDriverClassName(<span class="string">"org.h2.Driver"</span>);</span><br><span class="line">  ds.setUrl(<span class="string">"jdbc:h2:tcp://localhost/~/xxxx"</span>);</span><br><span class="line">  ds.setUsername(<span class="string">"sa"</span>);</span><br><span class="line">  ds.setPassword(<span class="string">""</span>);</span><br><span class="line">   <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已上三数据源对多线程支持都不好，强烈建议使用数据库连接池。</p><h4 id="2-4-选择数据源"><a href="#2-4-选择数据源" class="headerlink" title="2.4 选择数据源"></a>2.4 选择数据源</h4><p>借助 Spring 的 bean-profiles 特性，在不同的环境中配置不同的数据源。利用 @Profile 注解，在运行时根据激活的 profile 选择指定的数据源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">embeddedDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"qa"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicDataSource <span class="title">basicDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BasicDataSource ds = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JndiObjectFactoryBean jndiObjectFactoryBean = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> (DataSource)jndiObjectFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用-JdbcTemplate"><a href="#3-使用-JdbcTemplate" class="headerlink" title="3 使用 JdbcTemplate"></a>3 使用 JdbcTemplate</h3><p><a href="https://www.jianshu.com/p/aec25eea5c71" target="_blank" rel="noopener">JDBC </a>直接操作数据库， 处理与数据库访问相关的所有事情， 样板代码繁琐，但很重要。Spring 的 JDBC 框架承担了资源管理和异常处理的样板代码，开发者只需编写读写数据的必需代码。</p><p><strong>JdbcTemplate</strong> 是最主要的 JDBC 模板，支持简单的 JDBC 数据库访问功能以及基于索引参数的查询；还提供了 NameParameterJdbcTemplate 支持命名参数。</p><h4 id="3-1-CRUD"><a href="#3-1-CRUD" class="headerlink" title="3.1 CRUD"></a>3.1 CRUD</h4><p>使用 JdbcTemplate 前需设置 DataSource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br></pre></td></tr></table></figure><ul><li>增删改<ul><li>update(final String sql)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"insert into user (username, password) values (?, ?)"</span>;</span><br><span class="line">jdbcTemplate.update(sql, username, password);</span><br></pre></td></tr></table></figure><p>当调用 update() 方法时，JdbcTemplate 调用 jdbc 获取一个连接、创建一个 statement，并执行插入语句。内部捕获了可能抛出的 SQLException 异常，然后转为更具体的数据库访问异常，并重新抛出。</p><ul><li>查<ul><li>queryForObject(String sql, RowMapper rowMapper, Object… args)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = jdbcOperations.queryForObject(sql,<span class="keyword">new</span> UserMapper (),param);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> rows)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(resultSet.getString(<span class="number">1</span>));</span><br><span class="line">        user.setPassword(resultSet.getString(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实现一个 RowMapper 对象，JdbcTemplate 会调用 mapRow() 方法，从结果集中取出对应属性的值，并构造对象。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data JPA</title>
      <link href="/2020/07/17/Spring/Data/Spring%20Data%20JPA/"/>
      <url>/2020/07/17/Spring/Data/Spring%20Data%20JPA/</url>
      
        <content type="html"><![CDATA[<p>Java 持久化 API（Java Persistence API， JPA）基于 POJO 的持久化机制，制定了规范，具体由厂商实现。</p><p>只需按照约定好的【方法命名规则】编写 Repository 接口，不需要实现类，就可实现对数据库的访问和操作。</p><p>hibernate 实现了 JPA 规范，Spring Data JPA 进一步封装了 Hibernate。</p><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h3><p>maven</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto &#x3D; update</span><br><span class="line">spring.jpa.properties.hibernate.dialect &#x3D; org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">spring.jpa.show-sql &#x3D; true</span><br></pre></td></tr></table></figure><p>spring.jpa.properties.hibernate.hbm2ddl.auto 有几种配置：</p><ul><li>create：每次加载生成新表。</li><li>create-drop：每次加载生成新表，但当 SessionFactory 关闭时，所生成的表将自动删除。</li><li>update：第一次加载时创建数据表，以后加载根据实体更新，只增不删。</li><li>validate：每次加载验证数据表结构，只会和已经存在的数据表进行比较，根据model修改表结构，但不会创建新表。</li></ul><p>不配置此项，表示禁用自动建表功能</p><h3 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2 简单使用"></a>2 简单使用</h3><h4 id="2-1-建立-entity"><a href="#2-1-建立-entity" class="headerlink" title="2.1 建立 entity"></a>2.1 建立 entity</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-扩展-Repository-接口"><a href="#2-2-扩展-Repository-接口" class="headerlink" title="2.2 扩展 Repository 接口"></a>2.2 扩展 Repository 接口</h4><p>扩展 Repository 接口或其子接口 JpaRepository、 PagingAndSortingRepository 和 CrudRepository</p><p>应用启动后自动生成接口的实现，提供默认通用方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-启用-Spring-Data-JPA"><a href="#2-3-启用-Spring-Data-JPA" class="headerlink" title="2.3 启用 Spring Data JPA"></a>2.3 启用 Spring Data JPA</h4><p>@EnableJpaRepositories 注解，扫描查找扩展自 Spring Data JPA Repository 接口的所有接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>&#123;basePackages=<span class="string">"com.xxx.xxx"</span>&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaConfiguration</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-定义查询方法"><a href="#3-定义查询方法" class="headerlink" title="3 定义查询方法"></a>3 定义查询方法</h3><p>只需使用属性名和关键字构建 Repository 方法签名， 就能让 Spring Data JPA 生成方法实现</p><p>当创建 Repository 实现的时候， Spring Data 会检查 Repository 接口的所有方法， 解析方法的名称， 并基于被持久化的对象来试图推测方法的目的。</p><h4 id="3-1-方法组成"><a href="#3-1-方法组成" class="headerlink" title="3.1 方法组成"></a>3.1 方法组成</h4><p>Repository 方法是由一个动词、 一个可选的主题、 关键词 By 以及一个断言所组成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByUsername</span><span class="params">(String userName)</span></span>;</span><br></pre></td></tr></table></figure><p>findByUsername() 这个样例中， 动词是 find， 断言是 Username， 主题并没有指 定， 暗含的主题是 User。</p><h4 id="3-2-比较操作"><a href="#3-2-比较操作" class="headerlink" title="3.2 比较操作"></a>3.2 比较操作</h4><p>断言中的多个限制条件可以进行比较操作</p><ul><li>IsAfter、 After、 IsGreaterThan、 GreaterThan</li><li>IsGreaterThanEqual、 GreaterThanEqual</li><li>…</li></ul><h3 id="4-声明自定义查询"><a href="#4-声明自定义查询" class="headerlink" title="4 声明自定义查询"></a>4 声明自定义查询</h3><p>如果 Spring Data 的这个小型的 DSL 无法满足需求，还可以通过 @Query 注解来解决问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query(<span class="string">"select * from User where username like '%abc'"</span>)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByAllAbcUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-混合自定义的功能"><a href="#5-混合自定义的功能" class="headerlink" title="5 混合自定义的功能"></a>5 混合自定义的功能</h3><p>当 Spring Data JPA 为 Repository 接口生成实现的时候， 它还会查找名字与接口相同， 并且添加了 Impl 后缀的一个类。 如果这个类存在的话， Spring Data JPA 将会把它的方法与 Spring DataJPA 所生成的方法合并在一起。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切面</title>
      <link href="/2020/07/16/Spring/AOP/%E5%88%87%E9%9D%A2/"/>
      <url>/2020/07/16/Spring/AOP/%E5%88%87%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建切面"><a href="#1-创建切面" class="headerlink" title="1 创建切面"></a>1 创建切面</h3><p>使用 @Aspect 注解创建切面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* cn.xxx..*ServiceImpl.*(..))&quot;)</span><br><span class="line">    public void printLog() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Before(&quot;printLog()&quot;)</span><br><span class="line">    public void before(JoinPoint jp) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @After(&quot;printLog()&quot;)</span><br><span class="line">    public void after(JoinPoint jp) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @AfterReturning(pointcut &#x3D; &quot;execution(* cn.xxx..*ServiceImpl.*(..))&quot;, returning &#x3D; &quot;returnVal&quot;)</span><br><span class="line">    public void afterReturn(JoinPoint jp, String returnVal) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @AfterThrowing(value &#x3D; &quot;printLog()&quot;, throwing &#x3D; &quot;e&quot;)</span><br><span class="line">    public void afterThrow(JoinPoint jp, Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-通知注解"><a href="#2-通知注解" class="headerlink" title="2 通知注解"></a>2 通知注解</h3><ul><li>@After(最终通知)：通知方法会在目标方法返回或抛出异常后调用</li><li>@AfterReturning(后置通知)：通知方法会在目标方法返回后调用</li><li>@AfterThrowing(异常通知)：通知方法会在目标方法抛出异常后调用</li><li>@Around(环绕通知)：通知方法会将目标方法封装起来</li><li>@Before(前置通知)：通知方法会在目标方法调用之前执行</li></ul><h3 id="3-JoinPoint"><a href="#3-JoinPoint" class="headerlink" title="3 JoinPoint"></a>3 JoinPoint</h3><p>常用的方法</p><ul><li>Object[] getArgs：返回目标方法的参数</li><li>Signature getSignature：返回目标方法的签名</li><li>Object getTarget：返回被织入增强处理的目标对象</li><li>Object getThis：返回AOP框架为目标对象生成的代理对象</li></ul><p>当使用 @Around 处理时，需要将第一个参数定义为 ProceedingJoinPoint 类型，该类是 JoinPoint 的子类。</p><h3 id="4-切面执行顺序"><a href="#4-切面执行顺序" class="headerlink" title="4 切面执行顺序"></a>4 切面执行顺序</h3><h4 id="4-1-被一个-Aspect-类拦截"><a href="#4-1-被一个-Aspect-类拦截" class="headerlink" title="4.1 被一个 Aspect 类拦截"></a>4.1 被一个 Aspect 类拦截</h4><p>正常： <img src="https://imine141.github.io/images/1545011851419.jpg" alt="img"></p><p>异常： <img src="https://imine141.github.io/images/1545011851515.jpg" alt="img"></p><h4 id="4-2-被多个-Aspect-类拦截"><a href="#4-2-被多个-Aspect-类拦截" class="headerlink" title="4.2 被多个 Aspect 类拦截"></a>4.2 被多个 Aspect 类拦截</h4><h5 id="1）执行顺序"><a href="#1）执行顺序" class="headerlink" title="1）执行顺序"></a>1）执行顺序</h5><p>优先级高的切面先执行，同一切面增强类型优先的先执行，增强类型相同的随机执行</p><h5 id="2）指定优先级"><a href="#2）指定优先级" class="headerlink" title="2）指定优先级"></a>2）指定优先级</h5><ol><li>让切面类实现 org.springframework.core.Ordered 接口：实现该接口的 int getOrder() 方法，该方法返回值越小，优先级越高</li><li>直接使用 @Order 注解来修饰一个切面类：使用这个注解时可以配置一个 int 类型的 value 属性，该属性值越小，优先级越高</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP简介</title>
      <link href="/2020/07/15/Spring/AOP/AOP%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/07/15/Spring/AOP/AOP%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>AOP 即 Aspect Oriented Programming，面向切面编程。</p><p>AOP 允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。</p><h3 id="1-AOP-术语"><a href="#1-AOP-术语" class="headerlink" title="1 AOP 术语"></a>1 AOP 术语</h3><p><img src="https://imine141.github.io/images/aopjianjie1.png" alt="img"></p><ul><li>通知（Advice）<ul><li><code>通知</code>表示在方法执行前后需要执行的动作，是<code>切面</code>真正要做的工作。通知负责定义<code>切面</code>的 <code>what</code> 和 <code>when</code>。</li></ul></li><li>连接点（JointPoint）<ul><li><code>连接点</code>表示在应用中可以插入<code>切面</code>，执行<code>通知</code>的地点。</li></ul></li><li>切点（Pointcut）<ul><li><code>切点</code>定义了 <code>where</code>。<code>切点</code>指定一个或者多个<code>连接点</code>，而<code>通知</code>通过切点接入。</li></ul></li><li>切面（Aspect）<ul><li><code>切面</code> = <code>通知</code> + <code>切点</code>。定义 <code>what</code>、<code>when</code> 和 <code>where</code>。是 AOP 的核心，将多个类的通用行为封装为可重用的模块。</li></ul></li><li>引入（Introduction）<ul><li><code>引入</code>允许向现有类添加新方法或属性。类似于设计模式中的装饰者模式——在不改变现有类的基础上为之增加属性和方法。</li></ul></li><li>织入（Weaving）<ul><li><code>织入</code>是把<code>切面</code>应用到目标对象并创建新的代理对象的过程。</li><li><code>切面</code>在指定的<code>连接点</code>被织入到目标对象中。</li><li>在目标对象的生命周期里有多个点可以进行织入：编译期（AspectJ）、类加载期（LTW）、运行期（Spring AOP）</li></ul></li><li>目标对象<ul><li>被一个或者多个<code>切面</code>所<code>通知</code>的对象。它通常是一个代理对象。也被称做被通知（advised）对象。</li></ul></li><li>代理<ul><li><code>代理</code>是将<code>通知</code>应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</li></ul></li><li>自动代理<ul><li>BeanNameAutoProxyCreator：bean名称自动代理创建器</li><li>DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器</li><li>Metadata autoproxying：元数据自动代理</li></ul></li><li>Concern（核心逻辑）<ul><li>表示在应用程序中一个模块的行为。Concern 可以定义为我们想要实现的功能。</li></ul></li><li>Cross-cutting concern（横向的通用逻辑）<ul><li>指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互</li></ul></li></ul><h3 id="2-Spring-的-AOP-支持"><a href="#2-Spring-的-AOP-支持" class="headerlink" title="2 Spring 的 AOP 支持"></a>2 Spring 的 AOP 支持</h3><p>Spring 对 AOP 有以下四种支持：</p><ul><li>基于代理的 Spring AOP</li><li>Pure-POJO aspects</li><li>基于 @AspectJ 注解的 aspects</li><li>注入 AspectJ aspects（所有版本的 Spring 都支持）</li></ul><p>前三种属于 Spring AOP 框架，基于动态代理机制构建，<strong>仅支持函数级别的拦截</strong>。如果需要实现更复杂的 AOP 功能，则应使用 <strong><em>AspectJ 框架</em></strong>。</p><p>在 Spring AOP 框架中，通过在 beans 的外围包含一个代理类来将切面织入到这些 beans。调用者跟代理类直接联系，代理类拦截函数调用，然后执行切面逻辑之后再调用真正的目标对象的方法。</p><p><img src="https://imine141.github.io/images/1545011850875.png" alt="img"></p><p>虽然 Spring AOP 能够满足许多应用的切面需求， 但是与 AspectJ 相比， Spring AOP 是一个功能比较弱的 AOP 解决方案。 AspectJ 提供了 Spring AOP 所不能支持的许多类型的切点。</p><p>AOP 的源码中用到了两种动态代理来实现拦截切入功能：</p><ul><li>jdk 动态代理<ul><li>jdk 动态代理是由 java 内部的反射机制来实现的，反射机制在生成类的过程中比较高效</li><li>如果加入容器的目标对象有实现接口,用 JDK 代理；</li></ul></li><li>Cglib 动态代理<ul><li>cglib 动态代理底层则是借助 asm 来实现的，asm 在生成类之后的相关执行过程中比较高效</li><li>如果目标对象没有实现接口，用 Cglib 代理</li></ul></li></ul><h3 id="3-AspectJ"><a href="#3-AspectJ" class="headerlink" title="3 AspectJ"></a>3 AspectJ</h3><p><strong>AspectJ 注解生效</strong></p><p>通过类级别的 @EnableAspectJAutoProxy 注解开启自动代理机制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//开启AspectJ的自动代理机制</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切点</title>
      <link href="/2020/07/15/Spring/AOP/%E5%88%87%E7%82%B9/"/>
      <url>/2020/07/15/Spring/AOP/%E5%88%87%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-编写切点"><a href="#1-编写切点" class="headerlink" title="1 编写切点"></a>1 编写切点</h3><p>@Pointcut 定义可重复使用的切点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.xxx.mapper.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-表示式"><a href="#1-1-表示式" class="headerlink" title="1.1 表示式"></a>1.1 表示式</h4><p>由下列方式来定义或者通过 &amp;&amp;、 ||、 !、 的方式进行组合：</p><h5 id="1）方法"><a href="#1）方法" class="headerlink" title="1）方法"></a>1）方法</h5><ul><li>execution：匹配方法</li><li>within：限制匹配范围</li><li>this：匹配 AOP 代理类的执行方法</li><li>target：匹配目标类的执行方法</li><li>args：将匹配方法的参数传入通知，名称必须相同</li></ul><h5 id="2）注解"><a href="#2）注解" class="headerlink" title="2）注解"></a>2）注解</h5><ul><li>@within：匹配类注解</li><li>@target：匹配类注解</li><li>@args：匹配参数注解</li><li>@annotation：匹配方法注解</li></ul><h5 id="3）bean"><a href="#3）bean" class="headerlink" title="3）bean"></a>3）bean</h5><ul><li>bean()：匹配制定 bean</li></ul><h4 id="1-2-格式"><a href="#1-2-格式" class="headerlink" title="1.2 格式"></a>1.2 格式</h4><p>“?”代表可选项</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(修饰符? 返回值 类路径? 方法名(参数)异常类型?)</span><br></pre></td></tr></table></figure><ul><li>返回值<br><code>*</code>匹配任意</li><li>方法名<br><code>*</code>匹配任意</li><li>参数<br>指定参数类型，<code>,</code>隔开<br><code>*</code>任意类型<br><code>..</code>任意个数</li></ul><h4 id="1-3-例子"><a href="#1-3-例子" class="headerlink" title="1.3 例子"></a>1.3 例子</h4><ul><li>任意公共方法：<code>execution(public * *(..))</code></li><li>任何“set”开头方法：<code>execution(* set*(..))</code></li><li>某类任意方法：<code>execution(* com.xyz.service.AccountService.*(..))</code></li><li>某包里任意方法： <code>execution(* com.xyz.service.*.*(..))</code></li><li>某包及子包任意方法：<code>execution(* com.xyz.service..*.*(..))</code></li><li>某包任意类： <code>within(com.test.spring.aop.pointcutexp.*)</code></li><li>实现了 Intf 接口的所有类：<code>this(com.abc.Intf)</code></li><li>带有 @xxx 注解的所有类的任意方法：<ul><li><code>@within(org.abc.xxx)</code></li><li><code>@target(org.abc.xxx))</code></li></ul></li><li>带有 @xxx 注解的任意方法：<code>@annotation(org.abc.xxx))</code></li><li>参数带有有 @xxx 注解的方法：<code>@args(org.abc.xxx)</code></li><li>参数类型： <code>args(String)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态注册 Bean</title>
      <link href="/2020/07/14/Spring/IoC/%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%20Bean/"/>
      <url>/2020/07/14/Spring/IoC/%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%20Bean/</url>
      
        <content type="html"><![CDATA[<h3 id="1-注册接口"><a href="#1-注册接口" class="headerlink" title="1 注册接口"></a>1 注册接口</h3><p>有两种接口可动态注册 bean</p><ol><li>BeanDefinitionRegistry<br>注册 Bean 定义，使用<code>BeanDefinitionRegistry</code> 接口 <code>registerBeanDefinition()</code> 方法，根据<code>BeanDefinition</code>实例化 bean 实例</li><li>SingletonBeanRegistry<br>注册 bean 实例，使用<code>SingletonBeanRegistry</code> 接口<code>registerSingleton()</code> 方法，注册单例 bean。</li></ol><p><strong>DefaultListableBeanFactory</strong> 接口同时实现了这两个接口</p><h3 id="2-普通注册"><a href="#2-普通注册" class="headerlink" title="2 普通注册"></a>2 普通注册</h3><p>如果是在普通 Bean 中注册，那么该 bean 则无法被<strong>BeanPostProcessor</strong>处理，没有 AOP 的支持。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonManagerRegisterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    GenericApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConfigurableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerPersonManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PersonDao personDao = applicationContext.getBean(PersonDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        PersonManager personManager = <span class="keyword">new</span> PersonManager();</span><br><span class="line">        personManager.setPersonDao(personDao);</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"personManager"</span>, personManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-BeanFactoryPostProcessor-注册"><a href="#3-BeanFactoryPostProcessor-注册" class="headerlink" title="3 BeanFactoryPostProcessor 注册"></a>3 BeanFactoryPostProcessor 注册</h3><p>在 Spring 容器的启动过程中，BeanFactory 载入 bean 的定义后会立刻执行 BeanFactoryPostProcessor，此时动态注册 bean，则可以保证动态注册的 bean 被 BeanPostProcessor 处理，并且可以保证其的实例化和初始化总是先于依赖它的 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory</span><br><span class="line">                = (DefaultListableBeanFactory) beanFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册 Bean 定义</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder =</span><br><span class="line">                BeanDefinitionBuilder.genericBeanDefinition(PersonManager<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanDefinitionBuilder.addPropertyReference(<span class="string">"personDao"</span>, <span class="string">"personDao"</span>);</span><br><span class="line">        BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder.getRawBeanDefinition();</span><br><span class="line">        defaultListableBeanFactory.registerBeanDefinition(<span class="string">"personManager1"</span>, personManagerBeanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册 bean 实例</span></span><br><span class="line">        PersonDao personDao = beanFactory.getBean(PersonDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        PersonManager personManager = <span class="keyword">new</span> PersonManager();</span><br><span class="line">        personManager.setPersonDao(personDao);</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"personManager2"</span>, personManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Spring-官方实现"><a href="#4-Spring-官方实现" class="headerlink" title="4 Spring 官方实现"></a>4 Spring 官方实现</h3><h4 id="4-1-ImportBeanDefinitionRegistrar"><a href="#4-1-ImportBeanDefinitionRegistrar" class="headerlink" title="4.1 ImportBeanDefinitionRegistrar"></a>4.1 ImportBeanDefinitionRegistrar</h4><p>Spring 官方在动态注册 bean 时，大多使用 ImportBeanDefinitionRegistrar 接口。</p><p>所有实现了该接口的类的都会被 ConfigurationClassPostProcessor 处理，ConfigurationClassPostProcessor 实现了 BeanFactoryPostProcessor 接口，所以 ImportBeanDefinitionRegistrar 中动态注册的 bean 是优先与依赖其的 bean 初始化的，也能被 aop、validator 等机制处理。</p><h4 id="4-2-BeanDefinitionRegistryPostProcessor"><a href="#4-2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="4.2 BeanDefinitionRegistryPostProcessor"></a>4.2 BeanDefinitionRegistryPostProcessor</h4><p>Spring 官方另一个大量使用的动态注册接口是 BeanDefinitionRegistryPostProcessor，这个接口扩展自 BeanFactoryPostProcessor，专门用于动态注册 Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBeanDefinitionRegistryPostProcessor</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 Bean 定义</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// 构造 bean 定义</span></span><br><span class="line">BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(PersonManager<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//设置依赖</span></span><br><span class="line">beanDefinitionBuilder.addPropertyReference(<span class="string">"personDao"</span>, <span class="string">"personDao"</span>);</span><br><span class="line">BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder</span><br><span class="line">.getRawBeanDefinition();</span><br><span class="line"><span class="comment">//注册bean定义</span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"personManager1"</span>, personManagerBeanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Bean 实例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(PersonManager<span class="class">.<span class="keyword">class</span>, () -&gt; </span>&#123;</span><br><span class="line">PersonDao personDao = beanFactory.getBean(PersonDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">PersonManager personManager = <span class="keyword">new</span> PersonManager();</span><br><span class="line">personManager.setPersonDao(personDao);</span><br><span class="line"><span class="keyword">return</span> personManager;</span><br><span class="line">&#125;);</span><br><span class="line">BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder</span><br><span class="line">.getRawBeanDefinition();</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.registerBeanDefinition(<span class="string">"personManager2"</span>, personManagerBeanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级装配</title>
      <link href="/2020/07/13/Spring/IoC/%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/"/>
      <url>/2020/07/13/Spring/IoC/%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-环境与-profile"><a href="#1-环境与-profile" class="headerlink" title="1 环境与 profile"></a>1 环境与 profile</h3><h4 id="1-1-配置-profile"><a href="#1-1-配置-profile" class="headerlink" title="1.1 配置 profile"></a>1.1 配置 profile</h4><h5 id="Profile-注解"><a href="#Profile-注解" class="headerlink" title="@Profile 注解"></a>@Profile 注解</h5><p>指定某个 bean 属于哪一个 profile，运行时做出环境决策。</p><p>没有指定 profile 的 bean 始终都会被创建， 与激活哪个 profile 没有关系。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br></pre></td></tr></table></figure><h4 id="1-2-激活-profiles"><a href="#1-2-激活-profiles" class="headerlink" title="1.2 激活 profiles"></a>1.2 激活 profiles</h4><p>Spring 提供了两个配置项定义激活哪个 profile：</p><ul><li>spring.profiles.active：优先</li><li>spring.profiles.default：没有 active 则找 default</li></ul><p>如都没有设置，则只会创建没有被 profile 修饰的 bean。</p><h3 id="2-条件化的-bean"><a href="#2-条件化的-bean" class="headerlink" title="2 条件化的 bean"></a>2 条件化的 bean</h3><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>作用于 @Bean 注解修饰的方法上，通过判断指定的条件是否满足来决定是否创建该 bean。</p><p>传入注解的类一定要实现 Condition 接口，提供 matchs() 方法——如果 matches() 方法返回 true，则被 @Conditional 注解修饰的 bean 就会创建，否则对应的 bean 不会创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional</span>(MagicExistsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">MagicBean</span> <span class="title">magicBean</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MagicBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理自动装配的歧义"><a href="#3-处理自动装配的歧义" class="headerlink" title="3 处理自动装配的歧义"></a>3 处理自动装配的歧义</h3><h4 id="3-1-Primary"><a href="#3-1-Primary" class="headerlink" title="3.1 @Primary"></a>3.1 @Primary</h4><p>指定优先 bean</p><h4 id="3-2-Qualifier"><a href="#3-2-Qualifier" class="headerlink" title="3.2 @Qualifier"></a>3.2 @Qualifier</h4><p>指定 bean 的 ID</p><p>也可在 bean 和注入的地方注解相同 @Qualifier，或定义自定义 QUALIFIER</p><h3 id="4-bean-的作用域"><a href="#4-bean-的作用域" class="headerlink" title="4 bean 的作用域"></a>4 bean 的作用域</h3><h4 id="4-1-Scope"><a href="#4-1-Scope" class="headerlink" title="4.1 @Scope"></a>4.1 @Scope</h4><p>Spring 中的 bean 默认都是单例，这对可变类型是非线程安全的。如果选择其他的作用域， 要使用 @Scope 注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br></pre></td></tr></table></figure><h4 id="4-2-scoped-代理"><a href="#4-2-scoped-代理" class="headerlink" title="4.2 scoped 代理"></a>4.2 scoped 代理</h4><p>单例 bean 在加载时就会被创建，会话/请求 bean 要创建 request/session 时才会被创建。</p><p>把会话 bean 装配到单例 bean 时，应给单例 bean 装配一个会话 bean 的代理。</p><p>代理类对外暴露的接口和会话 bean 中的一样，当单例 bean 调用对应的接口时，代理采取懒解析策略，并把调用委派给实际的 session-scoped bean。设置 proxyMode 属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(value=WebApplicationContext.SCOPE_SESSION,</span><br><span class="line">proxyMode=ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ShoppingCart <span class="title">cart</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="5-运行时值注入"><a href="#5-运行时值注入" class="headerlink" title="5 运行时值注入"></a>5 运行时值注入</h3><p>Spring 提供以下两种方式实现运行时注入：</p><ul><li>属性占位符（ Property placeholder） 。</li><li>Spring 表达式语言（ SpEL） 。</li></ul><h4 id="5-1-Environment"><a href="#5-1-Environment" class="headerlink" title="5.1 Environment"></a>5.1 Environment</h4><p>在 Spring 中解析外部值的最好方法是定义一个配置文件，然后通过 Spring 的 Environment 实例获取配置文件中的配置项的值。属性文件被加载到 Spring 的 Environment 实例中，然后通过 getProperty() 方法解析对应配置项的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressiveConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">disc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(env.getProperty(<span class="string">"disc.title"</span>),env.getProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-属性占位符"><a href="#5-2-属性占位符" class="headerlink" title="5.2 属性占位符"></a>5.2 属性占位符</h4><p>将属性定义到外部的属性的文件中， 并使用占位符“${ … }”将其插入到 Spring bean 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Value(<span class="string">"$&#123;disc.title&#125;"</span>)</span> String title,</span></span><br><span class="line"><span class="function">        @<span class="title">Value</span><span class="params">(<span class="string">"$&#123;disc.artist&#125;"</span>)</span> String artist) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使用占位符的值，需要配置 PropertySourcesPlaceholderConfigurer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">placeholderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-SpEL-表达式"><a href="#5-3-SpEL-表达式" class="headerlink" title="5.3 SpEL 表达式"></a>5.3 SpEL 表达式</h4><p>运行时给 bean 的属性或者构造函数参数注入值</p><p>SpEL 表达式被 #{ … } 包围：</p><ul><li>可以通过 bean 的 ID 引用 bean；</li><li>可以调用某个对象的方法或者访问它的属性；</li><li>支持数学、关系和逻辑操作；</li><li>正则表达式匹配；</li><li>支持集合操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入</title>
      <link href="/2020/07/13/Spring/IoC/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/07/13/Spring/IoC/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>IoC</strong>（Inversion of Control，控制反转 ）：控制权由应用代码中转到了外部容器，控制权的转移，所谓控制反转。</p><p><strong>依赖注入</strong>：依赖注入是控制反转(IOC)的一个层面，用创建对象而只需要描述如何创建它们。</p><p>IoC 负责装配 Bean，即创建应用对象之间协作关系，是<strong>依赖注入</strong>（DI，Dependency injection）的本质。</p><p>装配方式优先级：自动装配 &gt; Java 配置文件 &gt; XML 配置文件</p><h3 id="1-自动装配"><a href="#1-自动装配" class="headerlink" title="1 自动装配"></a>1 自动装配</h3><p>Spring 容器可以自动配置相互协作 beans 之间的关联关系。这意味着 Spring 可以自动配置一个 bean 和其他协作 bean 之间的关系。</p><p>Spring 从两个角度来实现自动装配</p><h4 id="1-1-组件扫描"><a href="#1-1-组件扫描" class="headerlink" title="1.1 组件扫描"></a>1.1 组件扫描</h4><p>Spring 自动发现 ApplicationContext 中所创建的 bean</p><h5 id="1）-Component"><a href="#1）-Component" class="headerlink" title="1）@Component"></a>1）@Component</h5><p>让 Spring 为类自动创建 bean，默认 ID 是类名称的首字母小写。也可给注解传入指定的参数指定名字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"lonelyHeartsClub"</span>)</span><br></pre></td></tr></table></figure><p>还有 @Repository、@Service、@Controller 等</p><h5 id="2）-ComponentScan"><a href="#2）-ComponentScan" class="headerlink" title="2）@ComponentScan"></a>2）@ComponentScan</h5><p>开启 Component 扫描，默认设置该目录以及子目录下所有被 @Component 注解修饰的类。也可指定扫描的包。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"soundsystem"</span>)<span class="comment">//扫描指定包  </span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"soundsystem"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"soundsystem"</span>, <span class="string">"video"</span>&#125;)</span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackageClasses = &#123;CDPlayer<span class="class">.<span class="keyword">class</span>, <span class="title">DVDPlayer</span>.<span class="title">class</span>&#125;)//扫描指定类所属的包</span></span><br></pre></td></tr></table></figure><h4 id="1-2-自动装配"><a href="#1-2-自动装配" class="headerlink" title="1.2 自动装配"></a>1.2 自动装配</h4><p>Spring 自动满足 bean 之间的依赖</p><p><strong>@Autowired</strong>：声明自动装配，可用在构造器、方法、成员变量上。</p><p>只要对应类型的 bean 有且只有一个，则会自动装配。推荐通过构造器注入以避免 NullPointerException 问题。</p><h5 id="1）注入到-Java-集合类"><a href="#1）注入到-Java-集合类" class="headerlink" title="1）注入到 Java 集合类"></a>1）注入到 Java 集合类</h5><p>@Autowired 可直接将接口的实现 Bean 注入到如下几种类型的集合中</p><ul><li>list：用来注入一系列的值，允许有相同的值。</li><li>set：用来注入一些列的值，不允许有相同的值。</li><li>map：用来注入一组”键-值”对，key 必须为 String。</li><li>props：也可以用来注入一组”键-值”对，这里的键、值都字符串类型。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;BeanInterface&gt; list;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Interface&gt; map;</span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">table-info.list[0]=list_value1</span><br><span class="line">table-info.list[1]=list_value2</span><br><span class="line">table-info.map.map_key1=map_value1</span><br><span class="line">table-info.map.map_key2=map_value2</span><br><span class="line">table-info.maplist.map_key1[0]=maplist_value1</span><br><span class="line">table-info.maplist.map_key1[1]=maplist_value2</span><br><span class="line">table-info.maplist.map_key2[0]=maplist_value3</span><br></pre></td></tr></table></figure><p>TableConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"table-info"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; maplist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）允许-null-值"><a href="#2）允许-null-值" class="headerlink" title="2）允许 null 值"></a>2）允许 null 值</h5><p>默认要求依赖对象必须存在，如允许 null 值，可设置 @Autowired(required=false)</p><p>还有 @Resource 等</p><h5 id="3）推荐对构造函数进行注释"><a href="#3）推荐对构造函数进行注释" class="headerlink" title="3）推荐对构造函数进行注释"></a>3）推荐对构造函数进行注释</h5><p>由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EnterpriseDbService service;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EnterpriseDbService service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnterpriseDbController</span><span class="params">(EnterpriseDbService service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.service = service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明确成员变量的加载顺序</p><h3 id="2-Java-配置文件"><a href="#2-Java-配置文件" class="headerlink" title="2 Java 配置文件"></a>2 Java 配置文件</h3><p>想要装配第三方库中的组件时，因为没办法在它的类上添加 @Component 和 @Autowired 注解，不能自动化配置，必须要采用显式装配。</p><h4 id="2-1-创建配置类"><a href="#2-1-创建配置类" class="headerlink" title="2.1 创建配置类"></a>2.1 创建配置类</h4><p>@Configuration：表明是配置类</p><h4 id="2-2-声明-bean"><a href="#2-2-声明-bean" class="headerlink" title="2.2 声明 bean"></a>2.2 声明 bean</h4><p><strong>@Bean</strong>：声明 bean，需编写方法创建所需类型实例， 注解 @Bean。默认 ID 是方法名，也可通过 name 属性指定名字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"lonelyHeartsClub"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-装配-bean"><a href="#2-3-装配-bean" class="headerlink" title="2.3 装配 bean"></a>2.3 装配 bean</h4><p>在 JavaConfig 中装配 bean 的最简单方式就是引用创建 bean 的方法。</p><p>默认情况下，Spring 中所有的 bean 都是<strong>单例模式</strong>，Spring 会拦截 @Bean 注解的函数调用，并返回之前创建好的 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-XML-配置文件"><a href="#3-XML-配置文件" class="headerlink" title="3 XML 配置文件"></a>3 XML 配置文件</h3><p>维护已有的 XML 配置， 在完成新的 Spring 工作时， 使用自动化配置和 JavaConfig。</p><p>创建一个 XML 文件， 并且以 元素为根。使用 元素声明 bean 并指定 class 属性。 元素注入构造器</p><p>可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用 setter 方法实现可选的依赖关系。</p><h4 id="3-1-set-注入"><a href="#3-1-set-注入" class="headerlink" title="3.1 set 注入"></a>3.1 set 注入</h4><p>首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用 bean 中的setter 方法完成 Setter 方法依赖注入。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderService</span><span class="params">(OrderServiceImp orderService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 配置 XML 文件：其中配置声明 OrderAction 类存在属性 orderService。程式运行时候，会将已经实例化的 orderService 对象调用 setOrderService 方式注入。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderAction"</span> <span class="attr">class</span>=<span class="string">"com.pec.action.OrderAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">ref</span>=<span class="string">"orderService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"com.pec.service.imp.OrderServiceImp"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-构造器注入"><a href="#3-2-构造器注入" class="headerlink" title="3.2 构造器注入"></a>3.2 构造器注入</h4><p>构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderAction</span><span class="params">(OrderServiceImp orderService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 配置 XML 文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderAction"</span> <span class="attr">class</span>=<span class="string">"com.pec.action.OrderAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"orderService"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"com.pec.service.imp.OrderServiceImp"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-多种配置方法混用"><a href="#4-多种配置方法混用" class="headerlink" title="4 多种配置方法混用"></a>4 多种配置方法混用</h3><p>通常的做法是：无论使用 JavaConfig 或者 XML 装配，都要创建一个 root configuration；并且在这个配置文件中开启自动扫描机制</p><h4 id="4-1-JavaConfig-中引用"><a href="#4-1-JavaConfig-中引用" class="headerlink" title="4.1 JavaConfig 中引用"></a>4.1 JavaConfig 中引用</h4><ul><li>@Import：导入其他的 JavaConfig</li><li>@ImportResource：导入 XML 配置文件</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;CDPlayerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">CDConfig</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line">@ImportResource("classpath: cd-config.xml")</span><br></pre></td></tr></table></figure><h4 id="4-2-XML-配置中引用"><a href="#4-2-XML-配置中引用" class="headerlink" title="4.2 XML 配置中引用"></a>4.2 XML 配置中引用</h4><p>标签引入其他的 XML 配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:/spring/calculate-web.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>标签导入 Java 配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"soundsystem.CDConfig"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-BeanFactory-和-FactoryBean的区别"><a href="#5-BeanFactory-和-FactoryBean的区别" class="headerlink" title="5 BeanFactory 和 FactoryBean的区别"></a>5 BeanFactory 和 FactoryBean的区别</h3><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a><strong>BeanFactory</strong></h4><p>BeanFactory，以Factory结尾，表示它是一个工厂类(接口)， 它负责生产和管理bean的一个工厂。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a><strong>FactoryBean</strong></h4><p>一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<T>的形式</p><p>以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean<T>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> IoC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC容器和Bean</title>
      <link href="/2020/07/11/Spring/Core/IOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/07/11/Spring/Core/IOC%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-IOC-容器"><a href="#1-IOC-容器" class="headerlink" title="1 IOC 容器"></a>1 IOC 容器</h3><p>概念 ： IOC 容器（container）是 Spring 框架的核心，它管理着 Spring 应用中 bean 的创建、 配置和管理，负责对象的整个生命周期。</p><h4 id="1-1-容器实现"><a href="#1-1-容器实现" class="headerlink" title="1.1 容器实现"></a>1.1 容器实现</h4><h5 id="1）BeanFactory"><a href="#1）BeanFactory" class="headerlink" title="1）BeanFactory"></a>1）BeanFactory</h5><p>最简单的容器，提供基本的 DI 支持。使用控制反转将应用的配置和依赖与实际的应用代码分离开来。</p><p>第一次访问某一 Bean 时才实例化它。</p><h5 id="2）ApplicationContext"><a href="#2）ApplicationContext" class="headerlink" title="2）ApplicationContext"></a>2）ApplicationContext</h5><p>基于 BeanFactory 构建， 并提供应用框架级别的服务。</p><p>初始化容器时就实例化所有单例的 Bean。</p><p>有多种 ApplicationContext 的实现， 每一种都提供了配置 Spring 的不同方式。</p><h5 id="3）Bean-Factory-和-ApplicationContext-的区别"><a href="#3）Bean-Factory-和-ApplicationContext-的区别" class="headerlink" title="3）Bean Factory 和 ApplicationContext 的区别"></a>3）Bean Factory 和 ApplicationContext 的区别</h5><p>ApplicationContext 提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。</p><p>另外，容器或者容器中 beans 的操作，这些必须以 Bean Factory 的编程方式处理的操作可以在 ApplicationContext 中以声明的方式处理。</p><p><strong>这两者的继承关系如下：</strong></p><p><img src="https://imine141.github.io/images/ioc%E7%BB%A7%E6%89%BF%E5%9B%BE2.png" alt=""></p><h4 id="1-2-getBean"><a href="#1-2-getBean" class="headerlink" title="1.2 getBean()"></a>1.2 getBean()</h4><p>通过容器 getBean() 方法从容器获取指定 bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">xxx xxxobj = applicationContext.getBean(xxx<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-Spring-Bean"><a href="#2-Spring-Bean" class="headerlink" title="2 Spring Bean"></a>2 Spring Bean</h3><h3 id="2-1-Spring-Bean-定义"><a href="#2-1-Spring-Bean-定义" class="headerlink" title="2.1 Spring Bean 定义"></a>2.1 Spring Bean 定义</h3><p><strong>什么是Bean？</strong></p><p>由于Java语言欠缺属性、事件、多重继承功能，如果在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。简而言之，Bean就是一个具有规范的Java类</p><p>在spring中。这些bean对象由 Spring IOC 容器实例化、组装、管理。</p><p>Spring Bean 中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p><h4 id="2-2-定义-bean-的作用域"><a href="#2-2-定义-bean-的作用域" class="headerlink" title="2.2 定义 bean 的作用域"></a>2.2 定义 bean 的作用域</h4><p>在 Spring 中创建一个 bean 的时候，我们可以通过“scope”属性声明它的作用域。</p><p>Spring 中的 bean 默认都是单例（singleton）的，这对可变类型是非线程安全的。</p><p>Spring 定义了几种 bean 的作用域：</p><ul><li>Singleton：单例。在 Spring IOC 容器中仅存在一个 Bean 实例，Bean 以单实例的方式存在。</li><li>Prototype：原型。每次被装配时，都会创建一个新的实例。</li><li>Request：在 WebApplicationContext 中，在每次 http 请求中创建一个 bean 的实例。</li><li>Session：在 WebApplicationContext 中，在每次 HTTP Session 过程中只创建一个 bean 的实例；</li><li>GlobalSession：在 WebApplicationContext 中，在同一个全局 HTTP Session 只创建一个 Bean 的实例</li></ul><h3 id="3-Bean-的生命周期"><a href="#3-Bean-的生命周期" class="headerlink" title="3 Bean 的生命周期"></a>3 Bean 的生命周期</h3><p>对于普通的 Java 对象，当 new 的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。而由 Spring IoC 容器托管的对象，它们的生命周期完全由容器控制。</p><p>Spring 只管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p><p><img src="https://imine141.github.io/images/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" alt="bean的生命周期"></p><p>BeanFactory 负责 bean 创建的最初四步，然后移交给 ApplicationContext 做后续创建过程</p><h4 id="3-1-实例化"><a href="#3-1-实例化" class="headerlink" title="3.1 实例化"></a>3.1 实例化</h4><p>Spring 容器（从 XML 文件、注解、Java 配置文件）读取 bean 的定义并实例化 bean。</p><ul><li>对于 BeanFactory 容器：当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。</li><li>对于 ApplicationContext 容器：当容器启动结束后，便实例化所有的 bean。</li></ul><p>容器通过获取 BeanDefinition 对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。</p><p>实例化对象被包装在 BeanWrapper 对象中，BeanWrapper 提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h4 id="3-2-属性填充（依赖注入）"><a href="#3-2-属性填充（依赖注入）" class="headerlink" title="3.2 属性填充（依赖注入）"></a>3.2 属性填充（依赖注入）</h4><p>实例化后的对象被封装在 BeanWrapper 对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。</p><p>紧接着，Spring 根据 BeanDefinition 中的信息进行依赖注入。</p><p>并且通过 BeanWrapper 提供的设置属性的接口完成依赖注入。</p><h4 id="3-3-注入-Aware-接口"><a href="#3-3-注入-Aware-接口" class="headerlink" title="3.3 注入 Aware 接口"></a>3.3 注入 Aware 接口</h4><p>紧接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 bean。</p><ul><li>如果该 Bean 实现了 BeanNameAware 接口，Spring 将 bean 的 id 传递给 setBeanName() 方法。</li><li>如果该 Bean 实现了 BeanFactoryAware 接口，Spring 将 BeanFactory 传递给 setBeanFactory() 方法。</li><li>如果该 Bean 实现了 ApplicationContextAware 接口，Spring 将 ApplicationContext 传递给 setApplicationContext() 方法。</li></ul><p>xxxAware 接口可以用于在初始化 bean 时获得 Spring 中的一些对象，如获取 Spring 上下文等。</p><h4 id="3-4-BeanPostProcessor"><a href="#3-4-BeanPostProcessor" class="headerlink" title="3.4 BeanPostProcessor"></a>3.4 BeanPostProcessor</h4><p>当经过上述几个步骤后，bean 对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过 BeanPostProcessor 接口实现。</p><p>该接口提供了两个函数：</p><ul><li>postProcessBeforeInitialzation( Object bean, String beanName )<ul><li>当前正在初始化的 bean 对象会被传递进来，我们就可以对这个 bean 作任何处理。</li><li>这个函数会先于 InitialzationBean 执行，因此称为“前置处理”。</li><li>所有 Aware 接口的注入就是在这一步完成的。</li></ul></li><li>postProcessAfterInitialzation( Object bean, String beanName )<ul><li>当前正在初始化的 bean 对象会被传递进来，我们就可以对这个 bean 作任何处理。</li><li>这个函数会在 InitialzationBean 完成后执行，因此称为“后置处理”。</li></ul></li></ul><h4 id="3-5-自定义初始化"><a href="#3-5-自定义初始化" class="headerlink" title="3.5 自定义初始化"></a>3.5 自定义初始化</h4><p>当 BeanPostProcessor 的“前置处理”完成后就会进入本阶段。</p><h5 id="1）InitializingBean-接口"><a href="#1）InitializingBean-接口" class="headerlink" title="1）InitializingBean 接口"></a>1）InitializingBean 接口</h5><p>InitializingBean 接口只有一个函数：afterPropertiesSet()</p><p>这一阶段也可以在 bean 正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前 bean 对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。</p><p>若要使用它，我们需要让 bean 实现该接口，并把要增加的逻辑写在该函数中。</p><p>Spring 会在前置处理完成后检测当前 bean 是否实现了 InitializingBean 接口，并执行 afterPropertiesSet 函数。</p><h5 id="2）init-method-属性"><a href="#2）init-method-属性" class="headerlink" title="2）init-method 属性"></a>2）init-method 属性</h5><p>Spring 为了降低对客户代码的侵入性，给 bean 的配置提供了 init-method 属性，该属性指定了在这一阶段需要执行的函数名。</p><p>Spring 便会在初始化阶段执行我们设置的函数。init-method 本质上仍然使用了 InitializingBean 接口。</p><h5 id="3）-PostConstruct-注解"><a href="#3）-PostConstruct-注解" class="headerlink" title="3）@PostConstruct 注解"></a>3）@PostConstruct 注解</h5><p>对象构建之后调用</p><h4 id="3-6-自定义销毁"><a href="#3-6-自定义销毁" class="headerlink" title="3.6 自定义销毁"></a>3.6 自定义销毁</h4><p>当 BeanPostProcessor 的“后置处理”完成后就会进入本阶段。</p><h5 id="1）DisposableBean-接口"><a href="#1）DisposableBean-接口" class="headerlink" title="1）DisposableBean 接口"></a>1）DisposableBean 接口</h5><p>如果该 bean 实现了 DisposableBean，调用 destroy() 方法。</p><h5 id="2）destroy-method-属性"><a href="#2）destroy-method-属性" class="headerlink" title="2）destroy-method 属性"></a>2）destroy-method 属性</h5><p>和 init-method 一样，通过给 destroy-method 指定函数，就可以在 bean 销毁前执行指定的逻辑。</p><h5 id="3）-PreDestroy-注解"><a href="#3）-PreDestroy-注解" class="headerlink" title="3）@PreDestroy 注解"></a>3）@PreDestroy 注解</h5><p>对象移除之前调用</p><p><strong>如果想从源码的角度再深入了解IOC这块，推荐看这篇文章</strong></p><p> <a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">https://javadoop.com/post/spring-ioc</a> </p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring基础</title>
      <link href="/2020/07/10/Spring/Core/spring%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/10/Spring/Core/spring%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。</p><h3 id="1-Spring-基本理念"><a href="#1-Spring-基本理念" class="headerlink" title="1 Spring 基本理念"></a>1 Spring 基本理念</h3><p>简化 Java 开发</p><ul><li>轻量级：基础版本的 Spring 框架大约只有 2 MB。</li><li>容器：Spring 包含并管理应用程序对象的配置及生命周期。</li><li>控制反转(IOC)：松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。</li><li>面向切面编程(AOP)： 把应用的业务逻辑与系统的服务分离开来。消除样板式代码.</li></ul><h3 id="2-Spring-基本原理"><a href="#2-Spring-基本原理" class="headerlink" title="2 Spring 基本原理"></a>2 Spring 基本原理</h3><ol><li>启动项目后，按照配置找到要 scan 的包（自动装配）</li><li>解析包里面的所有类，找到所有含有 @bean，@service 等注解的类，利用反射解析，封装成各种信息类放到容器（map 实现）里。</li><li>需要 bean 时，从容器里找。找到则通过构造器 new 出来（控制反转），没找到则抛出异常</li><li>如果类中有需要注入的，仍从 container 寻找、解析类，new 出对象，用 setter 注入（依赖注入）。</li><li>嵌套 bean 用了递归，container 会放到 servletcontext 里，每次 request 从 servletcontext 找 container。</li><li>如果 bean 的 scope 是 singleton，会重用，将这个 bean 放到一个 map 里，每次用都先从这个 map 里面找。</li><li>如果 scope 是 session，则该 bean 会放到 session 里面。</li></ol><h3 id="3-Spring-模块"><a href="#3-Spring-模块" class="headerlink" title="3 Spring 模块"></a>3 Spring 模块</h3><p>Spring 4.0 有 20 个模块，这些模块依据其所属的功能可以划分为 6 类不同的功能</p><p><img src="https://imine141.github.io/images/1545011849499.png" alt=""></p><h4 id="3-1-Spring-核心容器"><a href="#3-1-Spring-核心容器" class="headerlink" title="3.1 Spring 核心容器"></a>3.1 Spring 核心容器</h4><p>最核心的部分。除了 BeanFactory 和 ApplicationContext，还提供 E-mail、 JNDI 访问、 EJB 集成和调度等服务。所有的 Spring 模块都构建于核心容器之上</p><h4 id="3-2-面向切面编程"><a href="#3-2-面向切面编程" class="headerlink" title="3.2 面向切面编程"></a>3.2 面向切面编程</h4><p>开发切面的基础。借助于 AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。</p><h4 id="3-3-数据访问与集成"><a href="#3-3-数据访问与集成" class="headerlink" title="3.3 数据访问与集成"></a>3.3 数据访问与集成</h4><p>JDBC 和 data-access object 模块封装了样板式代码和异常。</p><p>集成了许多流行的 ORM。支持事务管理。</p><h5 id="1）JDBC-和-DAO"><a href="#1）JDBC-和-DAO" class="headerlink" title="1）JDBC 和 DAO"></a>1）JDBC 和 DAO</h5><p>JDBC 和 DAO（data-access object）模块封装了样板式代码和异常，保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。</p><p>它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用 Spring 的 AOP 模块为 Spring 应用程序中的对象提供事务管理服务。</p><h5 id="2）ORM"><a href="#2）ORM" class="headerlink" title="2）ORM"></a>2）ORM</h5><p>Spring 通过提供对象/关系映射集成（ORM）模块在 JDBC 的基础上支持对象关系映射工具。</p><p>这样的支持使得 Spring 可以集成主流的 ORM 框架，包括 Hibernate, JDO, 及 iBATIS SQL Maps。Spring 的事务管理可以同时支持以上某种框架和 JDBC。</p><h4 id="3-4-Web-与远程调用"><a href="#3-4-Web-与远程调用" class="headerlink" title="3.4 Web 与远程调用"></a>3.4 Web 与远程调用</h4><p>Spring 的 web 模块建立在应用上下文(application context)模块之上，提供了一个适合基于 web 应用程序的上下文环境。该模块还支持了几个面向 web 的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。</p><h5 id="1）Spring-MVC"><a href="#1）Spring-MVC" class="headerlink" title="1）Spring MVC"></a>1）Spring MVC</h5><p>Spring 可以很轻松的同其他 MVC 框架结合，但 Spring 的 MVC 是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。通过 DispatcherServlet, ModelAndView 和 View Resolver，开发 web 应用变得很容易。</p><h5 id="2）HTTP-invoker"><a href="#2）HTTP-invoker" class="headerlink" title="2）HTTP invoker"></a>2）HTTP invoker</h5><p>自带远程调用框架。提供了暴露和使用 REST API 的良好支持。还能集成多种流行远程调用框架。</p><h4 id="3-5-Instrumentation"><a href="#3-5-Instrumentation" class="headerlink" title="3.5 Instrumentation"></a>3.5 Instrumentation</h4><p>提供为 JVM 添加代理的功能。为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。</p><h4 id="3-6-测试"><a href="#3-6-测试" class="headerlink" title="3.6 测试"></a>3.6 测试</h4><p>可以与常用的 JUNIT、Mockito、Spock 等测试框架整合使用。</p><p>为使用 JNDI、 Servlet 和 Portlet 编写单元测试提供了一系列的 mock 对象实现。加载 Spring 应用上下文中的 bean 集合以及与 Spring 上下文中的 bean 进行交互提供了支持。</p><h3 id="4-Spring-社区经典项目"><a href="#4-Spring-社区经典项目" class="headerlink" title="4 Spring 社区经典项目"></a>4 Spring 社区经典项目</h3><h4 id="4-1-Spring-Security"><a href="#4-1-Spring-Security" class="headerlink" title="4.1 Spring Security"></a>4.1 Spring Security</h4><p>安全对于许多应用都是一个非常关键的切面。 利用 Spring AOP， 为 Spring 应用提供了声明式的安全机制。</p><h4 id="4-2-Spring-Data"><a href="#4-2-Spring-Data" class="headerlink" title="4.2 Spring Data"></a>4.2 Spring Data</h4><p>使得在 Spring 中使用任何数据库都变得非常容易。 不管使用文档数据库， 还是关系型数据库，Spring Data 都为持久化提供了一种简单的编程模型。包括为多种数据库类型提供了一种自动化的 Repository 机制。</p><h4 id="4-3-Spring-Boot"><a href="#4-3-Spring-Boot" class="headerlink" title="4.3 Spring Boot"></a>4.3 Spring Boot</h4><p>Spring Boot 主要是为了解决使用 Spring 框架需要进行大量的配置太麻烦的问题，所以它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>Spring Boot 大量依赖于自动配置（auto-configuration）技术，它能够消除大部分 Spring 配置。它还提供了多个 Starter 项目，降低了项目搭建的复杂度。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Durid实战</title>
      <link href="/2020/06/03/%E5%AE%9E%E6%88%98/Druid/"/>
      <url>/2020/06/03/%E5%AE%9E%E6%88%98/Druid/</url>
      
        <content type="html"><![CDATA[<h3 id="Druid简介"><a href="#Druid简介" class="headerlink" title="Druid简介"></a>Druid简介</h3><p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p><p>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</p><h3 id="一、配置单数据源"><a href="#一、配置单数据源" class="headerlink" title="一、配置单数据源"></a>一、配置单数据源</h3><p>1.添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.yaml配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/erp_ydh?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxx</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span> <span class="comment"># 自定义数据源</span></span><br></pre></td></tr></table></figure><h3 id="二、配置多数据源"><a href="#二、配置多数据源" class="headerlink" title="二、配置多数据源"></a>二、配置多数据源</h3>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
