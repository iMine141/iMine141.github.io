<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="类"><meta name="keywords" content="java"><meta name="author" content="iMine"><meta name="copyright" content="iMine"><title>类 | iMineのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 7.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB"><span class="toc-text">1 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">1.1 类之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">1.2 构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-finalize-%E6%96%B9%E6%B3%95"><span class="toc-text">1.3 finalize 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Object%EF%BC%9A%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB"><span class="toc-text">1.4 Object：所有类的超类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89equals-%E6%96%B9%E6%B3%95"><span class="toc-text">1）equals()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB"><span class="toc-text">等价关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E4%B8%8E%E7%9B%B8%E7%AD%89"><span class="toc-text">等价与相等</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89hashCode"><span class="toc-text">2）hashCode()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89toString"><span class="toc-text">3）toString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89clone"><span class="toc-text">4）clone()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">1.5 枚举类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.1 创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-text">2.2 对象克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">2.3 序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95"><span class="toc-text">3 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="toc-text">3.1 方法签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-text">3.2 隐式参数与显式参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-text">3.3 方法参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.4 参数变量可变的方法</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">iMine</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">74</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iMineのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">类</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">对象与类</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="1-类"><a href="#1-类" class="headerlink" title="1 类"></a>1 类</h3><p>类是构造对象的模板。</p>
<p>由类构造对象的过程称为创建类的实例。</p>
<p>一个源文件中，只能有一个公共类，类名必须与文件名相同。</p>
<h4 id="1-1-类之间的关系"><a href="#1-1-类之间的关系" class="headerlink" title="1.1 类之间的关系"></a>1.1 类之间的关系</h4><p>最常见的关系有：</p>
<ol>
<li>依赖（uses-a）：一个类的方法需要操纵另一个类的对象</li>
<li>聚合（has-a）：类 A 的对象包含着类 B 的对象</li>
<li>继承（is-a）：继承是一种用于表示特殊与一般的关系，父类更一般</li>
</ol>
<p>应该尽可能地将相互依赖的类减至最少。</p>
<h4 id="1-2-构造器"><a href="#1-2-构造器" class="headerlink" title="1.2 构造器"></a>1.2 构造器</h4><ol>
<li>构造器和类名同名，参数不限，没有返回值。</li>
<li>构造器中的局部变量会覆盖同名实例域。</li>
<li>若未手动编写构造器，会默认提供一个无参构造器，设默认值。手动提供构造器后，不会自动提供无参构造器。</li>
<li>构造器不能被继承，因此不能被重写，但可以被重载。</li>
<li>父类与子类的构造函数调用次序：若子类构造器没有显式调用父类构造器，不管子类构造器有无参数，都默认调用父类无参构造器。</li>
</ol>
<h4 id="1-3-finalize-方法"><a href="#1-3-finalize-方法" class="headerlink" title="1.3 finalize 方法"></a>1.3 finalize 方法</h4><p>可以为任何一个类添加 finalize 方法，将在垃圾回收器清除对象之前调用。不要依赖，不能保证被调用。</p>
<h4 id="1-4-Object：所有类的超类"><a href="#1-4-Object：所有类的超类" class="headerlink" title="1.4 Object：所有类的超类"></a>1.4 Object：所有类的超类</h4><p>如果重新定义 equals 方法，就必须重新定义 hashCode 方法。eauals 与 hashCode 的定义必须一致：如果 x.eauals(y) 返回 true，那么 x.hashCode() 必须与 y.hashCode() 具有相同的值。</p>
<h5 id="1）equals-方法"><a href="#1）equals-方法" class="headerlink" title="1）equals()方法"></a>1）equals()方法</h5><h6 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h6><p>两个对象具有等价关系，需要满足以下五个条件：</p>
<ul>
<li><p>自反性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对称性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一致性</p>
<ul>
<li>多次调用 equals() 方法结果不变</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与 null 的比较</p>
<ul>
<li>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(<span class="literal">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="等价与相等"><a href="#等价与相等" class="headerlink" title="等价与相等"></a>等价与相等</h6><ul>
<li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<h5 id="2）hashCode"><a href="#2）hashCode" class="headerlink" title="2）hashCode()"></a>2）hashCode()</h5><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p>
<h5 id="3）toString"><a href="#3）toString" class="headerlink" title="3）toString()"></a>3）toString()</h5><p>默认返回 ClassName@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<h5 id="4）clone"><a href="#4）clone" class="headerlink" title="4）clone()"></a>4）clone()</h5><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<p>clone() 方法并不是 Cloneable 接口的方法，Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<ul>
<li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</li>
<li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。</li>
</ul>
<h4 id="1-5-枚举类"><a href="#1-5-枚举类" class="headerlink" title="1.5 枚举类"></a>1.5 枚举类</h4><p>枚举类定义的是一个类，有着指定的几个实例。<br>比较两个枚举类型的值时，不需要调用 equals 方法，而直接使用”&#x3D;&#x3D;”就可以了。</p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2 对象"></a>2 对象</h3><h4 id="2-1-创建对象"><a href="#2-1-创建对象" class="headerlink" title="2.1 创建对象"></a>2.1 创建对象</h4><ol>
<li>用 new 语句创建对象</li>
<li>运用反射</li>
<li>调用对象的 clone() 方法</li>
<li>运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject() 方法</li>
</ol>
<p>(1) 和 (2) 都会明确的显式的调用构造函数；(3) 是在内存上对已有对象的影印，所以不会调用构造函数；(4) 是从文件中还原类的对象，也不会调用构造函数。</p>
<h4 id="2-2-对象克隆"><a href="#2-2-对象克隆" class="headerlink" title="2.2 对象克隆"></a>2.2 对象克隆</h4><p>有两种方式：</p>
<ul>
<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法；</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>
</ul>
<h4 id="2-3-序列化"><a href="#2-3-序列化" class="headerlink" title="2.3 序列化"></a>2.3 序列化</h4><ul>
<li>对象序列化（Serializable）是指将对象转换为字节序列的过程，而反序列化则是根据字节序列恢复对象的过程。只有实现了 Serializable 和 Externalizable 接口的类的对象才能被序列化。</li>
<li>java.io.ObjectOutputStream 代表对象输出流，它的 writeObject(Objectobj) 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</li>
<li>java.io.ObjectInputStream 代表对象输入流，它的 readObject() 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</li>
</ul>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><h4 id="3-1-方法签名"><a href="#3-1-方法签名" class="headerlink" title="3.1 方法签名"></a>3.1 方法签名</h4><p>方法签名只有<strong>方法名</strong>和<strong>参数</strong>，没有返回值。也就是说，不能有两个名字相同、参数也相同而返回值不同的方法。</p>
<h4 id="3-2-隐式参数与显式参数"><a href="#3-2-隐式参数与显式参数" class="headerlink" title="3.2 隐式参数与显式参数"></a>3.2 隐式参数与显式参数</h4><p>隐式参数是出现在方法名前的类对象（this），显式参数位于方法名后面的括号中。</p>
<p>使用 this 可以区分开隐式参数的类对象的实例域和局部变量</p>
<h4 id="3-3-方法参数"><a href="#3-3-方法参数" class="headerlink" title="3.3 方法参数"></a>3.3 方法参数</h4><p>Java 方法参数是<strong>值传递</strong>，不是引用传递。</p>
<p>方法在执行时，先定义了局部变量，这些局部变量指向，传入参数的指向。对局部变量重新指向时，完全不影响原本传入参数的那些指向。</p>
<ul>
<li>值传递：方法接收的是调用者提供的值。</li>
<li>引用传递：方法接受的是调用所对应的变量地址。</li>
</ul>
<h4 id="3-4-参数变量可变的方法"><a href="#3-4-参数变量可变的方法" class="headerlink" title="3.4 参数变量可变的方法"></a>3.4 参数变量可变的方法</h4><p>Object… 参数类型与 Object[] 完全一样，省略号表明这个方法可以接收任意数量的的对象。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">iMine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://imine141.github.io/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E7%B1%BB/">https://imine141.github.io/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E7%B1%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"><i class="fa fa-chevron-left">  </i><span>修饰符</span></a></div><div class="next-post pull-right"><a href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><span>面向对象</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2024 By iMine</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>