<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Pulsar订阅进度同步原理"><meta name="keywords" content="pulsar"><meta name="author" content="iMine"><meta name="copyright" content="iMine"><title>Pulsar订阅进度同步原理 | iMineのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?434d6055a3a5266f2c2a21749e588070";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#描述"><span class="toc-text">描述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#具体方法"><span class="toc-text">具体方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#集群A发布一个快照通知"><span class="toc-text">集群A发布一个快照通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集群B和C收到通知"><span class="toc-text">集群B和C收到通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集群A建立本集群和集群B、C间消费ID的关联关系"><span class="toc-text">集群A建立本集群和集群B、C间消费ID的关联关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建快照缓存"><span class="toc-text">创建快照缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集群A更新进度"><span class="toc-text">集群A更新进度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集群B和C更新进度"><span class="toc-text">集群B和C更新进度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他说明"><span class="toc-text">其他说明</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">iMine</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/iMine141" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">73</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://github.com/iMine141" target="_blank" rel="noopener">iMine</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iMineのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Pulsar订阅进度同步原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/pulsar/">pulsar</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>Reading time: 15 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>Pulsar自带的跨集群数据复制，可以把一个集群收到的消息复制到其他集群上，这样消费者正在连接的集群挂掉后，可以从其他集群消费消息。</p>
<p>除了消息的复制，pulsar还支持订阅进度的同步，具体场景如下：</p>
<p>部署了三个集群A、B、C，并设置集群之间的消息两两复制。消费者A刚开始从集群A消费消息，当集群A挂掉后，消费者A切换到集群B消费消息，这时候消费者A不需要从头开始读取集群B上的消息，而是可以从上一次在集群A上消费失败的位置继续从集群B上消费消息。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>集群间的消息复制是通过内置生产者和消费者实现的，接收消息的集群上会启动一个消息读取进程，读取发送到该集群的消息，然后通过客户端接口发送到其他集群上。</p>
<p>也就是说消息的复制并不是直接把bookie中的存储文件复制到其他集群上，而是使用内置的订阅名称读取本地消息，然后发送到其他集群。这样的话，两个集群的消息元数据就不是一样的，同一条消息在多个集群的消息ID是不一样的。</p>
<p>所以如果想实现订阅进度的同步，需要把同一条消息在多个集群的消息ID关联上，然后在各个集群间同步上次消费完毕的消息ID，这样不同集群之间就都知道消费者上次消费确认的位置并能够移动本集群的消费位点了。</p>
<p>所以实现订阅进度同步的关键点在于</p>
<ul>
<li><p>集群间能相互通信</p>
</li>
<li><p>同一条消息在多集群间的关联关系</p>
</li>
<li><p>消费进度更新时能及时通知到其他集群</p>
</li>
</ul>
<h1 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h1><p>Pulsar本身的消息同步并不是实时的、严格的同步，只是避免大范围的重复消费，还是会有一小段消息的重复。</p>
<p>Pulsar订阅进度同步的流程</p>
<ul>
<li><p>发布快照通知给其他集群。</p>
</li>
<li><p>其他集群收到通知后，记录本集群的LAC指针并发送给开启同步流程的集群。</p>
</li>
<li><p>开启流程的集群收到其他所有集群的返回消息后，分别建立其他集群LAC和本集群上一次消息ID的关联关系。</p>
</li>
<li><p>开启流程的集群建立好消息的ID的关联关系后，生成一个快照消息，并插入到消息队列中。</p>
</li>
<li><p>消费者返回确认后，会根据消息ID检测上一个快照，找到后就说明消费位置已经超过快照了，需要通知其他消费者更新消费位置了。</p>
</li>
<li><p>其他集群收到位置更新通知后更新本集群的消费位置。</p>
</li>
</ul>
<p>下面以某个场景详细说明下。</p>
<p>场景描述：</p>
<p>集群A、B、C三个集群互相同步消息，生产者都发送消息到集群A上。</p>
<h2 id="集群A发布一个快照通知"><a href="#集群A发布一个快照通知" class="headerlink" title="集群A发布一个快照通知"></a>集群A发布一个快照通知</h2><p>创建Topic时会检测是否需要同步订阅进度，如果需要则通过ReplicatedSubscriptionsController启动一个定时任务，任务的功能就是发送一个通知，代码如下：</p>
<p><strong>ReplicatedSubscriptionsController</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startNewSnapshot() &#123;</span><br><span class="line">  cleanupTimedOutSnapshots();</span><br><span class="line">  &#x2F;&#x2F; 判断是否有新消息写入了</span><br><span class="line">  if (topic.getLastDataMessagePublishedTimestamp() &lt; lastCompletedSnapshotStartTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; There was no message written since the last snapshot, we can skip creating a new snapshot</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(&quot;[&#123;&#125;] There is no new data in topic. Skipping snapshot creation.&quot;, topic.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MutableBoolean anyReplicatorDisconnected &#x3D; new MutableBoolean();</span><br><span class="line">  topic.getReplicators().forEach((cluster, replicator) -&gt; &#123;</span><br><span class="line">    if (!replicator.isConnected()) &#123;</span><br><span class="line">      anyReplicatorDisconnected.setTrue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当所有集群都正常时才会发送通知。</span><br><span class="line">  if (anyReplicatorDisconnected.isTrue()) &#123;</span><br><span class="line">    &#x2F;&#x2F; Do not attempt to create snapshot when some of the clusters are not reachable</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(&quot;[&#123;&#125;] Do not attempt to create snapshot when some of the clusters are not reachable.&quot;,</span><br><span class="line">          topic.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Starting snapshot creation.&quot;, topic.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pendingSnapshotsMetric.inc();</span><br><span class="line">  ReplicatedSubscriptionsSnapshotBuilder builder &#x3D; new ReplicatedSubscriptionsSnapshotBuilder(this,</span><br><span class="line">      topic.getReplicators().keys(), topic.getBrokerService().pulsar().getConfiguration(), Clock.systemUTC());</span><br><span class="line">  pendingSnapshots.put(builder.getSnapshotId(), builder);</span><br><span class="line">    &#x2F;&#x2F; 这里只是通过往该Topic写入一条消息，消息中包含通知ID。</span><br><span class="line">  builder.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ReplicatedSubscriptionsSnapshotBuilder</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void start() &#123;</span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Starting new snapshot &#123;&#125; - Clusters: &#123;&#125;&quot;, controller.topic().getName(), snapshotId,</span><br><span class="line">        missingClusters);</span><br><span class="line">  &#125;</span><br><span class="line">  startTimeMillis &#x3D; clock.millis();</span><br><span class="line">    &#x2F;&#x2F; 设置通知ID（快照ID）和本集群名称。</span><br><span class="line">  controller.writeMarker(</span><br><span class="line">      Markers.newReplicatedSubscriptionsSnapshotRequest(snapshotId, controller.localCluster()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集群B和C收到通知"><a href="#集群B和C收到通知" class="headerlink" title="集群B和C收到通知"></a>集群B和C收到通知</h2><p>集群A写入消息到该Topic后，该条消息会和其他消息一样发送到集群B和集群C上。</p>
<p>由于集群间是相互复制消息，所以集群B和C的复制模块能够读取到该消息，并作相应的处理。</p>
<p><strong>PersistentReplicator</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void checkReplicatedSubscriptionMarker(Position position, MessageImpl&lt;?&gt; msg, ByteBuf payload) &#123;</span><br><span class="line">  if (!msg.getMessageBuilder().hasMarkerType()) &#123;</span><br><span class="line">    &#x2F;&#x2F; No marker is defined</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int markerType &#x3D; msg.getMessageBuilder().getMarkerType();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里确保只处理消息发送方集群发送的消息，即只处理集群A发送的消息。</span><br><span class="line">  if (!(msg.getMessageBuilder().hasReplicatedFrom()</span><br><span class="line">      &amp;&amp; remoteCluster.equals(msg.getMessageBuilder().getReplicatedFrom()))) &#123;</span><br><span class="line">    &#x2F;&#x2F; Only consider markers that are coming from the same cluster that this</span><br><span class="line">    &#x2F;&#x2F; replicator instance is assigned to.</span><br><span class="line">    &#x2F;&#x2F; All the replicators will see all the markers, but we need to only process</span><br><span class="line">    &#x2F;&#x2F; it once.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 需要处理的消息包含三类：通知、通知应答、消费位置更新。</span><br><span class="line">  switch (markerType) &#123;</span><br><span class="line">  case MarkerType.REPLICATED_SUBSCRIPTION_SNAPSHOT_REQUEST_VALUE:</span><br><span class="line">  case MarkerType.REPLICATED_SUBSCRIPTION_SNAPSHOT_RESPONSE_VALUE:</span><br><span class="line">  case MarkerType.REPLICATED_SUBSCRIPTION_UPDATE_VALUE:</span><br><span class="line">    topic.receivedReplicatedSubscriptionMarker(position, markerType, payload);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  default:</span><br><span class="line">    &#x2F;&#x2F; Do nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>收到通知后，会获取LAC，然后封装LAC，写入到该Topic中。</p>
<p><strong>ReplicatedSubscriptionsController</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void receivedSnapshotRequest(ReplicatedSubscriptionsSnapshotRequest request) &#123;</span><br><span class="line">  &#x2F;&#x2F; if replicator producer is already closed, restart it to send snapshot response</span><br><span class="line">  Replicator replicator &#x3D; topic.getReplicators().get(request.getSourceCluster());</span><br><span class="line">  if (!replicator.isConnected()) &#123;</span><br><span class="line">    topic.startReplProducers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Send response containing the current last written message id. The response</span><br><span class="line">  &#x2F;&#x2F; marker we&#39;re publishing locally and then replicating will have a higher</span><br><span class="line">  &#x2F;&#x2F; message id.</span><br><span class="line">    &#x2F;&#x2F; 得到集群上次写入的消息</span><br><span class="line">  PositionImpl lastMsgId &#x3D; (PositionImpl) topic.getLastPosition();</span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Received snapshot request. Last msg id: &#123;&#125;&quot;, topic.getName(), lastMsgId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 把消息ID连同通知ID一起写入到Topic中。</span><br><span class="line">  ByteBuf marker &#x3D; Markers.newReplicatedSubscriptionsSnapshotResponse(</span><br><span class="line">      request.getSnapshotId(),</span><br><span class="line">      request.getSourceCluster(),</span><br><span class="line">      localCluster,</span><br><span class="line">      lastMsgId.getLedgerId(), lastMsgId.getEntryId());</span><br><span class="line">  writeMarker(marker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集群A建立本集群和集群B、C间消费ID的关联关系"><a href="#集群A建立本集群和集群B、C间消费ID的关联关系" class="headerlink" title="集群A建立本集群和集群B、C间消费ID的关联关系"></a>集群A建立本集群和集群B、C间消费ID的关联关系</h2><p>集群B和C写入的消息会被集群B和C的复制模块发送到集群A，集群A的复制模块会读到该消息并做相应的处理。</p>
<p><strong>ReplicatedSubscriptionsController</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void receivedSnapshotResponse(Position position, ReplicatedSubscriptionsSnapshotResponse response) &#123;</span><br><span class="line">  String snapshotId &#x3D; response.getSnapshotId();</span><br><span class="line">  ReplicatedSubscriptionsSnapshotBuilder builder &#x3D; pendingSnapshots.get(snapshotId);</span><br><span class="line">  if (builder &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(&quot;[&#123;&#125;] Received late reply for timed-out snapshot &#123;&#125; from &#123;&#125;&quot;, topic.getName(), snapshotId,</span><br><span class="line">          response.getCluster().getCluster());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  builder.receivedSnapshotResponse(position, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ReplicatedSubscriptionsSnapshotBuilder</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该Position是集群A和B返回的消息在集群A上的Position。</span><br><span class="line">synchronized void receivedSnapshotResponse(Position position, ReplicatedSubscriptionsSnapshotResponse response) &#123;</span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Received response from &#123;&#125;&quot;, controller.topic().getName(),</span><br><span class="line">        response.getCluster().getCluster());</span><br><span class="line">  &#125;</span><br><span class="line">  String cluster &#x3D; response.getCluster().getCluster();</span><br><span class="line">    &#x2F;&#x2F; Response中包含集群A&#x2F;集群B中的LAC消息。</span><br><span class="line">  responses.putIfAbsent(cluster, new MarkersMessageIdData().copyFrom(response.getCluster().getMessageId()));</span><br><span class="line">  missingClusters.remove(cluster);</span><br><span class="line"></span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Missing clusters &#123;&#125;&quot;, controller.topic().getName(), missingClusters);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!missingClusters.isEmpty()) &#123;</span><br><span class="line">    &#x2F;&#x2F; We&#39;re still waiting for more responses to come back</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; We have now received all responses</span><br><span class="line">  &#x2F;&#x2F; 如果超过两个集群需要两次通知，这里没看懂为啥...</span><br><span class="line">  if (needTwoRounds &amp;&amp; !firstRoundComplete) &#123;</span><br><span class="line">    &#x2F;&#x2F; Mark that 1st round is done and start a 2nd round</span><br><span class="line">    firstRoundComplete &#x3D; true;</span><br><span class="line">    missingClusters.addAll(remoteClusters);</span><br><span class="line"></span><br><span class="line">    controller.writeMarker(</span><br><span class="line">        Markers.newReplicatedSubscriptionsSnapshotRequest(snapshotId, controller.localCluster()));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;] Snapshot is complete &#123;&#125;&quot;, controller.topic().getName(), snapshotId);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Snapshot is now complete, store it in the local topic</span><br><span class="line">    &#x2F;&#x2F; 这里是建立记录集群B&#x2F;集群C的LAC消息和集群A收到集群B&#x2F;集群C是保存LAC的消息的消息ID间的关联关系，而且是最后边一个消息。</span><br><span class="line">    &#x2F;&#x2F; 所以这里不能实现同一条消息在三个集群间的关联。</span><br><span class="line">  PositionImpl p &#x3D; (PositionImpl) position;</span><br><span class="line">  controller.writeMarker(</span><br><span class="line">      Markers.newReplicatedSubscriptionsSnapshot(snapshotId, controller.localCluster(),</span><br><span class="line">          p.getLedgerId(), p.getEntryId(), responses));</span><br><span class="line">  controller.snapshotCompleted(snapshotId);</span><br><span class="line"></span><br><span class="line">  double latencyMillis &#x3D; clock.millis() - startTimeMillis;</span><br><span class="line">  snapshotMetric.observe(latencyMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群A建立好关联关系后，会生成一个快照，这个快照包含各集群消息ID的关联关系、</p>
<p>然后写入到该Topic中，之后这条消息就会复制到集群B和集群C上。</p>
<h2 id="创建快照缓存"><a href="#创建快照缓存" class="headerlink" title="创建快照缓存"></a>创建快照缓存</h2><p>虽然上边的步骤已经生成快照了，但是快照的缓存并不上在上边添加的。当快照被写到Topic中，那么当消费者读取消息时就肯定能读到该快照。</p>
<p>当消息在Broker端被读到时，通过过滤器处理这些消息。</p>
<p><strong>AbstractBaseDispatcher</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int filterEntriesForConsumer(Optional&lt;EntryWrapper[]&gt; entryWrapper, int entryWrapperOffset,</span><br><span class="line">     List&lt;Entry&gt; entries, EntryBatchSizes batchSizes, SendMessageInfo sendMessageInfo,</span><br><span class="line">     EntryBatchIndexesAcks indexesAcks, ManagedCursor cursor, boolean isReplayRead) &#123;</span><br><span class="line">  int totalMessages &#x3D; 0;</span><br><span class="line">  long totalBytes &#x3D; 0;</span><br><span class="line">  int totalChunkedMessages &#x3D; 0;</span><br><span class="line">  int totalEntries &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0, entriesSize &#x3D; entries.size(); i &lt; entriesSize; i++) &#123;</span><br><span class="line">    Entry entry &#x3D; entries.get(i);</span><br><span class="line">    if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    totalEntries++;</span><br><span class="line">    ByteBuf metadataAndPayload &#x3D; entry.getDataBuffer();</span><br><span class="line">    int entryWrapperIndex &#x3D; i + entryWrapperOffset;</span><br><span class="line">    MessageMetadata msgMetadata &#x3D; entryWrapper.isPresent() &amp;&amp; entryWrapper.get()[entryWrapperIndex] !&#x3D; null</span><br><span class="line">        ? entryWrapper.get()[entryWrapperIndex].getMetadata()</span><br><span class="line">        : null;</span><br><span class="line">    msgMetadata &#x3D; msgMetadata &#x3D;&#x3D; null</span><br><span class="line">        ? Commands.peekMessageMetadata(metadataAndPayload, subscription.toString(), -1)</span><br><span class="line">        : msgMetadata;</span><br><span class="line">    if (!isReplayRead &amp;&amp; msgMetadata !&#x3D; null &amp;&amp; msgMetadata.hasTxnidMostBits()</span><br><span class="line">        &amp;&amp; msgMetadata.hasTxnidLeastBits()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 省略代码 ...</span><br><span class="line">            </span><br><span class="line">    &#125; else if (msgMetadata &#x3D;&#x3D; null || Markers.isServerOnlyMarker(msgMetadata)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里处理读到的快照消息。</span><br><span class="line">      PositionImpl pos &#x3D; (PositionImpl) entry.getPosition();</span><br><span class="line">      &#x2F;&#x2F; Message metadata was corrupted or the messages was a server-only marker</span><br><span class="line"></span><br><span class="line">      if (Markers.isReplicatedSubscriptionSnapshotMarker(msgMetadata)) &#123;</span><br><span class="line">        processReplicatedSubscriptionSnapshot(pos, metadataAndPayload);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      entries.set(i, null);</span><br><span class="line">      entry.release();</span><br><span class="line">      subscription.acknowledgeMessage(Collections.singletonList(pos), AckType.Individual,</span><br><span class="line">          Collections.emptyMap());</span><br><span class="line">      continue;</span><br><span class="line">    &#125; else if (msgMetadata.hasDeliverAtTime()</span><br><span class="line">        &amp;&amp; trackDelayedDelivery(entry.getLedgerId(), entry.getEntryId(), msgMetadata)) &#123;</span><br><span class="line">      &#x2F;&#x2F; The message is marked for delayed delivery. Ignore for now.</span><br><span class="line">      entries.set(i, null);</span><br><span class="line">      entry.release();</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 省略代码 ...</span><br><span class="line">  &#125;</span><br><span class="line">  sendMessageInfo.setTotalMessages(totalMessages);</span><br><span class="line">  sendMessageInfo.setTotalBytes(totalBytes);</span><br><span class="line">  sendMessageInfo.setTotalChunkedMessages(totalChunkedMessages);</span><br><span class="line">  return totalEntries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void processReplicatedSubscriptionSnapshot(PositionImpl pos, ByteBuf headersAndPayload) &#123;</span><br><span class="line">  &#x2F;&#x2F; Remove the protobuf headers</span><br><span class="line">  Commands.skipMessageMetadata(headersAndPayload);</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    ReplicatedSubscriptionsSnapshot snapshot &#x3D; Markers.parseReplicatedSubscriptionsSnapshot(headersAndPayload);</span><br><span class="line">    subscription.processReplicatedSubscriptionSnapshot(snapshot);</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    log.warn(&quot;Failed to process replicated subscription snapshot at &#123;&#125; -- &#123;&#125;&quot;, pos, t.getMessage(), t);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PersistentSubscription</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void processReplicatedSubscriptionSnapshot(ReplicatedSubscriptionsSnapshot snapshot) &#123;</span><br><span class="line">    ReplicatedSubscriptionSnapshotCache snapshotCache &#x3D; this.replicatedSubscriptionSnapshotCache;</span><br><span class="line">    if (snapshotCache !&#x3D; null) &#123;</span><br><span class="line">        snapshotCache.addNewSnapshot(new ReplicatedSubscriptionsSnapshot().copyFrom(snapshot));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ReplicatedSubscriptionSnapshotCache</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void addNewSnapshot(ReplicatedSubscriptionsSnapshot snapshot) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里的本地消息ID，就是保存集群B&#x2F;集群C LAC消息的消息ID，且是最新的一个。</span><br><span class="line">    MarkersMessageIdData msgId &#x3D; snapshot.getLocalMessageId();</span><br><span class="line">    PositionImpl position &#x3D; new PositionImpl(msgId.getLedgerId(), msgId.getEntryId());</span><br><span class="line"></span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(&quot;[&#123;&#125;] Added new replicated-subscription snapshot at &#123;&#125; -- &#123;&#125;&quot;, subscription, position,</span><br><span class="line">                  snapshot.getSnapshotId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    snapshots.put(position, snapshot);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prune the cache</span><br><span class="line">    while (snapshots.size() &gt; maxSnapshotToCache) &#123;</span><br><span class="line">        snapshots.pollFirstEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此快照从存储中被加载到Broker内存中。</p>
<h2 id="集群A更新进度"><a href="#集群A更新进度" class="headerlink" title="集群A更新进度"></a>集群A更新进度</h2><p>当消费者订阅消息时，快照才会被加载到Broker内存里，然后消费者返回确认消息时，会查找消息ID的上一个快照。</p>
<p><strong>PersistentSubscription</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void acknowledgeMessage(List&lt;Position&gt; positions, AckType ackType, Map&lt;String, Long&gt; properties) &#123;</span><br><span class="line">  Position previousMarkDeletePosition &#x3D; cursor.getMarkDeletedPosition();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 省略代码 ... </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当可删除位置更新了（注意不能处理单独确认的消息）</span><br><span class="line">  if (!cursor.getMarkDeletedPosition().equals(previousMarkDeletePosition)) &#123;</span><br><span class="line">    this.updateLastMarkDeleteAdvancedTimestamp();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Mark delete position advance</span><br><span class="line">    ReplicatedSubscriptionSnapshotCache snapshotCache  &#x3D; this.replicatedSubscriptionSnapshotCache;</span><br><span class="line">    if (snapshotCache !&#x3D; null) &#123;</span><br><span class="line">      ReplicatedSubscriptionsSnapshot snapshot &#x3D; snapshotCache</span><br><span class="line">          .advancedMarkDeletePosition((PositionImpl) cursor.getMarkDeletedPosition());</span><br><span class="line">      if (snapshot !&#x3D; null) &#123;</span><br><span class="line">        topic.getReplicatedSubscriptionController()</span><br><span class="line">            .ifPresent(c -&gt; c.localSubscriptionUpdated(subName, snapshot));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteTransactionMarker(properties);</span><br><span class="line"></span><br><span class="line">  if (topic.getManagedLedger().isTerminated() &amp;&amp; cursor.getNumberOfEntriesInBacklog(false) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; Notify all consumer that the end of topic was reached</span><br><span class="line">    if (dispatcher !&#x3D; null) &#123;</span><br><span class="line">      dispatcher.getConsumers().forEach(Consumer::reachedEndOfTopic);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能找到快照，则说明需要更新进度了。</p>
<p>这个进度是上一次的快照进度，不是最新消费的进度。</p>
<p><strong>ReplicatedSubscriptionsController</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void localSubscriptionUpdated(String subscriptionName, ReplicatedSubscriptionsSnapshot snapshot) &#123;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(&quot;[&#123;&#125;][&#123;&#125;] Updating subscription to snapshot &#123;&#125;&quot;, topic, subscriptionName,</span><br><span class="line">                  snapshot.getClustersList().stream()</span><br><span class="line">                  .map(cmid -&gt; String.format(&quot;%s -&gt; %d:%d&quot;, cmid.getCluster(),</span><br><span class="line">                                             cmid.getMessageId().getLedgerId(), cmid.getMessageId().getEntryId()))</span><br><span class="line">                  .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, MarkersMessageIdData&gt; clusterIds &#x3D; new TreeMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0, size &#x3D; snapshot.getClustersCount(); i &lt; size; i++) &#123;</span><br><span class="line">        ClusterMessageId cmid &#x3D; snapshot.getClusterAt(i);</span><br><span class="line">        clusterIds.put(cmid.getCluster(), cmid.getMessageId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuf subscriptionUpdate &#x3D; Markers.newReplicatedSubscriptionsUpdate(subscriptionName, clusterIds);</span><br><span class="line">    writeMarker(subscriptionUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集群B和C更新进度"><a href="#集群B和C更新进度" class="headerlink" title="集群B和C更新进度"></a>集群B和C更新进度</h2><p>更新进度的消息会被写入到Topic中，这个消息也会被复制到集群B和C。</p>
<p>集群B和C中的复制模块读到消息后会做如下处理：</p>
<p><strong>ReplicatedSubscriptionsController</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void receiveSubscriptionUpdated(ReplicatedSubscriptionsUpdate update) &#123;</span><br><span class="line">  MarkersMessageIdData updatedMessageId &#x3D; null;</span><br><span class="line">  for (int i &#x3D; 0, size &#x3D; update.getClustersCount(); i &lt; size; i++) &#123;</span><br><span class="line">    ClusterMessageId cmid &#x3D; update.getClusterAt(i);</span><br><span class="line">    if (localCluster.equals(cmid.getCluster())) &#123;</span><br><span class="line">      updatedMessageId &#x3D; cmid.getMessageId();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (updatedMessageId &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; No updates for this cluster, ignore</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的消息ID是上一次的LAC。</span><br><span class="line">  Position pos &#x3D; new PositionImpl(updatedMessageId.getLedgerId(), updatedMessageId.getEntryId());</span><br><span class="line"></span><br><span class="line">  if (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(&quot;[&#123;&#125;][&#123;&#125;] Received update for subscription to &#123;&#125;&quot;, topic, update.getSubscriptionName(), pos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 更新消费者读取进度为上一次的LAC。</span><br><span class="line">  PersistentSubscription sub &#x3D; topic.getSubscription(update.getSubscriptionName());</span><br><span class="line">  if (sub !&#x3D; null) &#123;</span><br><span class="line">    sub.acknowledgeMessage(Collections.singletonList(pos), AckType.Cumulative, Collections.emptyMap());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; Subscription doesn&#39;t exist. We need to force the creation of the subscription in this cluster, because</span><br><span class="line">    log.info(&quot;[&#123;&#125;][&#123;&#125;] Creating subscription at &#123;&#125;:&#123;&#125; after receiving update from replicated subcription&quot;,</span><br><span class="line">        topic, update.getSubscriptionName(), updatedMessageId.getLedgerId(), pos);</span><br><span class="line">    topic.createSubscription(update.getSubscriptionName(),</span><br><span class="line">        InitialPosition.Latest, true &#x2F;* replicateSubscriptionState *&#x2F;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，消息进度的同步是由延迟的，而且是不是精确的。</p>
<h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><p>建立不同集群间消息ID的关联关系过程，是一个不精确的过程。集群A只是发送了一个快照通知，集群B和集群C把当前LAC发送给集群A，集群A读到这个LAC时，已经有新的消息写入到集群A了。此时集群A把集群B和集群C上次的LAC和本地集群中相对靠前的消息ID建立了关联关系。</p>
<p>比如：</p>
<p>集群A收到1、2、3三条消息，发送通知给集群B和集群C。</p>
<p>集群B读取到3后，可能有4、5、6又发送到集群B了，此时集群B发送的LAC是6。</p>
<p>集群C读取到3后，可能有4、5、6、7又发送到集群C了，此时集群C发送的LAC是7。</p>
<p>集群A读取到6后，记录下来，等待集群C的LAC。</p>
<p>集群A读取到7后，可能有8、9发送到集群A了，此时存储7的消息ID变成了10。</p>
<p>集群A建立的关联关系是10 - 6（集群B）- 7（集群C）。</p>
<p>当集群A的消费者读取到10的时候，把快照缓存到Broker的内存里，读取到11的时候，发现前边有一个快照。然后记录更新通知，写到Topic里。</p>
<p>集群B和集群C读取到快照时，会把进度分别更新到6和7，但此时消费者其实已经读取到11了。</p>
<p>按照这种解释，订阅进度永远不可能完全一致，即使集群A长时间都没收到消息了，集群B和集群C的消费进度也不会和集群A一致。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">iMine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://imine141.github.io/2021/10/15/pulsar/Pulsar%E8%AE%A2%E9%98%85%E8%BF%9B%E5%BA%A6%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/">https://imine141.github.io/2021/10/15/pulsar/Pulsar%E8%AE%A2%E9%98%85%E8%BF%9B%E5%BA%A6%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pulsar/">pulsar</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/08/07/pulsar/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/jstack%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/"><i class="fa fa-chevron-left">  </i><span>jstack分析线程运行状态</span></a></div><div class="next-post pull-right"><a href="/2021/09/14/pulsar/%E3%80%90bug%E3%80%91fastjson%E5%92%8Cjackson%E5%86%B2%E7%AA%81%E9%80%A0%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/"><span>fastjson和jackson冲突造成的数据解析问题</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '316d899c68e414a53017',
  clientSecret: 'e63edfd4dd96b3b665a0a561e2ce048c2b3f0a3b',
  repo: 'imine141.github.io',
  owner: 'imine141',
  admin: 'imine141',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2023 By iMine</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>