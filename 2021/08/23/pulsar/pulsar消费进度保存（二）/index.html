<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="pulsar消费进度保存（二）"><meta name="keywords" content="pulsar"><meta name="author" content="iMine"><meta name="copyright" content="iMine"><title>pulsar消费进度保存（二） | iMineのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?434d6055a3a5266f2c2a21749e588070";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-消息消费流程"><span class="toc-text">1. 消息消费流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-简单消息（Simple-commands）"><span class="toc-text">1.1 简单消息（Simple commands）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-内容消息（Payload-Message）"><span class="toc-text">1.2 内容消息（Payload Message）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-CRC校验"><span class="toc-text">1.2.1 CRC校验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-消息订阅和确认过程"><span class="toc-text">1.3 消息订阅和确认过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-订阅进度持久化"><span class="toc-text">2. 订阅进度持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-zk中消费进度解析"><span class="toc-text">2.1 zk中消费进度解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-bk中消费进度解析"><span class="toc-text">2.2 bk中消费进度解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-订阅进度恢复流程"><span class="toc-text">3. 订阅进度恢复流程</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">iMine</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/iMine141" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">74</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://github.com/iMine141" target="_blank" rel="noopener">iMine</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iMineのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">pulsar消费进度保存（二）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/pulsar/">pulsar</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.2k</span><span class="post-meta__separator">|</span><span>Reading time: 14 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>本文只针对persistent topic进行说明。</p>
</blockquote>
<h1 id="1-消息消费流程"><a href="#1-消息消费流程" class="headerlink" title="1. 消息消费流程"></a>1. 消息消费流程</h1><p>consumer和broker之间是通过TCP进行数据交互的，通信框架基于netty，数据格式是TLV结构，分为不包含负载的简单消息和包含负载的消息。</p>
<p>具体参考：<a href="https://pulsar.apache.org/docs/en/develop-binary-protocol/" target="_blank" rel="noopener">https://pulsar.apache.org/docs/en/develop-binary-protocol/</a></p>
<h2 id="1-1-简单消息（Simple-commands）"><a href="#1-1-简单消息（Simple-commands）" class="headerlink" title="1.1 简单消息（Simple commands）"></a>1.1 简单消息（Simple commands）</h2><table>
<thead>
<tr>
<th>名称</th>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>totalSize</td>
<td>4字节</td>
<td>消息总长度，不包含该字段。（单个消息的长度最长为5M）</td>
</tr>
<tr>
<td>commandSize</td>
<td>4字节</td>
<td>序列化消息的长度</td>
</tr>
<tr>
<td>message</td>
<td></td>
<td>序列化消息</td>
</tr>
</tbody></table>
<h2 id="1-2-内容消息（Payload-Message）"><a href="#1-2-内容消息（Payload-Message）" class="headerlink" title="1.2 内容消息（Payload Message）"></a>1.2 内容消息（Payload Message）</h2><p>这种类型的消息主要用于发布和传输消息。</p>
<p>其中message字段并不是用户自定义的消息内容，而是pulsar进行通信时内定的各种消息，已有的消息类型参考：</p>
<p><a href="https://github.com/apache/pulsar/blob/master/pulsar-common/src/main/proto/PulsarApi.proto" target="_blank" rel="noopener">https://github.com/apache/pulsar/blob/master/pulsar-common/src/main/proto/PulsarApi.proto</a></p>
<p>pulsar中的消息以前是基于google protobuf进行序列化的，之后为了节约空间和减少代码量（protobuf会生成很多代码…）使用lightproto（<a href="https://github.com/splunk/lightproto）进行序列化和反序列化。" target="_blank" rel="noopener">https://github.com/splunk/lightproto）进行序列化和反序列化。</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>totalSize</td>
<td>4字节</td>
<td>消息总长度，不包含该字段。（单个消息的长度最长为5M）</td>
</tr>
<tr>
<td>commandSize</td>
<td>4字节</td>
<td>序列化消息的长度</td>
</tr>
<tr>
<td>message</td>
<td></td>
<td>序列化消息</td>
</tr>
<tr>
<td>magicNumber</td>
<td>2字节</td>
<td>用于校验消息，固定为0x0e01。有此标识的话就会进行CRC校验。</td>
</tr>
<tr>
<td>checksum</td>
<td>4字节</td>
<td>用于校验消息完整性。对该字段后边的消息进行CRC32-C计算。具体参考：1.2.1 CRC校验</td>
</tr>
<tr>
<td>metadataSize</td>
<td>4字节</td>
<td>元数据大小</td>
</tr>
<tr>
<td>metaData</td>
<td></td>
<td>元数据内容</td>
</tr>
<tr>
<td>payload</td>
<td></td>
<td>其他内容（用户消息）</td>
</tr>
</tbody></table>
<h3 id="1-2-1-CRC校验"><a href="#1-2-1-CRC校验" class="headerlink" title="1.2.1 CRC校验"></a>1.2.1 CRC校验</h3><p>从netty接收到类型为Message的消息后，会调用handleMessage方法，然后调用consumer的messageReceived方法，在此处进行CRC校验。</p>
<p>调用过程如下（只是列举了方法内的主要逻辑，代码并不完整）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PulsarDecoder -&gt; channelRead</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HAProxyMessage) &#123;</span><br><span class="line">        HAProxyMessage proxyMessage = (HAProxyMessage) msg;</span><br><span class="line">        <span class="keyword">this</span>.proxyMessage = proxyMessage;</span><br><span class="line">        proxyMessage.release();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get a buffer that contains the full frame</span></span><br><span class="line">    ByteBuf buffer = (ByteBuf) msg;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// De-serialize the command</span></span><br><span class="line">        <span class="keyword">int</span> cmdSize = (<span class="keyword">int</span>) buffer.readUnsignedInt();</span><br><span class="line">        cmd.parseFrom(buffer, cmdSize);</span><br><span class="line">        log.info(<span class="string">"vvv_msg_type "</span> + cmd.getType());</span><br><span class="line">        <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE: &#123;</span><br><span class="line">                checkArgument(cmd.hasMessage());</span><br><span class="line">                handleMessage(cmd.getMessage(), buffer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ClientCnx -&gt; handleMessage</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(CommandMessage cmdMessage, ByteBuf headersAndPayload)</span> </span>&#123;</span><br><span class="line">    checkArgument(state == State.Ready);</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"&#123;&#125; Received a message from the server: &#123;&#125;"</span>, ctx.channel(), cmdMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    ConsumerImpl&lt;?&gt; consumer = consumers.get(cmdMessage.getConsumerId());</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;Long&gt; ackSets = Collections.emptyList();</span><br><span class="line">        <span class="keyword">if</span> (cmdMessage.getAckSetsCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ackSets = <span class="keyword">new</span> ArrayList&lt;&gt;(cmdMessage.getAckSetsCount());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cmdMessage.getAckSetsCount(); i++) &#123;</span><br><span class="line">                ackSets.add(cmdMessage.getAckSetAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.messageReceived(cmdMessage.getMessageId(), cmdMessage.getRedeliveryCount(), ackSets, headersAndPayload, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConsumerImpl -&gt; messageReceived</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(MessageIdData messageId, <span class="keyword">int</span> redeliveryCount, List&lt;Long&gt; ackSet, ByteBuf headersAndPayload, ClientCnx cnx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"[&#123;&#125;][&#123;&#125;] Received message: &#123;&#125;/&#123;&#125;"</span>, topic, subscription, messageId.getLedgerId(),</span><br><span class="line">                  messageId.getEntryId());</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"headersAndPayload="</span> + headersAndPayload.readableBytes());</span><br><span class="line">    <span class="keyword">if</span> (!verifyChecksum(headersAndPayload, messageId)) &#123;</span><br><span class="line">        <span class="comment">// discard message with checksum error</span></span><br><span class="line">        discardCorruptedMessage(messageId, cnx, ValidationError.ChecksumMismatch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MessageMetadata msgMetadata;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msgMetadata = Commands.parseMessageMetadata(headersAndPayload);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        discardCorruptedMessage(messageId, cnx, ValidationError.ChecksumMismatch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConsumerImpl -&gt; verifyChecksum</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifyChecksum</span><span class="params">(ByteBuf headersAndPayload, MessageIdData messageId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasChecksum(headersAndPayload)) &#123;</span><br><span class="line">        <span class="keyword">int</span> checksum = Commands.readChecksum(headersAndPayload);</span><br><span class="line">        <span class="keyword">int</span> computedChecksum = Crc32cIntChecksum.computeChecksum(headersAndPayload);</span><br><span class="line">        <span class="keyword">if</span> (checksum != computedChecksum) &#123;</span><br><span class="line">            log.error(</span><br><span class="line">                <span class="string">"[&#123;&#125;][&#123;&#125;] Checksum mismatch for message at &#123;&#125;:&#123;&#125;. Received checksum: 0x&#123;&#125;, Computed checksum: 0x&#123;&#125;"</span>,</span><br><span class="line">                topic, subscription, messageId.getLedgerId(), messageId.getEntryId(),</span><br><span class="line">                Long.toHexString(checksum), Integer.toHexString(computedChecksum));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Commands -&gt; hasChecksum</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasChecksum</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// magicCrc32c == 0x0e01</span></span><br><span class="line">    <span class="keyword">return</span> buffer.getShort(buffer.readerIndex()) == magicCrc32c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-消息订阅和确认过程"><a href="#1-3-消息订阅和确认过程" class="headerlink" title="1.3 消息订阅和确认过程"></a>1.3 消息订阅和确认过程</h2><p>consumer和broker的交互是基于netty进行的，业务处理handler分别是ClientCnx和ServerCnx。</p>
<p>通过查看代码可以了解到consumer连接到broker，消费消息并返回确认的过程中会依次发送以下几种类型的消息：</p>
<p><img src="../../images/640-20231008232701854.png" alt="图片"></p>
<p><strong>CONNECT</strong>：建立TCP连接，broker端确认client的权限，确认成功后返回CONNECTED。</p>
<p><strong>PATITIONED_METADATA</strong>：获取分区数据。由于分区实际上是通过虚拟topic实现的，所有在此阶段可以获取分区topic信息。</p>
<p><strong>LOOKUP</strong>：通过topic名称查找消息是哪一个broker处理的，返回broker的地址。</p>
<p><strong>SUBSCRIBE</strong>：consumer向返回的broker地址建立连接，发送topic、subscriptionName等信息，开始订阅消息。</p>
<p><strong>FLOW</strong>：consumer端发送消息获取请求，并告知broker自己可以接收的最大消息数量。</p>
<p><strong>MESSAGE</strong>：broker收到flow请求后，会从缓存或者bk中拉取最新的消息，在消息完成封装后发送给consumer。</p>
<p><strong>ACK</strong>：consumer接收并处理完消息后，发送消息消费确认通知（已消费消息的messageId）。</p>
<p><strong>CLOSE_CONSUMER</strong>：发送连接断开请求。</p>
<h1 id="2-订阅进度持久化"><a href="#2-订阅进度持久化" class="headerlink" title="2. 订阅进度持久化"></a>2. 订阅进度持久化</h1><ul>
<li>每一个topic的消息都是由唯一的一个broker负责写入的，所以能比较容易保证每条消息的ID是唯一的，这个ID也是pulsar消息的消费和确认标识。</li>
</ul>
<p>一个ID包含如下内容：</p>
<p>ledgerId：bk中每一个文件对应一个ledgerId，由bk维护。</p>
<p>entryId：在每一个ledger中递增，由bk维护。</p>
<p>partitionId：分区ID，由broker维护。</p>
<ul>
<li><p>在pulsar中，ManagedLedgerImpl用于用户消息的写入和读取，ManagedCursorImpl用于topic下每一个subscription的消费进度维护。</p>
</li>
<li><p>consumer收到broker发送的消息后，发送确认信息（messageId）给broker，broker收到后查找该subscription对应的ledger，如果存在则通过ledger写入到bk中；</p>
<p>如果不存在，则创建一个ledger并把ledger信息写入到zk中，然后通过创建后的ledger写入bk中。</p>
</li>
<li><p>zk中写入的数据包含cursorLedgerId、deletedLedgerId、deletedEntryId等信息，如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cursorsLedgerId&#x3D;-1, markDeleteLedgerId&#x3D;603, markDeleteEntryId&#x3D;15, lastActive&#x3D;1629692232349</span><br><span class="line">upper ledgerId&#x3D;603, upper entryId&#x3D;18, lower ledgerId&#x3D;603, lower entryId&#x3D;16</span><br><span class="line">upper ledgerId&#x3D;37740, upper entryId&#x3D;2, lower ledgerId&#x3D;37740, lower entryId&#x3D;1</span><br><span class="line">upper ledgerId&#x3D;37740, upper entryId&#x3D;4, lower ledgerId&#x3D;37740, lower entryId&#x3D;3</span><br></pre></td></tr></table></figure>

<p>uppper和lower用于处理不连续确认的情况。</p>
<p>而且，只有最新一个ledger的最新一个entry信息是有效的，broker初始化cursor信息时只会加载最新ledger的最近一条确认消息的entry中最新一条数据。</p>
<ul>
<li>bk中存储的数据内容：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lowLedgerId&#x3D;603, lowEntryId&#x3D;16, upperLedgerId&#x3D;603, upperEntryId&#x3D;18</span><br><span class="line">lowLedgerId&#x3D;37740, lowEntryId&#x3D;1, upperLedgerId&#x3D;37740, upperEntryId&#x3D;2</span><br><span class="line">lowLedgerId&#x3D;37740, lowEntryId&#x3D;3, upperLedgerId&#x3D;37740, upperEntryId&#x3D;4</span><br><span class="line">lowLedgerId&#x3D;37740, lowEntryId&#x3D;5, upperLedgerId&#x3D;37740, upperEntryId&#x3D;6</span><br></pre></td></tr></table></figure>

<p><strong>可以看到bk中数据主要记录确认情况，zk中记录确认情况在哪一个ledger以及哪些数据被标记为可删除了（被成功消费了）。</strong></p>
<ul>
<li><p>对于不连续确认的消息，会记录消息确认范围信息。从low - upper之前的所有消息都被消费成功了（左开右闭）。</p>
</li>
<li><p>因broker停掉或者其他原因导致cursor被关闭后，会把进度持久化到zk或者bk中。满足以下条件会保存到bk中：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private boolean shouldPersistUnackRangesToLedger() &#123;</span><br><span class="line">    return cursorLedger !&#x3D; null</span><br><span class="line">        &amp;&amp; !isCursorLedgerReadOnly</span><br><span class="line">        &amp;&amp; config.getMaxUnackedRangesToPersist() &gt; 0</span><br><span class="line">        &amp;&amp; individualDeletedMessages.size() &gt; config.getMaxUnackedRangesToPersistInZk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-zk中消费进度解析"><a href="#2-1-zk中消费进度解析" class="headerlink" title="2.1 zk中消费进度解析"></a>2.1 zk中消费进度解析</h2><p>当客户端连接后，要获取该subscription的cursor信息，先从zk中查询，path如下：</p>
<p>/managed-ledgers/{tenant}/{namespace}/persistent/{topic}/{subscriptionName}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testZKMetaDataCursorInfo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/managed-ledgers/tenant_c/ns1/persistent/topic_cursor/consumer_002"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = getValue(path);</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"bytes is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MLDataFormats.ManagedCursorInfo info = MLDataFormats.ManagedCursorInfo.parseFrom(bytes);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.setLength(<span class="number">0</span>);</span><br><span class="line">    sb.append(<span class="string">"cursorsLedgerId="</span>).append(info.getCursorsLedgerId());</span><br><span class="line">    sb.append(<span class="string">", markDeleteLedgerId="</span>).append(info.getMarkDeleteLedgerId());</span><br><span class="line">    sb.append(<span class="string">", markDeleteEntryId="</span>).append(info.getMarkDeleteEntryId());</span><br><span class="line">    sb.append(<span class="string">", lastActive="</span>).append(info.getLastActive());</span><br><span class="line">    <span class="keyword">if</span> (info.getIndividualDeletedMessagesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MLDataFormats.MessageRange range : info.getIndividualDeletedMessagesList()) &#123;</span><br><span class="line">            sb.append(<span class="string">"\n"</span>);</span><br><span class="line">            sb.append(<span class="string">" upper ledgerId="</span>).append(range.getUpperEndpoint().getLedgerId());</span><br><span class="line">            sb.append(<span class="string">", upper entryId="</span>).append(range.getUpperEndpoint().getEntryId());</span><br><span class="line">            sb.append(<span class="string">", lower ledgerId="</span>).append(range.getLowerEndpoint().getLedgerId());</span><br><span class="line">            sb.append(<span class="string">", lower entryId="</span>).append(range.getLowerEndpoint().getEntryId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"debug vv "</span> + sb);</span><br><span class="line">    System.out.println(<span class="string">"done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-bk中消费进度解析"><a href="#2-2-bk中消费进度解析" class="headerlink" title="2.2 bk中消费进度解析"></a>2.2 bk中消费进度解析</h2><p>如果从zk中查询的数据中，cursorLedger不等于-1，则会从bk中查询该ledger的数据，恢复进度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePulsarCursor</span><span class="params">(StringBuilder sb, LedgerEntry entry)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MLDataFormats.PositionInfo positionInfo = MLDataFormats.PositionInfo.parseFrom(entry.getEntryBytes());</span><br><span class="line">    <span class="comment">//        sb.append(", ledgerId=").append(positionInfo.getLedgerId());</span></span><br><span class="line">    <span class="comment">//        sb.append(", entryId=").append(positionInfo.getEntryId());</span></span><br><span class="line">    PositionImpl position = <span class="keyword">new</span> PositionImpl(positionInfo);</span><br><span class="line">    <span class="keyword">if</span> (positionInfo.getIndividualDeletedMessagesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        positionInfo.getIndividualDeletedMessagesList().forEach(messageRange -&gt; &#123;</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">            MLDataFormats.NestedPositionInfo point = messageRange.getLowerEndpoint();</span><br><span class="line">            sb.append(<span class="string">", lowLedgerId="</span>).append(point.getLedgerId());</span><br><span class="line">            sb.append(<span class="string">", lowEntryId="</span>).append(point.getEntryId());</span><br><span class="line">            point = messageRange.getUpperEndpoint();</span><br><span class="line">            sb.append(<span class="string">", upperLedgerId="</span>).append(point.getLedgerId());</span><br><span class="line">            sb.append(<span class="string">", upperEntryId="</span>).append(point.getEntryId());</span><br><span class="line">            log.info(sb.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"-----------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (positionInfo.getBatchedEntryDeletionIndexInfoCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        positionInfo.getBatchedEntryDeletionIndexInfoList().forEach(batchDeletedIndexInfo -&gt; &#123;</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (batchDeletedIndexInfo.getDeleteSetCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchDeletedIndexInfo.getDeleteSetList().size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">long</span> indexId = batchDeletedIndexInfo.getDeleteSetList().get(i);</span><br><span class="line">                    sb.append(<span class="string">", indexId="</span>).append(indexId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(sb.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"================="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-订阅进度恢复流程"><a href="#3-订阅进度恢复流程" class="headerlink" title="3. 订阅进度恢复流程"></a>3. 订阅进度恢复流程</h1><p>订阅进度保存在zk和bk中，这些信息会在broker加载topic信息的时候被恢复。</p>
<p>当producer和consumer连接到broker时，都会调用BrokerService的getTopic方法（分别在ServerCnx的handleProducer和handleSubscribe方法）。</p>
<p>由于brokerService是单例的，所以consumer和producer共用一组topic信息，然后通过topic实例关联ledger、cursor等信息。</p>
<p>在BrokerService中，topic实例创建过程：</p>
<ul>
<li>是否已经创建，如果是则直接返回。</li>
<li>该broker是否有topic的拥有权，如果没有则返回异常。</li>
<li>对创建过程进行加锁，获取到锁后开始创建topic实例（同一时刻，一个topic仅有一个创建任务），由如下参数控制并发创建数量：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return topics.computeIfAbsent(topic, (topicName) -&gt; &#123;</span><br><span class="line">        return this.loadOrCreatePersistentTopic(topicName, createIfMissing);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Max number of concurrent topic loading request broker allows to control number of zk-operations</span><br><span class="line"># 限制获取topic信息时，zk并发操作数量</span><br><span class="line">maxConcurrentTopicLoadRequest&#x3D;5000</span><br></pre></td></tr></table></figure>

<ul>
<li>在后续每一个流程中都会校验该topic是否由该broker负责。</li>
<li>判断ns中topic数量是否超过最大值，如果是则返回。</li>
<li>打开ledger。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; BrokerService -&gt; createPersistentTopic</span><br><span class="line">&#x2F;&#x2F; Once we have the configuration, we can proceed with the async open operation</span><br><span class="line">managedLedgerFactory.asyncOpen(topicName.getPersistenceNamingEncoding(), managedLedgerConfig, new OpenLedgerCallback())...</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化ledger、bookeeper、cursor。</li>
<li>从zk中获取ledger信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ManagedLedgerImpl -&gt; synchronized void initialize(final ManagedLedgerInitializeLedgerCallback callback, final Object ctx)</span><br><span class="line">store.getManagedLedgerInfo(name, config.isCreateIfMissing(), new MetaStoreCallback&lt;ManagedLedgerInfo&gt;() &#123;</span><br></pre></td></tr></table></figure>

<p>从zk中获取cursor信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ManagedLedgerImpl -&gt; private void initializeCursors(final ManagedLedgerInitializeLedgerCallback callback)store.getCursors(name, new MetaStoreCallback&lt;List&lt;String&gt;&gt;() &#123;...</span><br></pre></td></tr></table></figure>

<p>恢复cursor内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">final</span> VoidCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Read the meta-data ledgerId from the store</span></span><br><span class="line">    log.info(<span class="string">"[&#123;&#125;] Recovering from bookkeeper ledger cursor: &#123;&#125;"</span>, ledger.getName(), name);</span><br><span class="line">    ledger.getStore().asyncGetCursorInfo(ledger.getName(), name, <span class="keyword">new</span> MetaStoreCallback&lt;ManagedCursorInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ManagedCursorInfo info, Stat stat)</span> </span>&#123;</span><br><span class="line">            cursorLedgerStat = stat;</span><br><span class="line">            lastActive = info.getLastActive() != <span class="number">0</span> ? info.getLastActive() : lastActive;</span><br><span class="line">            <span class="comment">// 如果zk中的cursorLedger是-1，则说明不需要从ledger中查询订阅进度，直接从zk中加载进度信息即可。</span></span><br><span class="line">            <span class="keyword">if</span> (info.getCursorsLedgerId() == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="comment">// There is no cursor ledger to read the last position from. It means the cursor has been properly</span></span><br><span class="line">                <span class="comment">// closed and the last mark-delete position is stored in the ManagedCursorInfo itself.</span></span><br><span class="line">                PositionImpl recoveredPosition = <span class="keyword">new</span> PositionImpl(info.getMarkDeleteLedgerId(),</span><br><span class="line">                                                                  info.getMarkDeleteEntryId());</span><br><span class="line">                <span class="keyword">if</span> (info.getIndividualDeletedMessagesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    recoverIndividualDeletedMessages(info.getIndividualDeletedMessagesList());</span><br><span class="line">                &#125;</span><br><span class="line">                Map&lt;String, Long&gt; recoveredProperties = Collections.emptyMap();</span><br><span class="line">                <span class="keyword">if</span> (info.getPropertiesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Recover properties map</span></span><br><span class="line">                    recoveredProperties = Maps.newHashMap();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info.getPropertiesCount(); i++) &#123;</span><br><span class="line">                        LongProperty property = info.getProperties(i);</span><br><span class="line">                        recoveredProperties.put(property.getName(), property.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                recoveredCursor(recoveredPosition, recoveredProperties, <span class="keyword">null</span>);</span><br><span class="line">                callback.operationComplete();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 需要从bk中加载消费进度信息。</span></span><br><span class="line">                <span class="comment">// Need to proceed and read the last entry in the specified ledger to find out the last position</span></span><br><span class="line">                log.info(<span class="string">"[&#123;&#125;] Consumer &#123;&#125; meta-data recover from ledger &#123;&#125;"</span>, ledger.getName(), name,</span><br><span class="line">                         info.getCursorsLedgerId());</span><br><span class="line">                recoverFromLedger(info, callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationFailed</span><span class="params">(MetaStoreException e)</span> </span>&#123;</span><br><span class="line">            callback.operationFailed(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从ledger中加载进度信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recoverFromLedger</span><span class="params">(<span class="keyword">final</span> ManagedCursorInfo info, <span class="keyword">final</span> VoidCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Read the acknowledged position from the metadata ledger, then create</span></span><br><span class="line">    <span class="comment">// a new ledger and write the position into it</span></span><br><span class="line">    ledger.mbean.startCursorLedgerOpenOp();</span><br><span class="line">    <span class="keyword">long</span> ledgerId = info.getCursorsLedgerId();</span><br><span class="line">    OpenCallback openCallback = (rc, lh, ctx) -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Read the last entry in the ledger</span></span><br><span class="line">        <span class="comment">// 读取最新一个位置</span></span><br><span class="line">        <span class="keyword">long</span> lastEntryInLedger = lh.getLastAddConfirmed();</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        lh.asyncReadEntries(lastEntryInLedger, lastEntryInLedger, (rc1, lh1, seq, ctx1) -&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 读取最后写入ledger的entry</span></span><br><span class="line">            LedgerEntry entry = seq.nextElement();</span><br><span class="line">            PositionInfo positionInfo;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                positionInfo = PositionInfo.parseFrom(entry.getEntry());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">                callback.operationFailed(<span class="keyword">new</span> ManagedLedgerException(e));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加载属性信息</span></span><br><span class="line">            Map&lt;String, Long&gt; recoveredProperties = Collections.emptyMap();</span><br><span class="line">            <span class="keyword">if</span> (positionInfo.getPropertiesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Recover properties map</span></span><br><span class="line">                recoveredProperties = Maps.newHashMap();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; positionInfo.getPropertiesCount(); i++) &#123;</span><br><span class="line">                    LongProperty property = positionInfo.getProperties(i);</span><br><span class="line">                    recoveredProperties.put(property.getName(), property.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            PositionImpl position = <span class="keyword">new</span> PositionImpl(positionInfo);</span><br><span class="line">            <span class="comment">// 如果有单独确认的消息（为了应对不是连续确认的情况）。</span></span><br><span class="line">            <span class="keyword">if</span> (positionInfo.getIndividualDeletedMessagesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                recoverIndividualDeletedMessages(positionInfo.getIndividualDeletedMessagesList());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (config.isDeletionAtBatchIndexLevelEnabled() &amp;&amp; batchDeletedIndexes != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; positionInfo.getBatchedEntryDeletionIndexInfoCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                recoverBatchDeletedIndexes(positionInfo.getBatchedEntryDeletionIndexInfoList());</span><br><span class="line">            &#125;</span><br><span class="line">            recoveredCursor(position, recoveredProperties, lh);</span><br><span class="line">            callback.operationComplete();</span><br><span class="line">        &#125;, <span class="keyword">null</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 打开一个新的ledger，并把进度信息写入新ledger中。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bookkeeper.asyncOpenLedger(ledgerId, digestType, config.getPassword(), openCallback, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">"[&#123;&#125;] Encountered error on opening cursor ledger &#123;&#125; for cursor &#123;&#125;"</span>,</span><br><span class="line">                  ledger.getName(), ledgerId, name, t);</span><br><span class="line">        openCallback.openComplete(BKException.Code.UnexpectedConditionException, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从ledger中加载单独确认的消息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recoverIndividualDeletedMessages</span><span class="params">(List&lt;MLDataFormats.MessageRange&gt; individualDeletedMessagesList)</span> </span>&#123;</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        individualDeletedMessages.clear();</span><br><span class="line">        individualDeletedMessagesList.forEach(messageRange -&gt; &#123;</span><br><span class="line">            MLDataFormats.NestedPositionInfo lowerEndpoint = messageRange.getLowerEndpoint();</span><br><span class="line">            MLDataFormats.NestedPositionInfo upperEndpoint = messageRange.getUpperEndpoint();</span><br><span class="line">            <span class="comment">// 已确认的消息都在一个ledger内。</span></span><br><span class="line">            <span class="keyword">if</span> (lowerEndpoint.getLedgerId() == upperEndpoint.getLedgerId()) &#123;</span><br><span class="line">                individualDeletedMessages.addOpenClosed(lowerEndpoint.getLedgerId(), lowerEndpoint.getEntryId(),</span><br><span class="line">                                                        upperEndpoint.getLedgerId(), upperEndpoint.getEntryId());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已确认的消息在不同的ledger内，这时候需要加载每个ledger中已确认的消息。</span></span><br><span class="line">                <span class="comment">// Store message ranges after splitting them by ledger ID</span></span><br><span class="line">                LedgerInfo lowerEndpointLedgerInfo = ledger.getLedgersInfo().get(lowerEndpoint.getLedgerId());</span><br><span class="line">                <span class="keyword">if</span> (lowerEndpointLedgerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    individualDeletedMessages.addOpenClosed(lowerEndpoint.getLedgerId(), lowerEndpoint.getEntryId(),</span><br><span class="line">                                                            lowerEndpoint.getLedgerId(), lowerEndpointLedgerInfo.getEntries() - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">"[&#123;&#125;][&#123;&#125;] No ledger info of lower endpoint &#123;&#125;:&#123;&#125;"</span>, ledger.getName(), name,</span><br><span class="line">                             lowerEndpoint.getLedgerId(), lowerEndpoint.getEntryId());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 加载顺序是：</span></span><br><span class="line">                <span class="comment">// (lowerLedgerId, lowerEntryId) -&gt; (lowerLedgerId, -1)   第一条</span></span><br><span class="line">                <span class="comment">// (lowerLedgerId, -1) -&gt; (lowerLedgerId, -1)             中间部分</span></span><br><span class="line">                <span class="comment">// (upperLedgerId, -1) -&gt; (upperLedgerId, upperEntryId)   最后一条</span></span><br><span class="line">                <span class="keyword">for</span> (LedgerInfo li : ledger.getLedgersInfo()</span><br><span class="line">                     .subMap(lowerEndpoint.getLedgerId(), <span class="keyword">false</span>, upperEndpoint.getLedgerId(), <span class="keyword">false</span>).values()) &#123;</span><br><span class="line">                    individualDeletedMessages.addOpenClosed(li.getLedgerId(), -<span class="number">1</span>, li.getLedgerId(),</span><br><span class="line">                                                            li.getEntries() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                individualDeletedMessages.addOpenClosed(upperEndpoint.getLedgerId(), -<span class="number">1</span>,</span><br><span class="line">                                                        upperEndpoint.getLedgerId(), upperEndpoint.getEntryId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进度恢复完毕。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">iMine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://imine141.github.io/2021/08/23/pulsar/pulsar%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E4%BF%9D%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89/">https://imine141.github.io/2021/08/23/pulsar/pulsar%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E4%BF%9D%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pulsar/">pulsar</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/09/01/pulsar/%E3%80%90bug%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1CompletableFuture%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%7B%7D/"><i class="fa fa-chevron-left">  </i><span>记一次CompletableFuture引起的死锁问题</span></a></div><div class="next-post pull-right"><a href="/2021/08/20/pulsar/pulsar%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E7%A0%94%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/"><span>pulsar消费进度研究（一）</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '316d899c68e414a53017',
  clientSecret: 'e63edfd4dd96b3b665a0a561e2ce048c2b3f0a3b',
  repo: 'imine141.github.io',
  owner: 'imine141',
  admin: 'imine141',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By iMine</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>