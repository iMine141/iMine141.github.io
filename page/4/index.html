<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="iMine"><meta name="copyright" content="iMine"><title>iMineのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 7.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">iMine</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">74</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iMineのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">iMineのBlog</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/">数组与广义表</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><div class="content"><h3 id="1-数组的概念、多维数组的实现"><a href="#1-数组的概念、多维数组的实现" class="headerlink" title="1 数组的概念、多维数组的实现"></a>1 数组的概念、多维数组的实现</h3><h4 id="1）数组的概念"><a href="#1）数组的概念" class="headerlink" title="1）数组的概念"></a>1）数组的概念</h4><ul>
<li>数组的特点：元素数目固定；下标有界。</li>
<li>数组的操作：按照下标进行读写。</li>
</ul>
<h4 id="2）多维数组的实现"><a href="#2）多维数组的实现" class="headerlink" title="2）多维数组的实现"></a>2）多维数组的实现</h4><h5 id="行优先顺序"><a href="#行优先顺序" class="headerlink" title="行优先顺序"></a>行优先顺序</h5><p>存储时先按行从小到大的顺序存储，在每一行中按列号从小到大存储。</p>
<h5 id="列优先顺序"><a href="#列优先顺序" class="headerlink" title="列优先顺序"></a>列优先顺序</h5><p>存储时先按列从小到大的顺序存储，在每一列中按行号从小到大存储。</p>
<h3 id="2-矩阵的压缩存储"><a href="#2-矩阵的压缩存储" class="headerlink" title="2 矩阵的压缩存储"></a>2 矩阵的压缩存储</h3><p>矩阵的压缩存储就是存储数组时，尽量减少存储空间，但数组中每个元素必须存储。</p>
<p>在矩阵中，如果有规律可寻，只要存储其中一部分，而另外一部分的存储地址可以通过相应的算法将它计算出来，从而占有较少的存储空间达到存储整个矩阵的目的。</p>
<p>矩阵的压缩存储仅能针对特殊矩阵使用，对于没有规律可循的二维数组则不能使用。</p>
<h4 id="1）对称矩阵"><a href="#1）对称矩阵" class="headerlink" title="1）对称矩阵"></a>1）对称矩阵</h4><p>只需对对称矩阵中n(n+1)&#x2F;2个元素进行储存表示</p>
<p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E5%B9%BF%E4%B9%89%E8%A1%A81"></p>
<h4 id="2）三角矩阵"><a href="#2）三角矩阵" class="headerlink" title="2）三角矩阵"></a>2）三角矩阵</h4><p>以主对角线划分，三角矩阵有上三角和下三角两种。上三角矩阵它的下三角中的元素均为常数。下三角矩阵正好相反，它的主对角线上方均为常数。</p>
<p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A82"></p>
<h4 id="3）稀疏矩阵"><a href="#3）稀疏矩阵" class="headerlink" title="3）稀疏矩阵"></a>3）稀疏矩阵</h4><p>if 一个 m * n 的矩阵含有 t 个非零元素，且 t 远远小于 m * n，则称这个矩阵为稀疏矩阵</p>
<p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A83"></p>
<p>除了记录非零元素的值之外，还必须同时几下它所在的行和列的位置。稀疏矩阵的存储方法一般有三种：三元组法、行逻辑连接顺序表和十字链表法。</p>
<h5 id="三元组法"><a href="#三元组法" class="headerlink" title="三元组法"></a>三元组法</h5><p>用三项内容表示稀疏矩阵中的每个非零元素，形式为：（i,j,value）。<br>其中，i 表示行序号，j 表示列序号，value 表示非零元素的值</p>
<h3 id="3-广义表的基本概念"><a href="#3-广义表的基本概念" class="headerlink" title="3 广义表的基本概念"></a>3 广义表的基本概念</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><ul>
<li>广义表：是线性表的扩展，具体定义为n（n≥0）个元素的有限集合。<br>n的值是广义表的长度，如果n&#x3D;0称广义表为空表。</li>
<li>长度：广义表中含有元素的个数称</li>
<li>深度：广义表中含有的括号对数</li>
</ul>
<h5 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h5><p>广义表的数据元素有两种类型：一个是不可再分的元素（原子元素）；一个是可以再分的元素（子表）。</p>
<ul>
<li>如果所有的元素都是原子元素，则称为线性表。</li>
<li>如果数据元素中含有子表元素，则称为广义表。</li>
</ul>
<h5 id="记法"><a href="#记法" class="headerlink" title="记法"></a>记法</h5><p>广义表一般记作：LS&#x3D;(a1,a2,……,an)</p>
<p>常见的广义表为：A&#x3D;()、B&#x3D;(())、C&#x3D;(a,b)、D&#x3D;(A,B,C)、E&#x3D;(a,E)</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>广义表有三个重要的特点：</p>
<ul>
<li>第一：广义表的元素可以是子表，而子表的元素还可以是子表，广义表是一个多层次的结构。</li>
<li>第二：广义表可以为其他广义表所共享。</li>
<li>第三：广义表可以是一个递归表，即表也可以是其本身的一个子表。</li>
</ul>
<h4 id="2）存储方式"><a href="#2）存储方式" class="headerlink" title="2）存储方式"></a>2）存储方式</h4><p>广义表的存储方法有很多种，一般采用链表存储。</p>
<p><img src="https://imine141.github.io/images/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A84"></p>
<p>flag表示标志位。当flag为0时，表示该结点为原子元素，info表示原子元素的值；当flag为1时表示该结点为子表，info表示指针，指向该子表的第一个结点。 link表示指针，指向广义表的下一个元素。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E4%BF%AE%E9%A5%B0%E7%AC%A6/">修饰符</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">对象与类</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h3 id="1-访问修饰符"><a href="#1-访问修饰符" class="headerlink" title="1 访问修饰符"></a>1 访问修饰符</h3><ul>
<li>private：仅对本类可见</li>
<li>public：对所有类可见<ul>
<li>接口里方法默认 public</li>
</ul>
</li>
<li>protected：对本包和所有子类可见</li>
<li>default：对本包可见</li>
</ul>
<p>一个方法可以访问所属类的所有对象的私有对象</p>
<h3 id="2-非访问修饰符"><a href="#2-非访问修饰符" class="headerlink" title="2 非访问修饰符"></a>2 非访问修饰符</h3><h4 id="2-1-final"><a href="#2-1-final" class="headerlink" title="2.1 final"></a>2.1 final</h4><ul>
<li>final 域（常量）<ul>
<li>final 域必须显式指定初始值，赋值后，不能被重新赋值。</li>
<li>基本类型：final 使数值不变</li>
<li>引用类型：final 使引用不变，但是被引用的对象本身是可以修改的</li>
</ul>
</li>
<li>final 方法<ul>
<li>final 方法可以被子类继承，但是不能被子类修改。</li>
<li>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</li>
</ul>
</li>
<li>final 类<ul>
<li>final 类不能被继承</li>
</ul>
</li>
</ul>
<h4 id="2-2-static"><a href="#2-2-static" class="headerlink" title="2.2 static"></a>2.2 static</h4><ul>
<li>静态域（变量）<ul>
<li>类变量，多实例也只有一份拷贝</li>
</ul>
</li>
<li>静态常量<ul>
<li>多与 final 组成静态常量，一般大写</li>
</ul>
</li>
<li>静态方法<ul>
<li>类方法，独立于对象，没有隐式参数 this 和 super，可以访问静态域</li>
<li>不可从一个 static 方法内部发出对非 static 方法的调用</li>
<li>必须有实现，不能是抽象方法</li>
</ul>
</li>
<li>静态内部类<ul>
<li>只有内部类能被声明为 static。</li>
<li>静态内部类不能访问外部类的非静态的变量和方法。</li>
</ul>
</li>
<li>静态代码块<ul>
<li>静态块在类加载时自动执行</li>
</ul>
</li>
<li>静态导包<ul>
<li>JDK 1.5，用 import static 代替 import 静态导入，可以直接使用类的静态方法和静态域，而不需要使用类名作为前缀。</li>
</ul>
</li>
</ul>
<p>存在继承的情况下，初始化顺序为：</p>
<blockquote>
<p>父类（静态变量、静态语句块）<br>子类（静态变量、静态语句块）<br>父类（实例变量、普通语句块）<br>父类（构造函数）<br>子类（实例变量、普通语句块）<br>子类（构造函数）</p>
</blockquote>
<h4 id="2-3-abstract"><a href="#2-3-abstract" class="headerlink" title="2.3 abstract"></a>2.3 abstract</h4><ul>
<li>抽象类<ul>
<li>抽象类不能实例化，唯一目的是为了对该类进行扩充。</li>
<li>抽象类可以不包含抽象方法。</li>
</ul>
</li>
<li>抽象方法<ul>
<li>抽象方法是一种没有任何实现的方法，具体实现由子类提供。</li>
<li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li>
<li>包含抽象方法的类，一定要声明为抽象类。</li>
</ul>
</li>
</ul>
<h4 id="2-4-synchronized"><a href="#2-4-synchronized" class="headerlink" title="2.4 synchronized"></a>2.4 synchronized</h4><ul>
<li>方法</li>
<li>代码块<ul>
<li>synchronized 声明的方法同一时间只能被一个线程访问。</li>
</ul>
</li>
</ul>
<h4 id="2-5-transient"><a href="#2-5-transient" class="headerlink" title="2.5 transient"></a>2.5 transient</h4><ul>
<li>transient 变量<ul>
<li>序列化时被跳过</li>
</ul>
</li>
</ul>
<h4 id="2-6-volatile"><a href="#2-6-volatile" class="headerlink" title="2.6 volatile"></a>2.6 volatile</h4><p>volatile 同步变量</p>
<ul>
<li>原子性：不保证</li>
<li>可见性：保证，读写立刻与主内存交换</li>
<li>有序性：保证，禁止指令重排序优化</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E7%B1%BB/">类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">对象与类</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h3 id="1-类"><a href="#1-类" class="headerlink" title="1 类"></a>1 类</h3><p>类是构造对象的模板。</p>
<p>由类构造对象的过程称为创建类的实例。</p>
<p>一个源文件中，只能有一个公共类，类名必须与文件名相同。</p>
<h4 id="1-1-类之间的关系"><a href="#1-1-类之间的关系" class="headerlink" title="1.1 类之间的关系"></a>1.1 类之间的关系</h4><p>最常见的关系有：</p>
<ol>
<li>依赖（uses-a）：一个类的方法需要操纵另一个类的对象</li>
<li>聚合（has-a）：类 A 的对象包含着类 B 的对象</li>
<li>继承（is-a）：继承是一种用于表示特殊与一般的关系，父类更一般</li>
</ol>
<p>应该尽可能地将相互依赖的类减至最少。</p>
<h4 id="1-2-构造器"><a href="#1-2-构造器" class="headerlink" title="1.2 构造器"></a>1.2 构造器</h4><ol>
<li>构造器和类名同名，参数不限，没有返回值。</li>
<li>构造器中的局部变量会覆盖同名实例域。</li>
<li>若未手动编写构造器，会默认提供一个无参构造器，设默认值。手动提供构造器后，不会自动提供无参构造器。</li>
<li>构造器不能被继承，因此不能被重写，但可以被重载。</li>
<li>父类与子类的构造函数调用次序：若子类构造器没有显式调用父类构造器，不管子类构造器有无参数，都默认调用父类无参构造器。</li>
</ol>
<h4 id="1-3-finalize-方法"><a href="#1-3-finalize-方法" class="headerlink" title="1.3 finalize 方法"></a>1.3 finalize 方法</h4><p>可以为任何一个类添加 finalize 方法，将在垃圾回收器清除对象之前调用。不要依赖，不能保证被调用。</p>
<h4 id="1-4-Object：所有类的超类"><a href="#1-4-Object：所有类的超类" class="headerlink" title="1.4 Object：所有类的超类"></a>1.4 Object：所有类的超类</h4><p>如果重新定义 equals 方法，就必须重新定义 hashCode 方法。eauals 与 hashCode 的定义必须一致：如果 x.eauals(y) 返回 true，那么 x.hashCode() 必须与 y.hashCode() 具有相同的值。</p>
<h5 id="1）equals-方法"><a href="#1）equals-方法" class="headerlink" title="1）equals()方法"></a>1）equals()方法</h5><h6 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h6><p>两个对象具有等价关系，需要满足以下五个条件：</p>
<ul>
<li><p>自反性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对称性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一致性</p>
<ul>
<li>多次调用 equals() 方法结果不变</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与 null 的比较</p>
<ul>
<li>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(<span class="literal">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="等价与相等"><a href="#等价与相等" class="headerlink" title="等价与相等"></a>等价与相等</h6><ul>
<li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<h5 id="2）hashCode"><a href="#2）hashCode" class="headerlink" title="2）hashCode()"></a>2）hashCode()</h5><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p>
<h5 id="3）toString"><a href="#3）toString" class="headerlink" title="3）toString()"></a>3）toString()</h5><p>默认返回 ClassName@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<h5 id="4）clone"><a href="#4）clone" class="headerlink" title="4）clone()"></a>4）clone()</h5><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<p>clone() 方法并不是 Cloneable 接口的方法，Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<ul>
<li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</li>
<li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。</li>
</ul>
<h4 id="1-5-枚举类"><a href="#1-5-枚举类" class="headerlink" title="1.5 枚举类"></a>1.5 枚举类</h4><p>枚举类定义的是一个类，有着指定的几个实例。<br>比较两个枚举类型的值时，不需要调用 equals 方法，而直接使用”&#x3D;&#x3D;”就可以了。</p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2 对象"></a>2 对象</h3><h4 id="2-1-创建对象"><a href="#2-1-创建对象" class="headerlink" title="2.1 创建对象"></a>2.1 创建对象</h4><ol>
<li>用 new 语句创建对象</li>
<li>运用反射</li>
<li>调用对象的 clone() 方法</li>
<li>运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject() 方法</li>
</ol>
<p>(1) 和 (2) 都会明确的显式的调用构造函数；(3) 是在内存上对已有对象的影印，所以不会调用构造函数；(4) 是从文件中还原类的对象，也不会调用构造函数。</p>
<h4 id="2-2-对象克隆"><a href="#2-2-对象克隆" class="headerlink" title="2.2 对象克隆"></a>2.2 对象克隆</h4><p>有两种方式：</p>
<ul>
<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法；</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>
</ul>
<h4 id="2-3-序列化"><a href="#2-3-序列化" class="headerlink" title="2.3 序列化"></a>2.3 序列化</h4><ul>
<li>对象序列化（Serializable）是指将对象转换为字节序列的过程，而反序列化则是根据字节序列恢复对象的过程。只有实现了 Serializable 和 Externalizable 接口的类的对象才能被序列化。</li>
<li>java.io.ObjectOutputStream 代表对象输出流，它的 writeObject(Objectobj) 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</li>
<li>java.io.ObjectInputStream 代表对象输入流，它的 readObject() 方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</li>
</ul>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><h4 id="3-1-方法签名"><a href="#3-1-方法签名" class="headerlink" title="3.1 方法签名"></a>3.1 方法签名</h4><p>方法签名只有<strong>方法名</strong>和<strong>参数</strong>，没有返回值。也就是说，不能有两个名字相同、参数也相同而返回值不同的方法。</p>
<h4 id="3-2-隐式参数与显式参数"><a href="#3-2-隐式参数与显式参数" class="headerlink" title="3.2 隐式参数与显式参数"></a>3.2 隐式参数与显式参数</h4><p>隐式参数是出现在方法名前的类对象（this），显式参数位于方法名后面的括号中。</p>
<p>使用 this 可以区分开隐式参数的类对象的实例域和局部变量</p>
<h4 id="3-3-方法参数"><a href="#3-3-方法参数" class="headerlink" title="3.3 方法参数"></a>3.3 方法参数</h4><p>Java 方法参数是<strong>值传递</strong>，不是引用传递。</p>
<p>方法在执行时，先定义了局部变量，这些局部变量指向，传入参数的指向。对局部变量重新指向时，完全不影响原本传入参数的那些指向。</p>
<ul>
<li>值传递：方法接收的是调用者提供的值。</li>
<li>引用传递：方法接受的是调用所对应的变量地址。</li>
</ul>
<h4 id="3-4-参数变量可变的方法"><a href="#3-4-参数变量可变的方法" class="headerlink" title="3.4 参数变量可变的方法"></a>3.4 参数变量可变的方法</h4><p>Object… 参数类型与 Object[] 完全一样，省略号表明这个方法可以接收任意数量的的对象。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/19/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">对象与类</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h3 id="1-抽象"><a href="#1-抽象" class="headerlink" title="1 抽象"></a>1 抽象</h3><p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2 封装"></a>2 封装</h3><p>把数据和行为隐藏，只能通过暴露的接口访问数据。</p>
<h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3 继承"></a>3 继承</h3><p>通过扩展一个类来建立另一个新的类。</p>
<h4 id="3-1-慎用继承"><a href="#3-1-慎用继承" class="headerlink" title="3.1 慎用继承"></a>3.1 慎用继承</h4><ol>
<li>将公共操作和域放在超类。</li>
<li>不要使用受保护的域。</li>
<li>使用继承实现”is-a”。</li>
<li>除非所有继承的方法都有意义，否则不要使用继承。</li>
<li>在覆盖方法时，不要改变预期的行为。</li>
<li>使用多态，而非类型信息。</li>
<li>不要过多地使用反射。</li>
</ol>
<h4 id="3-2-强制类型转换"><a href="#3-2-强制类型转换" class="headerlink" title="3.2 强制类型转换"></a>3.2 强制类型转换</h4><p>只能在继承层次内进行类型转换。</p>
<p>在将超类转换成子类之前，应该使用 instanceof 进行检查。</p>
<ul>
<li>上溯造型（Upcasting）：把衍生类型当作它的基本类型处理</li>
<li>下溯造型（Downcasting）：向下转型，超类可用子类置换。</li>
</ul>
<h4 id="3-3-重写（override）"><a href="#3-3-重写（override）" class="headerlink" title="3.3 重写（override）"></a>3.3 重写（override）</h4><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<h4 id="3-4-重载（overload）"><a href="#3-4-重载（overload）" class="headerlink" title="3.4 重载（overload）"></a>3.4 重载（overload）</h4><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4 多态"></a>4 多态</h3><p>一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。</p>
<p>Java 实现多态有三个必要条件：继承、重写、上溯造型。</p>
<p>虚拟机预先为每个类创建了一个方法表（method table），其中列出了所有方法的签名和实际调用的方法。</p>
<h4 id="4-1-动态绑定"><a href="#4-1-动态绑定" class="headerlink" title="4.1 动态绑定"></a>4.1 动态绑定</h4><p>在运行时能够自动选择调用哪个方法的现象称为动态绑定。</p>
<ol>
<li>编译器会列举类方法表中同名方法，和超类方法表中同名且为 public 的方法。</li>
<li>编译器重载匹配参数类型，若有完全匹配的就选择，没有就匹配允许类型转换的方法，如果这样还是不能找到匹配项，编译器就会报错；同时如果找到多于一个匹配项，编译器也会报错。</li>
</ol>
<h4 id="4-2-静态绑定"><a href="#4-2-静态绑定" class="headerlink" title="4.2 静态绑定"></a>4.2 静态绑定</h4><p>如果是 private,static,final 方法或者构造器，那么编译器可以明确地知道该调用哪个方法，这种调用方式成为静态绑定。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/18/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/">基础设计</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h3 id="1-数学函数与常量"><a href="#1-数学函数与常量" class="headerlink" title="1 数学函数与常量"></a>1 数学函数与常量</h3><ul>
<li>Math.sqrt(x)：平方根</li>
<li>Math.pow(x, y)：幂运算，x 的 y 次幂</li>
<li>Math.floorMod(x, y)：求余</li>
</ul>
<h3 id="2-自增与自减运算符"><a href="#2-自增与自减运算符" class="headerlink" title="2 自增与自减运算符"></a>2 自增与自减运算符</h3><p>建议不要在表达式中使用 ++，容易带来疑惑和 bug</p>
<h3 id="3-关系和-boolean-运算符"><a href="#3-关系和-boolean-运算符" class="headerlink" title="3 关系和 boolean 运算符"></a>3 关系和 boolean 运算符</h3><ul>
<li><code>==</code></li>
<li><code>!=</code></li>
<li><code>&lt;</code></li>
<li><code>&gt;</code></li>
<li><code>&lt;=</code></li>
<li><code>&gt;=</code></li>
<li><code>&amp;&amp;</code>（短路）</li>
<li><code>||</code>（短路）</li>
<li><code>?:</code></li>
</ul>
<h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4 位运算符"></a>4 位运算符</h3><ul>
<li><p>逻辑</p>
<ul>
<li>整型<ul>
<li><code>|</code> (或)</li>
<li><code>&amp;</code> (且)</li>
<li><code>~</code> (非)</li>
<li><code>^</code> (抑或)</li>
</ul>
</li>
<li>布尔值<ul>
<li>可用 <code>&amp;</code> 和 <code>|</code>，只是不短路</li>
</ul>
</li>
</ul>
</li>
<li><p>位移</p>
<ul>
<li><pre><code>&lt;&lt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （左移）</span><br><span class="line"></span><br><span class="line">  - `&lt;&lt;` 时 int 模 32，long 模 64，如 1 &lt;&lt; 35 等于 1 &lt;&lt; 3</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  &gt;&gt;</span><br></pre></td></tr></table></figure>

（带符号右移）

- “符号扩展”：若值为正，则在高位插入 0；若值为负，则在高位插入 1。
</code></pre>
</li>
<li><pre><code>&gt;&gt;&gt;
</code></pre>
<p>（无符号右移）</p>
<ul>
<li>“零扩展”：无论正负，都在高位插入0。</li>
</ul>
</li>
<li><p>不存在 <code>&lt;&lt;&lt;</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="5-括号与运算符级别"><a href="#5-括号与运算符级别" class="headerlink" title="5 括号与运算符级别"></a>5 括号与运算符级别</h3><h3 id="6-枚举类型"><a href="#6-枚举类型" class="headerlink" title="6 枚举类型"></a>6 枚举类型</h3></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/17/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E7%BB%84/">数组</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/">基础设计</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h3 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1. 一维数组"></a>1. 一维数组</h3><h4 id="1-1-声明"><a href="#1-1-声明" class="headerlink" title="1.1 声明"></a>1.1 声明</h4><p>一旦创建了数组就不能改变它的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br></pre></td></tr></table></figure>



<h4 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h4><p>数字数组初始化为 0。boolean 数组初始化 false。对象数组初始化 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2. 多维数组"></a>2. 多维数组</h3><p>java 实际上没有多维数组，只有一维数组，多维数组被解释成“数组的数组”</p>
<h4 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1 声明"></a>2.1 声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[n][]</span><br></pre></td></tr></table></figure>



<h4 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[][] A = &#123;</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-Arrays-类"><a href="#3-Arrays-类" class="headerlink" title="3. Arrays 类"></a>3. Arrays 类</h3><h4 id="3-1-填充-fill"><a href="#3-1-填充-fill" class="headerlink" title="3.1 填充 fill()"></a>3.1 填充 <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(type[] a,type v);</span><br></pre></td></tr></table></figure>



<h4 id="3-2-排序-sort"><a href="#3-2-排序-sort" class="headerlink" title="3.2 排序 sort()"></a>3.2 排序 <code>sort()</code></h4><p>优化的快排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序排序 </span></span><br><span class="line">Arrays.sort(type[] a);</span><br><span class="line"><span class="comment">//给开始位到结束位排序</span></span><br><span class="line">Arrays.sort(type[] a,<span class="type">int</span> start,<span class="type">int</span> end);</span><br></pre></td></tr></table></figure>



<h4 id="3-3-比较-equals"><a href="#3-3-比较-equals" class="headerlink" title="3.3 比较 equals()"></a>3.3 比较 <code>equals()</code></h4><p>比较元素是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.equals(type[] a,type[] b);</span><br></pre></td></tr></table></figure>



<h4 id="3-4-查找-binarySearch"><a href="#3-4-查找-binarySearch" class="headerlink" title="3.4 查找 binarySearch()"></a>3.4 查找 <code>binarySearch()</code></h4><p>二分查找，数组一定要是先排好序，返回最后一个找到的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.binarySearch(type[] a,type v);</span><br><span class="line"><span class="comment">//范围查找</span></span><br><span class="line">Arrays.binarySearch(type[] a,type v,<span class="type">int</span> start,<span class="type">int</span> end);</span><br></pre></td></tr></table></figure>



<h4 id="3-5-拷贝-copyOf"><a href="#3-5-拷贝-copyOf" class="headerlink" title="3.5 拷贝 copyOf()"></a>3.5 拷贝 <code>copyOf()</code></h4><p>使用 Arrays 类的 copyOf 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度拷贝</span></span><br><span class="line"><span class="type">int</span>[] a = Arrays.copyOf(b,b.length);</span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="type">int</span>[] a = Arrays.copyOf(b,b.length*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//部分拷贝</span></span><br><span class="line">Arrays.copyOfRange(a,<span class="number">0</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h4 id="3-6-转字符串-toString"><a href="#3-6-转字符串-toString" class="headerlink" title="3.6 转字符串 toString()"></a>3.6 转字符串 <code>toString()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.toString(a)</span><br><span class="line"><span class="comment">//打印多维数组</span></span><br><span class="line">Arrays.deepToString()</span><br></pre></td></tr></table></figure>



<h4 id="3-7-转列表-asList"><a href="#3-7-转列表-asList" class="headerlink" title="3.7 转列表 asList()"></a>3.7 转列表 <code>asList()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Moe&quot;</span>, <span class="string">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/16/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/">基础设计</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h3 id="1-String-底层实现"><a href="#1-String-底层实现" class="headerlink" title="1 String 底层实现"></a>1 String 底层实现</h3><p>String 被声明为 final，因此它不可被继承。</p>
<p>底层是 char 或 byte 类型的 value 数组，value 数组也被声明为 final，这意味着数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<p>编辑器可让字符串共享在常量池。</p>
<h4 id="1-1-Java-8-char-数组"><a href="#1-1-Java-8-char-数组" class="headerlink" title="1.1 Java 8 - char 数组"></a>1.1 Java 8 - char 数组</h4><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-Java-9-byte-数组"><a href="#1-2-Java-9-byte-数组" class="headerlink" title="1.2 Java 9 - byte 数组"></a>1.2 Java 9 - byte 数组</h4><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-3-不可变的好处"><a href="#1-3-不可变的好处" class="headerlink" title="1.3 不可变的好处"></a>1.3 不可变的好处</h4><ul>
<li>可以缓存 hash 值<ul>
<li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
</ul>
</li>
<li>String Pool 的需要<ul>
<li>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
</ul>
</li>
<li>安全性<ul>
<li>String 经常作为参数，String 不可变性可以保证参数不可变。</li>
<li>例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
</ul>
</li>
<li>线程安全<ul>
<li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ul>
</li>
</ul>
<h3 id="2-StringBuilder-和-StringBuffer"><a href="#2-StringBuilder-和-StringBuffer" class="headerlink" title="2 StringBuilder 和 StringBuffer"></a>2 StringBuilder 和 StringBuffer</h3><h4 id="2-1-可变性与线程安全"><a href="#2-1-可变性与线程安全" class="headerlink" title="2.1 可变性与线程安全"></a>2.1 可变性与线程安全</h4><ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 可变，不是线程安全的，效率比 StringBuffer 高</li>
<li>StringBuffer 可变，是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h4 id="2-2-底层实现"><a href="#2-2-底层实现" class="headerlink" title="2.2 底层实现"></a>2.2 底层实现</h4><p>StringBuilder 和 StringBuffer 继承了 AbstractStringBuilder，AbstractStringBuilder 的 char 数组没有 final 关键字修饰，字符数组长度可变，所有 StringBuilder 和 StringBuffer 也是可变的</p>
<p>AbstractStringBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// StringBuilder 类继承 AbstractStringBuilder 抽象类</span></span><br><span class="line">    <span class="comment">// 创建长度 16 的字符数组</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-String-Pool-与引用"><a href="#3-String-Pool-与引用" class="headerlink" title="3 String Pool 与引用"></a>3 String Pool 与引用</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。</p>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<ul>
<li>new String()：会在堆新建对象</li>
<li>intern() 方法： String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</li>
<li>“”字面量：使用字面量的形式创建字符串，会自动地将字符串放入 String Pool 中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Programming&quot;</span>;<span class="comment">//先去常量池取，没有就新建对象放在常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Programming&quot;</span>);<span class="comment">//两个字符串对象，一个是常量池的&quot;Programming&quot;，一个是用 new 创建在堆上的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Program&quot;</span>;<span class="comment">//常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;ming&quot;</span>;<span class="comment">//常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;Program&quot;</span> + <span class="string">&quot;ming&quot;</span>;<span class="comment">//常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s3 + s4;<span class="comment">//堆</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s6.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s2 == s2.intern());<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h3 id="4-String-常用方法"><a href="#4-String-常用方法" class="headerlink" title="4 String 常用方法"></a>4 String 常用方法</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><h5 id="1）使用字符串常量直接初始化"><a href="#1）使用字符串常量直接初始化" class="headerlink" title="1）使用字符串常量直接初始化"></a>1）使用字符串常量直接初始化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;hello!&quot;;</span><br></pre></td></tr></table></figure>

<h5 id="2）使用构造方法创建并初始化"><a href="#2）使用构造方法创建并初始化" class="headerlink" title="2）使用构造方法创建并初始化"></a>2）使用构造方法创建并初始化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = new String(Object);</span><br></pre></td></tr></table></figure>

<p>初始化源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">// 本质是字符数组常量，所以不可变</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-操作"><a href="#4-2-操作" class="headerlink" title="4.2 操作"></a>4.2 操作</h4><h5 id="1）截取字符串"><a href="#1）截取字符串" class="headerlink" title="1）截取字符串"></a>1）截取字符串</h5><ul>
<li>单点截取：subString(开始下标)</li>
<li>双点截取：subString(开始下标，结束下标)</li>
</ul>
<h5 id="2）拼接字符串"><a href="#2）拼接字符串" class="headerlink" title="2）拼接字符串"></a>2）拼接字符串</h5><ul>
<li>+ 号</li>
<li>join：用一个定界符分割，String.join(“定界符”,“待合并字符串”…)</li>
</ul>
<p>字符串的 + 操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象</p>
<p>一般情况进行字符串拼接用 + 就可以，但是如果是循环拼接，则需要用 StringBuilder 的 append 来实现。</p>
<p>若不使用 StringBuilder 的 append 方法而使用 + 来进行连接。那么每次在循环体内都将会在 Heap 中创造一个新的 String 对象，造成资源浪费。</p>
<h5 id="3）获取信息"><a href="#3）获取信息" class="headerlink" title="3）获取信息"></a>3）获取信息</h5><ul>
<li>下标：indexOf(子字符)，lastIndexOf(子字符)</li>
<li>字符：charAt(下标)</li>
<li>字节数组：getBytes()</li>
<li>字符数组：toCharArray()</li>
<li>长度：length()</li>
</ul>
<h5 id="4）替换字符串"><a href="#4）替换字符串" class="headerlink" title="4）替换字符串"></a>4）替换字符串</h5><ul>
<li>去掉前后空格：trim()</li>
<li>子字符串：split(字符串)，StringTokenizer()</li>
</ul>
<h5 id="5）判断字符串"><a href="#5）判断字符串" class="headerlink" title="5）判断字符串"></a>5）判断字符串</h5><ul>
<li>是否相等：.equals()</li>
<li>不区分大小写：.equalsIgnoreCase()</li>
<li>是否为空串：.length()&#x3D;&#x3D;0 或 .equals(“”)</li>
<li>是否为null：&#x3D;&#x3D; null</li>
<li>前缀：startsWith(前缀)</li>
<li>后缀：endsWith(后缀)</li>
<li>大小：compareTo()</li>
</ul>
<h5 id="6）字符串转换"><a href="#6）字符串转换" class="headerlink" title="6）字符串转换"></a>6）字符串转换</h5><ul>
<li>大&#x2F;小写：<ul>
<li>大写：toLowerCase()</li>
<li>小写：toUpperCase()</li>
</ul>
</li>
<li>字符串转换为基本类型<ul>
<li>Long.parseLong(“1231”);</li>
<li>Double.parseDouble(“0.213”);</li>
</ul>
</li>
<li>基本类型转换为字符串<ul>
<li>基本数据类型变量 + “”</li>
<li>String.valueOf(其他类型的参数)；</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1/">基础设计</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><p>数据类型分为基本类型和对象类型。</p>
<h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h3><p>Java 中的基本类型有 8 种，其中有 4 种整型、2 种浮点型、char 和 boolean。还有 void 和 reference 类型</p>
<ol>
<li>基本类型值存储在内存栈上。</li>
<li>基本类型所占空间大小固定。</li>
<li>所有数值类型都有正负号。</li>
</ol>
<h4 id="1-1-整型"><a href="#1-1-整型" class="headerlink" title="1.1 整型"></a>1.1 整型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>包装类</th>
<th>存储需求</th>
<th>取值范围</th>
<th>零值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>long</td>
<td>Long</td>
<td>8 字节 64 bits</td>
<td>-2^63 ~ +2^63-1</td>
<td>0L</td>
<td>后缀加L或l</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>4 字节 32 bits</td>
<td>-2^31 ~ +2^31-1</td>
<td>0</td>
<td>最常用，范围超20亿</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>2 字节 16 bits</td>
<td>-2^15 ~ +2^15-1</td>
<td>(short)0</td>
<td>控制占用存储空间的大数组</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>1 字节 8 bits</td>
<td>-2^7 ~ +2^7-1</td>
<td>(byte)0</td>
<td>底层文件处理</td>
</tr>
</tbody></table>
<ol>
<li>十六进制前缀 0x 或0X</li>
<li>八进制前缀 0</li>
<li>二进制前缀 0b 或 0B(Java 7 开始)</li>
<li>数字加下划线更易读，如 1_000_000，编译器会去掉(Java 7 开始)</li>
<li>没有后缀标识的整数默认为 int 类型</li>
</ol>
<h4 id="1-2-浮点"><a href="#1-2-浮点" class="headerlink" title="1.2 浮点"></a>1.2 浮点</h4><table>
<thead>
<tr>
<th>类型</th>
<th>包装类</th>
<th>存储需求</th>
<th>取值范围</th>
<th>零值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td>Double</td>
<td>8 字节 64 bits</td>
<td>大约-2^1024 ~ -2^-1074 —— 0 —— 2^-1074 ~ 2^1024（有效 15 位）</td>
<td>0.0d</td>
<td>后缀 D 或 d，最常用。</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>4 字节 32 bits</td>
<td>大约-2^128 ~ -2^-149 —— 0 —— 2^-149 ~ 2^128（有效 6~7 位）</td>
<td>0.0f</td>
<td>后缀 F 或 f，单精度库或大量数据</td>
</tr>
</tbody></table>
<ol>
<li>没有后缀F的浮点数默认是 double</li>
<li>浮点数不能绝对精确，因为二进制种无法精确表示 1&#x2F;10，不允许误差应使用 BigDecimal 类。</li>
</ol>
<p>浮点数的结构与整型不同，指数的底数为 2，尾数表示小数部分</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>符号位（S）</th>
<th>指数位（E）</th>
<th>尾数位（M）</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>1 bit</td>
<td>8 bits</td>
<td>23 bits</td>
</tr>
<tr>
<td>double</td>
<td>1 bit</td>
<td>11 bits</td>
<td>52 bits</td>
</tr>
</tbody></table>
<h4 id="1-3-字符"><a href="#1-3-字符" class="headerlink" title="1.3 字符"></a>1.3 字符</h4><table>
<thead>
<tr>
<th>类型</th>
<th>包装类</th>
<th>存储需求</th>
<th>取值范围</th>
<th>零值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>Character</td>
<td>2 字节 16 bits</td>
<td>int0-2^16-1 ,hex’\u0000’~’’\Uffff’</td>
<td>‘\u0000’</td>
<td>char 字面量要用单引号括起来。</td>
</tr>
</tbody></table>
<ul>
<li>转移序列 \u 可以出现在加引号的字符常量或字符串外（其它所有转义序列不可以）</li>
<li>警告：Unicode 转移序列会在解析代码前得到处理</li>
<li>警告：当心注释里的 \u，如“\u00A0”换行符，或“c:\user”，语法错误，因为没跟 4 个十六进制数</li>
<li>解决方案：字符串中用转义符“\”来去除“\u”造成的不必要影响</li>
</ul>
<h4 id="1-4-布尔"><a href="#1-4-布尔" class="headerlink" title="1.4 布尔"></a>1.4 布尔</h4><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。</p>
<p>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p>
<p>JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<p>整型和布尔之间不能转换，不能用 0 当作 false，可以使用条件表达式</p>
<h4 id="1-5-类型转换"><a href="#1-5-类型转换" class="headerlink" title="1.5 类型转换"></a>1.5 类型转换</h4><p>不要强制转换 boolean 类型，可用条件表达式</p>
<p>自动类型转换图示：byte -&gt; short(char) -&gt; int -&gt; long -&gt; float -&gt; double ，强制类型与之相反</p>
<h5 id="1）自动类型转换"><a href="#1）自动类型转换" class="headerlink" title="1）自动类型转换"></a>1）自动类型转换</h5><p>运算或方法调用时，系统会将较小的数据类型自动转换为较大的数据类型</p>
<ul>
<li>当使用 +、-、*、&#x2F;、% 运算符对基本类型进行运算时，转换为较大的数据类型，如最大的小于 int，则转为 int</li>
</ul>
<h5 id="2）强制类型转换"><a href="#2）强制类型转换" class="headerlink" title="2）强制类型转换"></a>2）强制类型转换</h5><p>强制类型将较大的数据类型转化为较小的数据类型，可能导致精度损失。</p>
<ul>
<li>当使用 +&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D; 运算符对基本类型进行运算时，运算符右边的数值将首先被强制转换成与运算符左边数值相同的类型，然后再执行运算，且运算结果与运算符左边数值类型相同。</li>
</ul>
<h3 id="2-包装类型"><a href="#2-包装类型" class="headerlink" title="2. 包装类型"></a>2. 包装类型</h3><ul>
<li>所有的基本类型都有一个与之对应的类。包装类都是声明为 final的，不可变，不可被继承。</li>
<li>对象引用存储在内存栈上，而对象本身的值存储在内存堆上。</li>
<li>对一个对象进行操作时，我们真正操作的是它的句柄。</li>
<li>自动装箱：基本类型自动转换成包装类，调用了 Integer.valueOf()</li>
<li>自动拆箱：包装类自动转换为基本类型，调用了 X.intValue()</li>
</ul>
<h4 id="2-1-大数值"><a href="#2-1-大数值" class="headerlink" title="2.1 大数值"></a>2.1 大数值</h4><ul>
<li>BigInteger 支持任意精度的整数。</li>
<li>BigDecimal 支持任意精度的浮点数字。</li>
<li>转换方法： valueOf</li>
<li>运算方法： add, multiply, divide 等</li>
</ul>
<h3 id="3-缓存池"><a href="#3-缓存池" class="headerlink" title="3. 缓存池"></a>3. 缓存池</h3><p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean：true, false</li>
<li>byte、short、int、long：-128 ~ 127</li>
<li>char：\u0000 ~ \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<h4 id="3-1-IntegerCache"><a href="#3-1-IntegerCache" class="headerlink" title="3.1 IntegerCache"></a>3.1 IntegerCache</h4><p>Integer 缓冲池 IntegerCache， 是静态类，上界可以通过参数调整。</p>
<p>加载的时候会初始化一个 int 数组，填上 -128 ~ 127 的值。</p>
<h4 id="3-2-valueOf-方法"><a href="#3-2-valueOf-方法" class="headerlink" title="3.2 valueOf() 方法"></a>3.2 valueOf() 方法</h4><p>valueOf() 方法会使用缓存池中的对象，多次调用会取得同一个对象的引用。</p>
<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/15/Java%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/">java基础</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8/">安全</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h2 id="一、类加载器"><a href="#一、类加载器" class="headerlink" title="一、类加载器"></a>一、类加载器</h2><h3 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1 类加载过程"></a>1 类加载过程</h3><p>虚拟机只加载程序执行时所需要的类文件。假设程序从 MyProgram.class 开始运行，下面是虚拟机执行的步骤：</p>
<ol>
<li>虚拟机有一个用于加载类文件的机制。</li>
<li>如果类拥有类型为另一个类的域，或者是拥有超类，那么这些类文件也会被加载。</li>
<li>接着，虚拟机执行类中的 main 方法。</li>
<li>如果 main 方法或者 main 调用的方法要用到更多的类，那么接下来就会加载这些类。</li>
</ol>
<p>每个Java程序至少拥有<strong>三个类加载器</strong>：</p>
<ul>
<li><p>启动类加载器(Bootstrap ClassLoader)</p>
<p>​	这个类加载器负责负责加载JDK中的核心类库，这个类加载器完全由JVM控制</p>
</li>
<li><p>扩展类加载器(Extendsion ClassLoader)</p>
<p>​	这个类加载器负责加载\lib\ext目录下的类库</p>
</li>
<li><p>应用程序类加载器(Application ClassLoader)</p>
<p>​	这个类加载器负责加载用户类路径(CLASSPATH)下的类库,一般我们编写的java类都是由这个类加载器加载</p>
</li>
</ul>
<h3 id="2-类加载器的层次结构"><a href="#2-类加载器的层次结构" class="headerlink" title="2 类加载器的层次结构"></a>2 类加载器的层次结构</h3><p>类加载器有一种父&#x2F;子关系。除了引导类加载器外，每个类加载器都有一个父类加载器。父类加载失败子类才加载。</p>
<p>如果插件被打包为 JAR 文件，那就可以直接用 URLClassLoader 类的实例去加载这些类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">URLClassLoader</span> <span class="variable">pluginLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[] &#123;url&#125;);</span><br><span class="line">Class&lt;?&gt; cl = pluginLoader.loadClass(<span class="string">&quot;mypackage.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以通过下面将其设置成为任何类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">t.setContextClassLoader(loader);</span><br></pre></td></tr></table></figure>

<p>助手方法可以获取这个上下文类加载器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> t.getCOntextClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> loader.loaderClass(className);</span><br></pre></td></tr></table></figure>

<p>当调用由不同的类加载器加载的插件类的方法时，进行上下文类加载器的设置是一种好的思路；或者，让助手方法的调用者设置上下文类加载器。</p>
<h3 id="3-将类加载器作为命名空间"><a href="#3-将类加载器作为命名空间" class="headerlink" title="3 将类加载器作为命名空间"></a>3 将类加载器作为命名空间</h3><p>同一虚拟机中，可以有两个类的类名和包名都相同。类是由它的全名和类加载器来确定的。</p>
<h3 id="4-编写自己的类加载器"><a href="#4-编写自己的类加载器" class="headerlink" title="4 编写自己的类加载器"></a>4 编写自己的类加载器</h3><p>编写自己的类加载器，只需要继承 ClassLoader 类，然后覆盖下面这个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass(String className)</span><br></pre></td></tr></table></figure>

<p>ClassLoader 超类的 loadClass 方法用于将类的加载操作委托给其父类加载器去进行，只有当该类尚未加载并且父类加载器也无法加载该类时，才调用 findClass 方法。</p>
<p>如果要实现该方法，必须做到以下几点：</p>
<ol>
<li>为来自本地文件系统或者其他来源的类加载其字节码</li>
<li>调用 ClassLoader 超类的 defineClass 方法，想虚拟机提供字节码。</li>
</ol>
<h3 id="5-字节码校验"><a href="#5-字节码校验" class="headerlink" title="5 字节码校验"></a>5 字节码校验</h3><p>当类加载器将新在加载的 Java 平台类的字节码传递给虚拟机，这些字节码首先要接受校验器的校验。校验器负责检查那些指令无法执行的明细那有破坏性的操作。出了系统类外，所有的类都要被校验。</p>
<p>下面是校验器执行的一些检查：</p>
<ul>
<li>变量要在使用之前进行初始化。</li>
<li>方法调用与对象引用类型之间要匹配。</li>
<li>访问私有类型和方法的规则没有被违反。</li>
<li>对本地变量的访问都落在运行时堆栈内。</li>
<li>运行时堆栈没有用溢出。</li>
</ul>
<h2 id="二、双亲委派原则"><a href="#二、双亲委派原则" class="headerlink" title="二、双亲委派原则"></a>二、双亲委派原则</h2><h3 id="1-双亲委派原则"><a href="#1-双亲委派原则" class="headerlink" title="1 双亲委派原则"></a>1 双亲委派原则</h3><p>一个类加载器受到类加载的请求，它会把这个请求转交到它的父加载器去请求，如果上级还有加载器，就继续把请求上传，直到启动类加载器。然后找到就返回给子加载器，直到第一个发出请求的类加载器。如果最后还是没有找到，就让子加载器自己去找</p>
<p><img src="https://imine141.github.io/images/1858901-20200325152628228-1073837913.png" alt="img"></p>
<h3 id="2-破坏双亲委派原则"><a href="#2-破坏双亲委派原则" class="headerlink" title="2 破坏双亲委派原则"></a>2 破坏双亲委派原则</h3><p>单一责任原则（SRP）不是绝对的。 它的存在有助于代码的可维护性和可读性。 但是您可能会不时看到解决方案，破坏SRP的模式，而且还可以。 其他原则也是如此，但是这次我想谈谈SRP。</p>
<p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。</p>
<h4 id="2-1-线程上下文类加载器（contextClassLoader）"><a href="#2-1-线程上下文类加载器（contextClassLoader）" class="headerlink" title="2.1 线程上下文类加载器（contextClassLoader）"></a>2.1 线程上下文类加载器（contextClassLoader）</h4><p>通过java.lang.Thread类中的<code>getContextClassLoader()</code>和 <code>setContextClassLoader(ClassLoader cl)</code>方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源，如下图所示，以jdbc.jar加载为例</p>
<p><img src="https://imine141.github.io/images/SouthEast.png" alt="img"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/07/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">分布式架构网络通信</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">分布式理论</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><div class="content"><h2 id="一、RPC（远程过程调用）"><a href="#一、RPC（远程过程调用）" class="headerlink" title="一、RPC（远程过程调用）"></a>一、RPC（远程过程调用）</h2><h4 id="1-RPC架构"><a href="#1-RPC架构" class="headerlink" title="1. RPC架构"></a>1. RPC架构</h4><ul>
<li><strong>客户端</strong>(Client)，服务的调用方。 </li>
<li><strong>客户端存根</strong>(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。 </li>
<li><strong>服务端</strong>(Server)，真正的服务提供者。 </li>
<li><strong>服务端存根</strong>(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法2</li>
</ul>
<h4 id="2-RPC调用过程"><a href="#2-RPC调用过程" class="headerlink" title="2.RPC调用过程"></a>2.RPC调用过程</h4><p><img src="E:\project\iMineBlog\source\images\1608773784559.png" alt="调用过程"></p>
<p>RPC的目标是要把2、3、4、7、8、9这些步骤都封装起来。</p>
<p>注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。</p>
<p>在java中RPC框架比较多，常见的有Hessian、gRPC、Thrift、Dubbo 等，其实对于RPC框架而言，核心模块就是通讯和序列化</p>
<p>ps：RPC并不是一个具体的技术，而是指整个网络远程调用过程。</p>
<h2 id="二、RMI（远程方法调用）"><a href="#二、RMI（远程方法调用）" class="headerlink" title="二、RMI（远程方法调用）"></a>二、RMI（远程方法调用）</h2><p>Java RMI 指的是远程方法调用 (Remote Method Invocation),是java原生支持的远程调用</p>
<h4 id="1-RMI的架构"><a href="#1-RMI的架构" class="headerlink" title="1.RMI的架构"></a>1.RMI的架构</h4><p>客户端：</p>
<ul>
<li><p>存根&#x2F;桩(Stub)：远程对象在客户端上的代理； </p>
</li>
<li><p>远程引用层(Remote Reference Layer)：解析并执行远程引用协议； </p>
</li>
<li><p>传输层(Transport)：发送调用、传递远程方法参数、接收远程方法执行结果。</p>
</li>
</ul>
<p>服务端：</p>
<ul>
<li>骨架(Skeleton)：读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值； </li>
<li>远程引用层(Remote Reference Layer)：处理远程引用后向骨架发送远程方法调用；</li>
<li>传输层(Transport)：监听客户端的入站连接，接收并转发调用到远程引用层。</li>
</ul>
<p>注册表(Registry):</p>
<ul>
<li>以URL形式注册远程对象，并向客户端回复对远程对象的引用。</li>
</ul>
<p><img src="E:\project\iMineBlog\source\images\1608774595079.png" alt="rmi"></p>
<h3 id="RMI和RPC的区别"><a href="#RMI和RPC的区别" class="headerlink" title="RMI和RPC的区别"></a>RMI和RPC的区别</h3><p><strong>1：方法调用方式不同：</strong></p>
<ul>
<li>RMI中是通过在客户端的Stub对象作为远程接口进行远程方法的调用。每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用。</li>
<li>RPC中是通过网络服务协议向远程主机发送请求，请求包含了一个参数集和一个文本值，通常形成“classname.methodname(参数集)”的形式。RPC远程主机就去搜索与之相匹配的类和方法，找到后就执行方法并把结果编码，通过网络协议发回。</li>
</ul>
<p><strong>2：适用语言范围不同：</strong></p>
<ul>
<li>RMI只用于Java；</li>
<li>RPC是网络服务协议，与操作系统和语言无关。</li>
</ul>
<p><strong>3：调用结果的返回形式不同：</strong></p>
<ul>
<li>Java是面向对象的，所以RMI的调用结果可以是对象类型或者基本数据类型；</li>
<li>RMI的结果统一由外部数据表示，这种语言抽象了字节序类和数据类型结构之间的差异。</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2024 By iMine</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>