<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="iMine"><meta name="copyright" content="iMine"><title>iMineのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 7.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">iMine</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">74</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iMineのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">iMineのBlog</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/07/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/">分布式系统设计策略</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">分布式理论</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><div class="content"><p>在分布式环境下，有几个问题是普遍关心的，我们称之为设计策略:</p>
<p>如何检测当前节点还活着?<br>如何保障高可用?<br>容错处理<br>负载均衡</p>
<h2 id="一、心跳检测"><a href="#一、心跳检测" class="headerlink" title="一、心跳检测"></a>一、心跳检测</h2><p>没有检测到心跳的时候，不代表节点死亡，可能是忙碌中。</p>
<p>通过下面两种方式来检测：</p>
<ul>
<li>周期检测心跳机制</li>
<li>累计失效检测机制</li>
</ul>
<h4 id="周期检测心跳机制"><a href="#周期检测心跳机制" class="headerlink" title="周期检测心跳机制"></a>周期检测心跳机制</h4><p>Server端每间隔 t 秒向Node集群发起监测请求，设定超时时间，如果超过超时时间，则判断“死亡”。</p>
<h4 id="累计失效检测机制"><a href="#累计失效检测机制" class="headerlink" title="累计失效检测机制"></a>累计失效检测机制</h4><p>在周期检测心跳机制的基础上，统计一定周期内节点的返回情况(包括超时及正确返回)，以此计算节点的“死亡”概率。另外，对于宣告“濒临死亡”的节点可以发起有限次数的重试，以作进一步判断。</p>
<p>通过周期检测心跳机制、累计失效检测机制可以帮助判断节点是否“死亡”，如果判断“死亡”，可以把该节点踢出集群</p>
<h2 id="二、高可用设计"><a href="#二、高可用设计" class="headerlink" title="二、高可用设计"></a>二、高可用设计</h2><p>系统高可用性的常用设计模式包括三种:主备(Master-SLave)、互备(Active-Active)和集群(Cluster)模式。</p>
<h4 id="1-主备模式"><a href="#1-主备模式" class="headerlink" title="1.主备模式"></a>1.主备模式</h4><p>当主机宕机时，备机接管主机的一切工作</p>
<h4 id="2-互备模式"><a href="#2-互备模式" class="headerlink" title="2.互备模式"></a>2.互备模式</h4><p>互备模式指两台主机同时运行各自的服务工作且相互监测情况</p>
<h4 id="3-集群模式"><a href="#3-集群模式" class="headerlink" title="3.集群模式"></a>3.集群模式</h4><p>多个节点在运行，同时可以通过主控节点分担服务请求</p>
<h2 id="三、容错性"><a href="#三、容错性" class="headerlink" title="三、容错性"></a>三、容错性</h2><p>容错的处理是保障分布式环境下相应系统的高可用或者健壮性，典型的案例就是对于缓存穿透问题的解决方案</p>
<p>我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据 库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，或者有人恶意攻击</p>
<p>如频繁发起为id为“-1”的条件进行查询，可能DB就挂掉了。</p>
<p>那这种问题有什么好办法解决呢?</p>
<p>一个比较巧妙的方法是，可以将这个不存在的key预先设定一个值。比如，key&#x3D;“null”。在返回这个null值的时候， 我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是null，则可以认为这时候key有值 了，从而避免了透传到数据库，把大量的类似请求挡在了缓存之中。</p>
<h2 id="四、负载均衡"><a href="#四、负载均衡" class="headerlink" title="四、负载均衡"></a>四、负载均衡</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/06/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/">分布式算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">分布式理论</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><div class="content"><h2 id="一、分布式理论-一致性算法-Paxos"><a href="#一、分布式理论-一致性算法-Paxos" class="headerlink" title="一、分布式理论:一致性算法 Paxos"></a>一、分布式理论:一致性算法 Paxos</h2><h3 id="1-Paxos解决了什么问题？"><a href="#1-Paxos解决了什么问题？" class="headerlink" title="1. Paxos解决了什么问题？"></a>1. Paxos解决了什么问题？</h3><p>Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致</p>
<h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h3><p><strong>提案proposal</strong></p>
<ul>
<li>提案编号（proposal ID）</li>
<li>提案的值（value）</li>
</ul>
<p><strong>Paxos的三种角色</strong></p>
<ul>
<li>Proposer提案人</li>
<li>Acceptor决策者</li>
<li>Learners终决策的学习者 （就是最终将决策完的value，落实到下来。到物理机）</li>
</ul>
<p>	</p>
<h3 id="3、Paxos的流程"><a href="#3、Paxos的流程" class="headerlink" title="3、Paxos的流程"></a>3、Paxos的流程</h3><h4 id="提案要求"><a href="#提案要求" class="headerlink" title="提案要求"></a>提案要求</h4><p>对于任意的Mn和Vn,如果提案[Mn,Vn]被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个： </p>
<ul>
<li>要么S中每个Acceptor都没有接受过编号小于Mn的提案。  </li>
<li>要么S中所有Acceptor批准的所有编号小于Mn的提案中，编号大的那个提案的value值为Vn</li>
</ul>
<h4 id="proposer生成提案"><a href="#proposer生成提案" class="headerlink" title="proposer生成提案"></a>proposer生成提案</h4><p> <strong>第一</strong>，Proposer选择一个新的提案编号N，然后向某个Acceptor集合（半数以上）发送请求，要求该集合中的每个 Acceptor做出如下响应（response）</p>
<p>（a）Acceptor向Proposer承诺保证不再接受任何编号小于N的提案。</p>
<p>（b）如果Acceptor已经接受过提案，那么就向Proposer反馈已经接受过的编号小于N的，但为大编号的提案的值</p>
<p>我们将该请求称为编号为N的<strong>Prepare请求</strong></p>
<p><strong>第二</strong>，如果Proposer收到了半数以上的Acceptor的响应，那么它就可以生成编号为N，Value为V的提案[N,V]。这里的V是所有的响应中编号大的提案的Value。如果所有的响应中都没有提案，那 么此时V就可以由Proposer 自己选择。 </p>
<p>生成提案后，Proposer将该提案发送给半数以上的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong></p>
<h4 id="accept接受提案"><a href="#accept接受提案" class="headerlink" title="accept接受提案"></a>accept接受提案</h4><p>一个Acceptor可能会受到来自Proposer的两种请求，分别是Prepare请求和Accept请求，对这两类请求作出响应的条件分别如</p>
<ul>
<li>Prepare请求：Acceptor可以在任何时候响应一个Prepare请求</li>
<li>Accept请求：在不违背Accept现有承诺的前提下，可以任意响应Accept请求</li>
</ul>
<h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p>Acceptor忽略编号小于当前最大变好的Prepare请求</p>
<p><img src="E:\project\iMineBlog\source\images\1608776443408.png" alt="1608776443408"></p>
<h3 id="4-Learner学习被选定value"><a href="#4-Learner学习被选定value" class="headerlink" title="4. Learner学习被选定value"></a>4. Learner学习被选定value</h3><p><strong>方案一：</strong> </p>
<p>Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准，因此，简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Learner</p>
<p>很显然，这种做法虽然可以让Learner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Learner逐个进行一次通信，通信的次数至少为二者个数的乘积</p>
<p><strong>方案二：</strong></p>
<p>另一种可行的方案是，我们可以让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的Learner（称为主Learner）, 各个Learner之间可以通过消息通信来互相感知提案的选定情况，基于这样的前提，当主Learner被通知一个提案已经被选定时，它会负责通知其他的learner</p>
<p>在这种方案中，Acceptor首先会将得到批准的提案发送给主Learner,再由其同步给其他Learner。因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的learner，但其通信次数却大大减少了，通常只是 Acceptor和Learner的个数总和，但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障  </p>
<p><strong>方案三：</strong></p>
<p>在讲解方案二的时候，我们提到，方案二大的问题在于主Learner存在单点问题，即主Learner随时可能出现故 障，因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的 Learner集合，该集合中每个Learner都可以在一个提案被选定后通知其他的Learner。这个Learner集合中的 Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高 </p>
<h3 id="5-如何保障Paxos算法的活性"><a href="#5-如何保障Paxos算法的活性" class="headerlink" title="5. 如何保障Paxos算法的活性"></a>5. 如何保障Paxos算法的活性</h3><p>假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的提案，导致终陷入死循环，没有 value被选定</p>
<p><strong>解决</strong>：通过选取主Proposer，并规定只有主Proposer才能提出议案。这样一来只要主Proposer和过半的Acceptor 能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准，这样通过选择一个主Proposer，整套Paxos算法就能够保持活性</p>
<h2 id="三、分布式理论-一致性算法-Raft"><a href="#三、分布式理论-一致性算法-Raft" class="headerlink" title="三、分布式理论:一致性算法 Raft"></a>三、分布式理论:一致性算法 Raft</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>Raft</strong> 是一种为了管理复制日志的一致性算法。 </p>
<p>Raft将一致性算法分解成了3模块 </p>
<ol>
<li>领导人选举</li>
<li>日志复制 </li>
<li>安全性</li>
</ol>
<p><strong>领导人角色</strong></p>
<ul>
<li>领导者(leader)：处理客户端交互，日志复制等动作，一般一次只有一个领导者 </li>
<li>候选者(candidate)：候选者就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者 </li>
<li>跟随者(follower)：类似选民，完全被动的角色，这样的服务器等待被通知投票</li>
</ul>
<p><strong>节点异常</strong></p>
<ul>
<li>leader不可用</li>
<li>follower不可用</li>
<li>多个candidate或多个leader</li>
<li>新节点加入集群</li>
</ul>
<h3 id="异常的解决"><a href="#异常的解决" class="headerlink" title="异常的解决"></a>异常的解决</h3><p><strong>1. leader 不可用；</strong></p>
<ul>
<li>一般情况下，leader 节点定时发送 heartbeat 到 follower 节点。</li>
<li>由于某些异常导致 leader 不再发送 heartbeat ，或 follower 无法收到 heartbeat 。</li>
<li>当某一 follower 发生 election timeout 时，其状态变更为 candidate，并向其他 follower发起投票。</li>
<li>当超过半数的 follower 接受投票后，这一节点将成为新的 leader，leader 的步进数加1并开始向follower同步日志</li>
<li>当一段时间之后，如果之前的 leader 再次加入集群，则两个 leader 比较彼此的步进数，步进数低的leader将切换自己的状态为follower。</li>
<li>较早前leader中不一致的日志将被清除，并与现有 leader中的日志保持一致。</li>
</ul>
<p><strong>2. follower 不可用；</strong> </p>
<ul>
<li>集群中的某个 follower 节点发生异常，不再同步日志以及接收 heartbeat。</li>
<li>经过一段时间之后，原来的 follower 节点重新加入集群。</li>
<li>这一节点的日志将从当时的 leader 处同步。</li>
</ul>
<p><strong>3. 多个 candidate 或多个 leader；</strong> </p>
<ul>
<li>初始状态下集群中的所有节点都处于 follower 状态。</li>
<li>两个节点同时成为 candidate 发起选举。</li>
<li>两个 candidate 都只得到了少部分 follower 的接受投票。</li>
<li>candidate 继续向其他的 follower 询问。</li>
<li>由于一些 follower 已经投过票了，所以均返回拒绝接受。</li>
<li>candidate 也可能向一个 candidate 询问投票。</li>
<li>在步进数相同的情况下，candidate 将拒绝接受另一个 candidate 的请求。</li>
<li>由于第一次未选出 leader，candidate 将随机选择一个等待间隔（150ms ~ 300ms）再次发起投	票。</li>
<li>如果得到集群中半数以上的 follower 的接受，这一 candidate 将成为 leader。</li>
<li>稍后另一个 candidate 也将再次发起投票。</li>
<li>由于集群中已经选出 leader，candidate 将收到拒绝接受的投票。</li>
<li>在被多数节点拒绝之后，并已知集群中已存在 leader 后，这一 candidate 节点将终止投票请求、切换为 follower，从 leader 节点同步日志。</li>
</ul>
<h3 id="日志复制过程"><a href="#日志复制过程" class="headerlink" title="日志复制过程"></a>日志复制过程</h3><ul>
<li>客户端的每一个请求都包含被复制状态机执行的指令。 </li>
<li>leader把这个指令作为一条新的日志条目添加到日志中，然后并行发起 RPC 给其他的服务器，让他们复制这条信息。</li>
<li>跟随者响应ACK,如果 follower 宕机或者运行缓慢或者丢包，leader会不断的重试，直到所有的 follower 终都复制了所有的日志条目。 </li>
<li>通知所有的Follower提交日志，同时领导人提交这条日志到自己的状态机中，并返回给客户端</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E7%90%86/">分布式定理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">分布式理论</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><div class="content"><h2 id="1-分布式理论：CAP定理"><a href="#1-分布式理论：CAP定理" class="headerlink" title="1. 分布式理论：CAP定理"></a>1. 分布式理论：CAP定理</h2><p><strong>CAP 理论含义</strong>是，一个分布式系统不可能同时满足一致性（C:Consistency)，可用性（A: Availability）和分区容错 性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的2个。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>C 一致性</td>
<td>分布式系统当中的一致性指的是所有节点的数据一致，或者说是所有副本的数据一致</td>
</tr>
<tr>
<td>A 可用性</td>
<td>Reads and writes always succeed. 也就是说系统一直可用，而且服务一直保持正常</td>
</tr>
<tr>
<td>P 分区容错性</td>
<td>系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务</td>
</tr>
</tbody></table>
<h4 id="C-如何实现一致性"><a href="#C-如何实现一致性" class="headerlink" title="C - 如何实现一致性?"></a>C - 如何实现一致性?</h4><ol>
<li>写入主数据库后要数据同步到从数据库</li>
<li>写入主数据库后,在向从数据库同步期间要将从数据库锁定, 等待同步完成后在释放锁,以免在写新数据后,向从数据<br>库查询到旧的数据.</li>
</ol>
<h4 id="A-如何实现可用性"><a href="#A-如何实现可用性" class="headerlink" title="A - 如何实现可用性?"></a>A - 如何实现可用性?</h4><ol>
<li>写入主数据库后要将数据同步到从数据库</li>
<li>由于要保证数据库的可用性,不可以将数据库中资源锁定</li>
<li>即使数据还没有同步过来,从数据库也要返回查询数据, 哪怕是旧数据,但不能返回错误和超时</li>
</ol>
<h4 id="P-如何实现分区容错性"><a href="#P-如何实现分区容错性" class="headerlink" title="P - 如何实现分区容错性?"></a>P - 如何实现分区容错性?</h4><ol>
<li>尽量使用异步取代同步操作,举例 使用异步方式将数据从主数据库同步到从数据库, 这样节点之间能有效的实现松耦合;</li>
<li>添加数据库节点,其中一个从节点挂掉,由其他从节点提供服务</li>
</ol>
<h4 id="CAP只能3选2"><a href="#CAP只能3选2" class="headerlink" title="CAP只能3选2"></a>CAP只能3选2</h4><ul>
<li><p>舍弃A(可用性)，保留CP(一致性和分区容错性)</p>
<p>一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个 时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。</p>
</li>
<li><p>舍弃C(一致性)，保留AP(可用性和分区容错性)</p>
<p>这种是大部分的分布式系统的设计，保证高可用和分区容错，但是会牺牲一致性。</p>
</li>
<li><p>舍弃P(分区容错性)，保留CA(一致性和可用性)</p>
<p>如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在</p>
</li>
</ul>
<h2 id="2-分布式理论：BASE-理论"><a href="#2-分布式理论：BASE-理论" class="headerlink" title="2.分布式理论：BASE 理论"></a>2.分布式理论：BASE 理论</h2><h4 id="BASE："><a href="#BASE：" class="headerlink" title="BASE："></a>BASE：</h4><ul>
<li>Basically Available(基本可用)</li>
<li>Soft state（软状态）</li>
<li>Eventually consistent（最终一致性）</li>
</ul>
<h4 id="1-Basically-Available-基本可用"><a href="#1-Basically-Available-基本可用" class="headerlink" title="1.Basically Available(基本可用)"></a>1.Basically Available(基本可用)</h4><ul>
<li>响应时间上的损失：响应时间增加</li>
<li>功能损失：服务降级</li>
</ul>
<h4 id="2-Soft-state（软状态）"><a href="#2-Soft-state（软状态）" class="headerlink" title="2.Soft state（软状态）"></a>2.Soft state（软状态）</h4><p>允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本之间进行数据同步的过程中存在延迟。</p>
<h4 id="3-Eventually-consistent（最终一致性）"><a href="#3-Eventually-consistent（最终一致性）" class="headerlink" title="3.Eventually consistent（最终一致性）"></a>3.Eventually consistent（最终一致性）</h4><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<h2 id="3-分布式理论：一致性协议-2PC"><a href="#3-分布式理论：一致性协议-2PC" class="headerlink" title="3.分布式理论：一致性协议 2PC"></a>3.分布式理论：一致性协议 2PC</h2><h4 id="1-什么是2PC？"><a href="#1-什么是2PC？" class="headerlink" title="1. 什么是2PC？"></a>1. 什么是2PC？</h4><ul>
<li>2 两个阶段</li>
<li>p 准备阶段</li>
<li>c 提交阶段</li>
</ul>
<h4 id="2-2PC（二阶段提交）流程"><a href="#2-2PC（二阶段提交）流程" class="headerlink" title="2. 2PC（二阶段提交）流程"></a>2. 2PC（二阶段提交）流程</h4><p><strong>阶段一：准备阶段</strong></p>
<ol>
<li>事务询问，协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。 </li>
<li>执行事务  (写本地的Undo&#x2F;Redo日志) </li>
<li>各参与者向协调者反馈事务询问的响应</li>
</ol>
<p><strong>阶段二：提交阶段</strong></p>
<ol>
<li>发送提交请求：协调者向所有参与者发出 commit 请求。 </li>
<li>事务提交：参与者收到 commit 请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。 </li>
<li>反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 信息。 </li>
<li>完成事务：协调者接收到所有参与者反馈的 Ack 信息后，完成事务。</li>
</ol>
<h4 id="3-2PC的缺点"><a href="#3-2PC的缺点" class="headerlink" title="3. 2PC的缺点"></a>3. 2PC的缺点</h4><ul>
<li>同步阻塞：一个参与者提交阶段，只有等到所有参与者都提交了，才能做其他操作</li>
<li>单点问题：协调者挂了</li>
<li>数据不一致：commit失败</li>
<li>过于保守：参与者挂了，只能通过协调者的策略来处理</li>
</ul>
<h2 id="4-分布式理论：一致性协议-3PC"><a href="#4-分布式理论：一致性协议-3PC" class="headerlink" title="4.分布式理论：一致性协议 3PC"></a>4.分布式理论：一致性协议 3PC</h2><p>3PC （将2PC的“提交事务请求”分为了两步），三阶段引入超时机制。同时在协调者和参与者中都引入超时机制，参与者会在协调者超时后，自动提交事务。</p>
<h4 id="1-3pc（三阶段提交）过程"><a href="#1-3pc（三阶段提交）过程" class="headerlink" title="1. 3pc（三阶段提交）过程"></a>1. 3pc（三阶段提交）过程</h4><p><strong>阶段一 CanCommit</strong></p>
<ul>
<li>事务询问</li>
<li>参与者反馈响应</li>
</ul>
<p><strong>阶段二 PreCommit</strong></p>
<ul>
<li>发送预提交请求</li>
<li>事务预提交</li>
<li>各参与者反馈结果</li>
</ul>
<p><strong>阶段三 DoCommit</strong>	</p>
<ul>
<li>发送提交请求</li>
<li>事务提交</li>
<li>反馈提交结果</li>
<li>完成事务</li>
</ul>
<h4 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h4><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>
<p><strong>总结</strong>：3pc相对于2pc，添加了超时机制，precommit中保障了各个节点状态是一致的。<strong>但是，无论是2pc 还是 3pc 都无法完全解决分布式一致性的问题</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">分布式理论</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">分布式理论</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><div class="content"><h2 id="1-分布式概念"><a href="#1-分布式概念" class="headerlink" title="1. 分布式概念"></a>1. 分布式概念</h2><p>分布式系统，就是一个业务拆分成多个子业务，分布在不同的服务器节点，共同构成的系统称为分布式系统</p>
<p><strong>分布式与集群的区别</strong></p>
<ul>
<li><p>集群：多个人在一起作同样的事 。 </p>
</li>
<li><p>分布式 ：多个人在一起作不同的事 。</p>
</li>
</ul>
<p><strong>分布式系统的特点</strong></p>
<ul>
<li>分布性 </li>
<li>对等性</li>
<li>并发性</li>
<li>缺乏全局时钟</li>
<li>故障总是会发生</li>
</ul>
<p><strong>分布式的演变过程</strong></p>
<ul>
<li>阶段一：单应用架构 （包括应用、数据库都在一起）</li>
<li>阶段二：应用服务器与数据库服务器分离（应用服务器与数据库拆分）</li>
<li>阶段三：应用服务器集群（将应用服务器拆分为集群）</li>
<li>阶段四：应用服务器负载客户</li>
<li>阶段五：数据库读写分离</li>
<li>阶段六：添加搜索引擎缓解读库压力</li>
<li>阶段七：添加缓存机制缓解读库压力</li>
<li>阶段八：数据库水平&#x2F;垂直拆分</li>
<li>阶段九：应用拆分</li>
<li>阶段十：服务化</li>
</ul>
<h2 id="2-分布式面临的问题"><a href="#2-分布式面临的问题" class="headerlink" title="2. 分布式面临的问题"></a><strong>2. 分布式面临的问题</strong></h2><p><strong>1) 通信异常</strong></p>
<p>就是网络情况不好，出现消息丢失和消息延迟等现象</p>
<p><strong>2) 网络分区</strong></p>
<p>因为网络异常，分布式系统中部分节点之间的网络延迟不断增大，最终只有部分节点可以正常通讯，另外的节点不能正常通讯，这个时候就会发生网络分区。这样分布式系统就会出现局部小集群，这就是<strong>脑裂问题</strong>。小集群回去执行原来整个系统要完成的事情。会产生对分布式一致性的挑战</p>
<p><strong>3) 节点故障</strong></p>
<p>节点故障是分布式系统下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或”僵死”现象，根据经验来说，每个节点都有可能出现故障，并且经常发生</p>
<p><strong>4) 三态</strong></p>
<p> 三态是，成功，失败，超时。分布式系统中，由于网络是不可靠的，虽然绝大部分情况下，网络通信能够接收到成功或失败的响应，但当网络出现异常的情况下，就会出现超时现象，通常有以下两种情况:</p>
<ol>
<li><p>由于网络原因，该请求并没有被成功的发送到接收方，而是在发送过程就发生了丢失现象。</p>
</li>
<li><p>该请求成功的被接收方接收后，并进行了处理，但在响应反馈给发送方过程中，发生了消息丢失现象。</p>
</li>
</ol>
<h2 id="3-分布式理论：一致性"><a href="#3-分布式理论：一致性" class="headerlink" title="3. 分布式理论：一致性"></a>3. 分布式理论：一致性</h2><p><strong>1）分布式一致性</strong></p>
<p>分布式数据一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。</p>
<p><strong>2）副本一致性</strong></p>
<p>因为分布式系统会存在网络延迟等问题，在副本拷贝时，就会出现同步不一致的问题</p>
<p><strong>3）数据一致性分类</strong></p>
<ul>
<li><p><strong>强一致性</strong></p>
<p>用户要求写什么，读出来就是什么，用户体验好，但实现起来困难</p>
</li>
<li><p><strong>弱一致性</strong></p>
<p>数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到 </p>
</li>
<li><p><strong>最终一致性 （最终一致性就是弱一致性）</strong></p>
</li>
<li><p><strong>读写一致性</strong></p>
<p>用户读取自己写入结果的一致性，保证用户永远能够第一时间看到自己更新的内容。 比如我们发一条朋友圈，朋友圈的内容是不是第一时间被朋友看见不重要，但是一定要显示在自己的列表上.</p>
<p><strong>解决方案:</strong></p>
<p>​	<strong>方案1</strong>:一种方案是对于一些特定的内容我们每次都去主库读取。 (问题主库压力大) </p>
<p>​	<strong>方案2</strong>:我们设置一个更新时间窗口，在刚刚更新的一段时间内，我们默认都从主库读取，过了这个窗口之后，我们会挑选最近有过更新的从库进行读取 </p>
<p>​	<strong>方案3</strong>:我们直接记录用户更新的时间戳，在请求的时候把这个时间戳带上，凡是最后更新时间小于这个时间戳的从库都不予以响应。</p>
</li>
<li><p><strong>单调读一致性</strong></p>
<p>本次读到的数据不能比上次读到的旧。</p>
<p>由于主从节点更新数据的时间不一致，导致用户在不停地刷新的时候，有时候能刷出来，再次刷新之后会发现数据不见了，再刷新又可能再刷出来，就好像遇见灵异事件一样</p>
<p><strong>解决方案:</strong></p>
<p>就是根据用户ID计算一个hash值，再通过hash值映射到机器。同一个用户不管怎么刷新，都只会被映射到同 一台机器上。这样就保证了不会读到其他从库的内容，带来用户体验不好的影响。</p>
</li>
<li><p><strong>因果一致性</strong></p>
<p>指的是:如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</p>
</li>
<li><p><strong>最终一致性</strong></p>
<p>最终一致性是所有分布式一致性模型当中最弱的。可以认为是没有任何优化的“最”弱一致性，它的意思是说，我不考虑所有的中间状态的影响，只保证当没有新的更新之后，经过一段时间之后，最终系统内所有副本的数据是正确的。 它最大程度上保证了系统的并发能力，也因此，在高并发的场景下，它也是使用最广的一致性模型。</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/01/Effective%20java/%E5%B9%B6%E5%8F%91/">并发</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/effective-java/">effective java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/effectivejava/">effectivejava</a></span><div class="content"><h3 id="第-78-条：同步访问共享的可变数据"><a href="#第-78-条：同步访问共享的可变数据" class="headerlink" title="第 78 条：同步访问共享的可变数据"></a>第 78 条：同步访问共享的可变数据</h3><h3 id="第-79-条：避免过度同步"><a href="#第-79-条：避免过度同步" class="headerlink" title="第 79 条：避免过度同步"></a>第 79 条：避免过度同步</h3><h3 id="第-80-条：executor-和-task-优先于线程"><a href="#第-80-条：executor-和-task-优先于线程" class="headerlink" title="第 80 条：executor 和 task 优先于线程"></a>第 80 条：executor 和 task 优先于线程</h3><ul>
<li>Executor.newCachedThreadPool：小程序，轻载的服务器</li>
<li>Executor.newFixedThreadPool：大负载的服务器</li>
<li>ThreadPoolExecutor：最大限度的控制</li>
<li>ScheduledThreadPoolExecutor：代替 java.util.Timer</li>
</ul>
<h3 id="第-81-条：并发工具优先于-wait-和-notify"><a href="#第-81-条：并发工具优先于-wait-和-notify" class="headerlink" title="第 81 条：并发工具优先于 wait 和 notify"></a>第 81 条：并发工具优先于 wait 和 notify</h3><p>java.util.concurrent 中更高级的工具分三类：Executor Framework，并发集合（Concurrent Collection）以及同步器（Synchronizer）。</p>
<p>优先使用 ConcurrentHashMap，而不是 Collections.synchronizedMap 或者 Hashtable</p>
<p>最常用的同步器是 CountDownLatch 和 Semaphore，不常用的是 Barrier 和 Exchanger。</p>
<p>对于间歇式定时,应该始终使用 System.nanoTime 而不是 System.cucurrentTimeMills。</p>
<h3 id="第-82-条：线程安全性的文档化"><a href="#第-82-条：线程安全性的文档化" class="headerlink" title="第 82 条：线程安全性的文档化"></a>第 82 条：线程安全性的文档化</h3><p>一个类为了可被多个线程安全使用，必须在文档中清楚地说明它所支持的线程安全性级别。</p>
<h3 id="第-83-条：慎用延迟初始化"><a href="#第-83-条：慎用延迟初始化" class="headerlink" title="第 83 条：慎用延迟初始化"></a>第 83 条：慎用延迟初始化</h3><p>对于延迟初始化，最好建议“除非绝对必要，否则就不要那么做”。延迟化降低了初始化类或者创建实例的开销，却增加了访问被延迟初始化的域的开销。</p>
<p>如果域只是在类的实例部分被访问，并且初始化这个域的开销很高，可能就值得进行延迟初始化。</p>
<ul>
<li>静态域：lazy initialization holder class 模式。</li>
<li>实例域：双重检查模式。</li>
</ul>
<h3 id="第-84-条：不要依赖于线程调度器"><a href="#第-84-条：不要依赖于线程调度器" class="headerlink" title="第 84 条：不要依赖于线程调度器"></a>第 84 条：不要依赖于线程调度器</h3><p>不要让应用程序的并发性依赖于线程调度器</p>
<p>不要依赖 Thread.yield 和线程优先级</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/31/Effective%20java/%E5%BC%82%E5%B8%B8/">异常</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/effective-java/">effective java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/effectivejava/">effectivejava</a></span><div class="content"><h3 id="第-69-条：只针对异常的情况才使用异常"><a href="#第-69-条：只针对异常的情况才使用异常" class="headerlink" title="第 69 条：只针对异常的情况才使用异常"></a>第 69 条：只针对异常的情况才使用异常</h3><p>如果在 try、catch、finally 块中都抛出了异常，只是只有一个异常可被传播到外界。</p>
<p>请不要在 try 块中发出对 return、break 或 continue 的调用，万一无法避免，一定要确保 finally 的存在不会改变函数的返回值（比如说抛异常、return 以及其他任何引起程序退出的调用）。因为那样会引起流程混乱或返回值不确定，如果有返回值最好在 try 与 finally 外返回。</p>
<p>如果构造器调用的代码需要抛出异常，就不要在构造器处理它，而是直接在构造器声明上 throws 出来</p>
<h3 id="第-70-条：对可恢复的情况使用受检异常-对编程错误使用运用时异常"><a href="#第-70-条：对可恢复的情况使用受检异常-对编程错误使用运用时异常" class="headerlink" title="第 70 条：对可恢复的情况使用受检异常,对编程错误使用运用时异常"></a>第 70 条：对可恢复的情况使用受检异常,对编程错误使用运用时异常</h3><h3 id="第-71-条：避免不必要地使用受检异常"><a href="#第-71-条：避免不必要地使用受检异常" class="headerlink" title="第 71 条：避免不必要地使用受检异常"></a>第 71 条：避免不必要地使用受检异常</h3><h3 id="第-72-条：优先使用标准异常"><a href="#第-72-条：优先使用标准异常" class="headerlink" title="第 72 条：优先使用标准异常"></a>第 72 条：优先使用标准异常</h3><h3 id="第-73-条：抛出与抽象对象相对应的异常"><a href="#第-73-条：抛出与抽象对象相对应的异常" class="headerlink" title="第 73 条：抛出与抽象对象相对应的异常"></a>第 73 条：抛出与抽象对象相对应的异常</h3><p>处理底层异常最好的方法首选是阻止底层异常的发生，如果不能阻止或者处理底层异常时，一般的做法是使用异常转换（包括异常链转换），除非底层方法碰巧可以保证抛出的异常对高层也合适才可以将底层异常直接从底层传播到高层。</p>
<h3 id="第-74-条：每个方法抛出的异常都要有文档描述"><a href="#第-74-条：每个方法抛出的异常都要有文档描述" class="headerlink" title="第 74 条：每个方法抛出的异常都要有文档描述"></a>第 74 条：每个方法抛出的异常都要有文档描述</h3><p>如果一个方法可能抛出多个异常类，则不要使用“快捷方式”声明它会抛出这此异常类的某个超类。永远不要声明一个方法“throws Exception”，或者更糟的是声明“throws Throwable”。</p>
<p>要为你编写的每个方法所能摆好出的每个异常建立文档，对于未受检和受检异常，以及对于抽象的和具体的方法也都一样。</p>
<h3 id="第-75-条：异常信息中要包含足够详细的异常细节消息"><a href="#第-75-条：异常信息中要包含足够详细的异常细节消息" class="headerlink" title="第 75 条：异常信息中要包含足够详细的异常细节消息"></a>第 75 条：异常信息中要包含足够详细的异常细节消息</h3><h3 id="第-76-条：努力使失败保持原子性"><a href="#第-76-条：努力使失败保持原子性" class="headerlink" title="第 76 条：努力使失败保持原子性"></a>第 76 条：努力使失败保持原子性</h3><p>作为方法规范的一部分，任何一个异常都不应该改变对象调用该方法之前的状态，如果这条规则被违反，则API文档中应该清楚的指明对象将会处于什么样的状态。</p>
<h3 id="第-77-条：不要忽略异常"><a href="#第-77-条：不要忽略异常" class="headerlink" title="第 77 条：不要忽略异常"></a>第 77 条：不要忽略异常</h3><p>空的 catch 块至少应该包含一条说明，用来解释为什么忽略这个异常是合适的。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/30/Effective%20java/%E6%96%B9%E6%B3%95/">方法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/effective-java/">effective java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/effectivejava/">effectivejava</a></span><div class="content"><h3 id="第-49-条：检查参数的有效性"><a href="#第-49-条：检查参数的有效性" class="headerlink" title="第 49 条：检查参数的有效性"></a>第 49 条：检查参数的有效性</h3><p>不仅需要检查参数的有效性，还需要在函数的文档中给予明确的说明，如在参数非法的情况下，会抛出哪些异常，或导致函数返回哪些错误值等</p>
<h3 id="第-50-条：必要时进行保护性拷贝"><a href="#第-50-条：必要时进行保护性拷贝" class="headerlink" title="第 50 条：必要时进行保护性拷贝"></a>第 50 条：必要时进行保护性拷贝</h3><p>如果不能够容忍对象进入数据结构之后发生变，就必须对该对象进行保护性拷贝，并且让拷贝之后的对象而不是原始对象进入到数据结构中。</p>
<h3 id="第-51-条：谨慎设计方法签名"><a href="#第-51-条：谨慎设计方法签名" class="headerlink" title="第 51 条：谨慎设计方法签名"></a>第 51 条：谨慎设计方法签名</h3><ul>
<li>谨慎地选择方法的名称</li>
<li>避免过长的参数列表，如果多于四个了就该考虑重构这个方法了</li>
<li>对于参数类型、要优先使用接口而不是类。</li>
<li>对于 boolean 参数，优先使用两个元素的枚举类型。</li>
</ul>
<h3 id="第-52-条：慎用重载"><a href="#第-52-条：慎用重载" class="headerlink" title="第 52 条：慎用重载"></a>第 52 条：慎用重载</h3><p>对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。</p>
<ol>
<li>安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。</li>
<li>如果方法使用可变参数，保守的策略是根本不要重载它。</li>
<li>在 Java 1.5 之后，需要对自动装箱机制保持警惕。</li>
</ol>
<p>对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。我们应当保证：当传递同样的参数时，所有重载方法的行为必须一致。</p>
<h3 id="第-53-条：慎用可变参数"><a href="#第-53-条：慎用可变参数" class="headerlink" title="第 53 条：慎用可变参数"></a>第 53 条：慎用可变参数</h3><p>有的时候在重视性能的情况下，使用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。</p>
<h3 id="第-54-条：返回零长度的数组或者集合，而不是-null"><a href="#第-54-条：返回零长度的数组或者集合，而不是-null" class="headerlink" title="第 54 条：返回零长度的数组或者集合，而不是 null"></a>第 54 条：返回零长度的数组或者集合，而不是 null</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final Cheese[] EMPTY_CHEESE_ARRAY= new Cheese[0];</span><br><span class="line">Collections.emptyList();</span><br><span class="line">Collections.emptySet();</span><br><span class="line">Collections.emptyMap();</span><br></pre></td></tr></table></figure>



<h3 id="第-55-条-返回-Optional-类型"><a href="#第-55-条-返回-Optional-类型" class="headerlink" title="第 55 条: 返回 Optional 类型"></a>第 55 条: 返回 Optional 类型</h3><h3 id="第-56-条：为所有导出的API元素编写文档注释"><a href="#第-56-条：为所有导出的API元素编写文档注释" class="headerlink" title="第 56 条：为所有导出的API元素编写文档注释"></a>第 56 条：为所有导出的API元素编写文档注释</h3></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/29/Effective%20java/Lambdas%20%E4%B8%8E%20Streams/">Lambdas 与 Streams</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/effective-java/">effective java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/effectivejava/">effectivejava</a></span><div class="content"><h3 id="第-42-条：lambdas-优于匿名类"><a href="#第-42-条：lambdas-优于匿名类" class="headerlink" title="第 42 条：lambdas 优于匿名类"></a>第 42 条：lambdas 优于匿名类</h3><p>从 Java 8 开始，lambda 是迄今为止表示小函数对象的最佳方式。 除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象。</p>
<p>lambda 没有名称和文档，如果超过三行，不要使用 lambda 表达式。</p>
<h3 id="第-43-条-方法引用优于-lambdas"><a href="#第-43-条-方法引用优于-lambdas" class="headerlink" title="第 43 条: 方法引用优于 lambdas"></a>第 43 条: 方法引用优于 lambdas</h3><p>如果方法引用看起来更简短更清晰，请使用它们；否则，还是坚持 lambda。</p>
<table>
<thead>
<tr>
<th>方法引用类型</th>
<th>举例</th>
<th>等同的 Lambda</th>
</tr>
</thead>
<tbody><tr>
<td>Static</td>
<td>Integer::parseInt</td>
<td>str -&gt; Integer.parseInt(str)</td>
</tr>
<tr>
<td>Bound</td>
<td>Instant.now()::isAfter</td>
<td>Instant then &#x3D; Instant.now(); t -&gt; then.isAfter(t)</td>
</tr>
<tr>
<td>Unbound</td>
<td>String::toLowerCase</td>
<td>str -&gt; str.toLowerCase()</td>
</tr>
<tr>
<td>Class Constructor</td>
<td>TreeMap&lt;K,V&gt;::new</td>
<td>() -&gt; new TreeMap&lt;K,V&gt;</td>
</tr>
<tr>
<td>Array Constructor</td>
<td>int[]::new</td>
<td>len -&gt; new int[len]</td>
</tr>
</tbody></table>
<h3 id="第-44-条-优先使用标准的函数式接口"><a href="#第-44-条-优先使用标准的函数式接口" class="headerlink" title="第 44 条: 优先使用标准的函数式接口"></a>第 44 条: 优先使用标准的函数式接口</h3><p>设计API时必须考虑 lambda 表达式。 在输入上接受函数式接口类型并在输出中返回它们。 一般来说，最好使用 java.util.function.Function 中提供的标准接口</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>方法</th>
<th>示例</th>
<th>表示</th>
</tr>
</thead>
<tbody><tr>
<td>UnaryOperator</td>
<td>T apply(T t)</td>
<td>String::toLowerCase</td>
<td>方法的结果和参数类型相同</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>T apply(T t1, T t2)</td>
<td>BigInteger::add</td>
<td>方法的结果和参数类型相同</td>
</tr>
<tr>
<td>Predicate</td>
<td>boolean test(T t)</td>
<td>Collection::isEmpty</td>
<td>方法接受一个参数并返回一个布尔值</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>R apply(T t)</td>
<td>Arrays::asList</td>
<td>参数和返回类型不同</td>
</tr>
<tr>
<td>Supplier</td>
<td>T get()</td>
<td>Instant::now</td>
<td>一个不接受参数和返回值(或“供应”)的方法</td>
</tr>
<tr>
<td>Consumer</td>
<td>void accept(T t)</td>
<td>System.out::println</td>
<td>接受一个参数而不返回任何东西</td>
</tr>
</tbody></table>
<h3 id="第-45-条-明智审慎地使用-Stream"><a href="#第-45-条-明智审慎地使用-Stream" class="headerlink" title="第 45 条: 明智审慎地使用 Stream"></a>第 45 条: 明智审慎地使用 Stream</h3><p>在没有显式类型的情况下，仔细命名 lambda 参数对于流管道的可读性至关重要。</p>
<p>使用辅助方法对于流管道中的可读性比在迭代代码中更为重要</p>
<p>重构现有代码以使用流，并仅在有意义的情况下在新代码中使用它们。</p>
<p>如果不确定一个任务是通过流还是迭代更好地完成，那么尝试这两种方法，看看哪一种效果更好。</p>
<h3 id="第-46-条-优先考虑流中无副作用的函数"><a href="#第-46-条-优先考虑流中无副作用的函数" class="headerlink" title="第 46 条: 优先考虑流中无副作用的函数"></a>第 46 条: 优先考虑流中无副作用的函数</h3><h3 id="第-47-条-返回类型优先选择集合而不是流"><a href="#第-47-条-返回类型优先选择集合而不是流" class="headerlink" title="第 47 条: 返回类型优先选择集合而不是流"></a>第 47 条: 返回类型优先选择集合而不是流</h3><p>如果返回集合是可行的，请执行此操作。如果返回集合是不可行的，则返回流或可迭代的。</p>
<p>如果在将来的 Java 版本中，Stream 接口声明被修改为继承 Iterable，那么可随意返回流。</p>
<h3 id="第-48-条-谨慎使用流并行"><a href="#第-48-条-谨慎使用流并行" class="headerlink" title="第 48 条: 谨慎使用流并行"></a>第 48 条: 谨慎使用流并行</h3><p>不恰当地并行化流的代价可能是程序失败或性能灾难。使用并行流之前，请确保您的代码在并行运行时保持正确，并在实际情况下进行仔细的性能度量。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/28/Effective%20java/%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/">枚举和注解</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/effective-java/">effective java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/effectivejava/">effectivejava</a></span><div class="content"><h3 id="第-34-条：用-enum-代替-int-常量"><a href="#第-34-条：用-enum-代替-int-常量" class="headerlink" title="第 34 条：用 enum 代替 int 常量"></a>第 34 条：用 enum 代替 int 常量</h3><p>当需要一组固定常量的时候，应该使用 enum 代替 int 常量。</p>
<h3 id="第-35-条：用实例域代替序数"><a href="#第-35-条：用实例域代替序数" class="headerlink" title="第 35 条：用实例域代替序数"></a>第 35 条：用实例域代替序数</h3><p>应该给 enum 添加 int 域，而不是使用 ordinal() 方法来导出与枚举关联的序数值。(几乎不应使用 ordinal() 方法，除非在编写像 EnumMap 这样的基于枚举的通用数据结构)</p>
<h3 id="第36条：用-EnumSet-代替位域"><a href="#第36条：用-EnumSet-代替位域" class="headerlink" title="第36条：用 EnumSet 代替位域"></a>第36条：用 EnumSet 代替位域</h3><ul>
<li>EnumSet 实现了 Set 接口</li>
<li>若枚举类型个数小于 64 个，则整个 EnumSet 就用单个 long 来表示，性能上比得上位运算</li>
<li>总而言之因为枚举类型要用在集合(Set)中,所以没有理由用位域来表示.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//WRONG</span><br><span class="line">public class Text&#123;</span><br><span class="line">    private static final int STYLE_BOLD = 1 &lt;&lt; 0;</span><br><span class="line">    private static final int STYLE_ITALIC = 1 &lt;&lt; 1;</span><br><span class="line">    private static final int STYLE_UNDERLINE = 1 &lt;&lt; 2;</span><br><span class="line">    </span><br><span class="line">    public void applyStyles(int styles) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">//use</span><br><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC);</span><br><span class="line"></span><br><span class="line">//RIGHT</span><br><span class="line">public class Text&#123;</span><br><span class="line">    public enum Style&#123;STYLE_BOLD, STYLE_ITALIC, STYLE_UNDERLINE&#125;</span><br><span class="line">    </span><br><span class="line">    public void applyStyles(Set&lt;Style&gt; styles) &#123;...&#125; </span><br><span class="line">&#125;</span><br><span class="line">//use</span><br><span class="line">text.applyStyles(EnumSet.of(STYLE_BOLD, STYLE_ITALIC));</span><br></pre></td></tr></table></figure>



<h3 id="第-37-条：用-EnumMap-代替序数索引"><a href="#第-37-条：用-EnumMap-代替序数索引" class="headerlink" title="第 37 条：用 EnumMap 代替序数索引"></a>第 37 条：用 EnumMap 代替序数索引</h3><p>序数索引是指依赖于枚举成员在枚举中的序数来进行数组索引</p>
<p>应该使用 EnumMap 来实现，EnumMap 内部是采用数组实现的，具有 Map 的丰富功能和类型安全以及数组的效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Plant.Type, Set&lt;Plant&gt;&gt; plants = new EnumMap&lt;Plant.Type, Set&lt;Plant&gt;&gt;(Plant.Type.class); </span><br><span class="line"></span><br><span class="line">for(Plant.Type type : Plant.Type.valuse())&#123;</span><br><span class="line">    plants.put(type, new HashSet&lt;Plant&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(Plant p : garden)&#123;</span><br><span class="line">    plants.get(p.type).add(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第-38-条：用接口模拟可以伸缩的枚举"><a href="#第-38-条：用接口模拟可以伸缩的枚举" class="headerlink" title="第 38 条：用接口模拟可以伸缩的枚举"></a>第 38 条：用接口模拟可以伸缩的枚举</h3><p>由于在 Java 中 enum 不是可扩展的，在某些情况下，可能需要对枚举进行扩展，比如操作类型（±*&#x2F;等），就可以考虑：</p>
<ol>
<li>定义一个接口，比如<code>public interface Operation&#123;…&#125;;</code></li>
<li>使枚举继承接口：比如<code>public enum BasicOperation implements Operation&#123;…&#125;</code></li>
<li>使用时的 API 写成接口(比如，<code>T extends Enum &amp; Operation)</code>，而不是实现（比如<code>BasicOperation</code>）</li>
<li>当需要扩展<code>BasicOperation</code>枚举时，就可以另写一个枚举，且 implements 接口<code>Operation</code></li>
</ol>
<h3 id="第-39-条：注解优先于命名模式"><a href="#第-39-条：注解优先于命名模式" class="headerlink" title="第 39 条：注解优先于命名模式"></a>第 39 条：注解优先于命名模式</h3><h3 id="第-40-条：坚持使用-Override-注解"><a href="#第-40-条：坚持使用-Override-注解" class="headerlink" title="第 40 条：坚持使用 Override 注解"></a>第 40 条：坚持使用 Override 注解</h3><h3 id="第-41-条：用标记接口实现类型"><a href="#第-41-条：用标记接口实现类型" class="headerlink" title="第 41 条：用标记接口实现类型"></a>第 41 条：用标记接口实现类型</h3><p>标记接口可以在编译时就检查到相应的类型问题，而标记注解则要到运行时。</p>
<ul>
<li>如果标记是应用到任何程序元素而不是类或者接口,就必须使用注解. 因为只有 类和接口可以用来实现或者扩展接口</li>
<li>如果标记只应用给类和接口,就应该 优先使用标记接口而非注解</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/27/Effective%20java/%E6%B3%9B%E5%9E%8B/">泛型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/effective-java/">effective java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/effectivejava/">effectivejava</a></span><div class="content"><h3 id="第-26-条：请不要在新代码中使用原生态类型"><a href="#第-26-条：请不要在新代码中使用原生态类型" class="headerlink" title="第 26 条：请不要在新代码中使用原生态类型"></a>第 26 条：请不要在新代码中使用原生态类型</h3><p>原生态类型只为了与引入泛型之前的遗留代码进行兼容和互用而提供的。</p>
<p>List 原生态类型</p>
<p>List<T> 泛型</p>
<h3 id="第-27-条：消除非受检警告"><a href="#第-27-条：消除非受检警告" class="headerlink" title="第 27 条：消除非受检警告"></a>第 27 条：消除非受检警告</h3><p>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，只有在这种情况下才可以用一个 @SuppressWarnings(“unchecked”) 注解来禁止这条警告。</p>
<h3 id="第-28-条：列表优先于数组"><a href="#第-28-条：列表优先于数组" class="headerlink" title="第 28 条：列表优先于数组"></a>第 28 条：列表优先于数组</h3><h3 id="第-29-条：优先考虑泛型"><a href="#第-29-条：优先考虑泛型" class="headerlink" title="第 29 条：优先考虑泛型"></a>第 29 条：优先考虑泛型</h3><h3 id="第-30-条：优先考虑泛型方法"><a href="#第-30-条：优先考虑泛型方法" class="headerlink" title="第 30 条：优先考虑泛型方法"></a>第 30 条：优先考虑泛型方法</h3><h3 id="第-31-条：利用有限制通配符来提升API的灵活性"><a href="#第-31-条：利用有限制通配符来提升API的灵活性" class="headerlink" title="第 31 条：利用有限制通配符来提升API的灵活性"></a>第 31 条：利用有限制通配符来提升API的灵活性</h3><p> 限定通配符包括两种： </p>
<ol>
<li>表示类型的上界，格式为：&lt;？ extends T&gt;，即类型必须为T类型或者T子类</li>
<li>表示类型的下界，格式为：&lt;？ super T&gt;，即类型必须为T类型或者T的父类</li>
</ol>
<h3 id="第-32-条-明智地结合泛型和可变参数"><a href="#第-32-条-明智地结合泛型和可变参数" class="headerlink" title="第 32 条: 明智地结合泛型和可变参数"></a>第 32 条: 明智地结合泛型和可变参数</h3><h3 id="第-33-条：优先考虑类型安全的异构容器"><a href="#第-33-条：优先考虑类型安全的异构容器" class="headerlink" title="第 33 条：优先考虑类型安全的异构容器"></a>第 33 条：优先考虑类型安全的异构容器</h3><p>异构容器</p>
<p>异构容器是指能够容纳不同类型对象的容器。像我们通常用的<code>List</code>、<code>Map</code>等容器，它们的原生态类型本身就是异构容器，一旦给它们设置了泛型参数，例如<code>List</code>、<code>Map</code>，它们就不再是异构容器。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2024 By iMine</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>