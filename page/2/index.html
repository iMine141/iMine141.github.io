<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="iMine"><meta name="copyright" content="iMine"><title>iMineのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 7.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">iMine</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">74</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iMineのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">iMineのBlog</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/10/pulsar/pulsar%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">pulsar负载均衡</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><h3 id="一、动态分配"><a href="#一、动态分配" class="headerlink" title="一、动态分配"></a>一、动态分配</h3><p>pulsar本身是集群部署的，每个集群包含多个broker。当创建新的topic时，会根据各个broker的负载情况，选择一个相对空闲的broker节点负责新topic的消息发布和订阅。如果某个broker的负载过高或者broker挂掉，也会重新进行topic的分配。从而确保整个集群在一个相对均衡稳定的情况下运行。</p>
<p>整个分配过程是自动的，不需要外部干预。</p>
<p>而且，由于broker只负责接收和发送消息，不负责消息持久化，所有broker本身是无状态的，使得broker的管理和topic分配都变得相对简单。</p>
<h3 id="二、bundle"><a href="#二、bundle" class="headerlink" title="二、bundle"></a>二、bundle</h3><p>topic是消息发布订阅的最小粒度，在某些情况下会被频繁的创建、销毁，所有如果按照topic的粒度进行负载均衡会增加难度。因此，pulsar选择在namespace和topic之间虚构一层bundle，然后把topic分配到各个bundle中，以bunlde为粒度进行负载均衡。</p>
<p>默认情况下，一个namespace创建后会分配4个bunlde，每个bundle负责一个数字区间范围（0 - 0xFFFFFFFF），当有新的topic创建后，会对topic取hash，然后根据hash值把topic分配到某一个bundle下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当命名空间创建时没有指定 bundle 数量时，将使用这个默认的值。defaultNumberOfNamespaceBundles=4</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>每个bunlde会被分配到一个broker上，需要重新分配时，会对整个bunlde进行移动。</p>
<p>bunlde的设置方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建ns2，设置bundle个数为16</span><br><span class="line">./pulsar-admin namespaces create tenant_vv/ns2 --bundles 16</span><br><span class="line"># 查看bundle个数</span><br><span class="line">./pulsar-admin namespaces bundles tenant_vv/ns2&#123;  &quot;boundaries&quot; : [ &quot;0x00000000&quot;, &quot;0x10000000&quot;, &quot;0x20000000&quot;, &quot;0x30000000&quot;, &quot;0x40000000&quot;, &quot;0x50000000&quot;, &quot;0x60000000&quot;, &quot;0x70000000&quot;, &quot;0x80000000&quot;, &quot;0x90000000&quot;, &quot;0xa0000000&quot;, &quot;0xb0000000&quot;, &quot;0xc0000000&quot;, &quot;0xd0000000&quot;, &quot;0xe0000000&quot;, &quot;0xf0000000&quot;, &quot;0xffffffff&quot; ],  &quot;numBundles&quot; : 16&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="三、bundle拆分"><a href="#三、bundle拆分" class="headerlink" title="三、bundle拆分"></a>三、bundle拆分</h3><p>通过hash方式可以把topic分配到某一个bundle上，通过增加bundle个数可以尽可能的让topic分配到不同的bundle上，从而让整个负载结果相对均衡。但如果topic的hash都很接近，或者一个bundle上topic的消息量特别大， 就会造成这个bundle压力过大，从而也造成处理该bundle的broker压力过大。</p>
<p>所以，pulsar支持对bundle进行拆分，拆分后的bundle会被重新分配。可以在conf&#x2F;broker.conf中设置bundle拆分策略，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启用/禁用 自动拆分命名空间中的bundleloadBalancerAutoBundleSplitEnabled=true# 启用/禁用 自动卸载切分的bundleloadBalancerAutoUnloadSplitBundlesEnabled=true# bundle 中最大的主题数, 一旦超过这个值，将触发拆分操作。loadBalancerNamespaceBundleMaxTopics=1000# bundle 最大的session数量(生产 + 消费), 一旦超过这个值，将触发拆分操作。loadBalancerNamespaceBundleMaxSessions=1000# bundle 最大的msgRate(进+出)的值, 一旦超过这个值，将触发拆分操作。loadBalancerNamespaceBundleMaxMsgRate=30000# bundle 最大的带宽(进+出)的值, 一旦超过这个值，将触发拆分操作loadBalancerNamespaceBundleMaxBandwidthMbytes=100# 命名空间中最大的 bundle 数量 (用于自动拆分bundle时)loadBalancerNamespaceMaximumBundles=128</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="四、broker过载检测"><a href="#四、broker过载检测" class="headerlink" title="四、broker过载检测"></a>四、broker过载检测</h3><p>broker会根据cpu、网卡流量和内存判断是否过载，如果broker过载了，则会卸载上边的一些bundle。关于自动卸载的配置项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启用/禁用自动负载拆分</span><br><span class="line">loadBalancerSheddingEnabled=true</span><br><span class="line"># 负载切分时间间隔。Broker 定期检查，是否有一些流量需要从一些负载比较高的 broker，转移到负载较低的 broker 上。</span><br><span class="line">loadBalancerSheddingIntervalMinutes=1</span><br><span class="line"># 防止同一个主题，在同一个时间窗口，被多次迁移的时间间隔。</span><br><span class="line">loadBalancerSheddingGracePeriodMinutes=30</span><br><span class="line"># 使用阈值确定 broker 是否过载</span><br><span class="line">loadBalancerBrokerOverloadedThresholdPercentage=85</span><br><span class="line"># 覆盖自动获取的网卡最大速度</span><br><span class="line"># 此选项在某些环境中是有用的(例如：EC2 VMs) ，因为Linux报告的网卡最大速度不是 broker 真实的值。</span><br><span class="line"># 因为负载管理器是根据网络使用情况来判断 broker 是否负载，为了确保信息是正确的，你可以通过这个参数来指定正确的值。这个配置值可以是一个 double 类型的值(比如: 0.8)。</span><br><span class="line"># 能够通过这个配置项在网卡带宽使用完之前，触发负载切分操作。</span><br><span class="line">loadBalancerOverrideBrokerNicSpeedGbps=</span><br></pre></td></tr></table></figure>



<h3 id="五、相关代码处理逻辑"><a href="#五、相关代码处理逻辑" class="headerlink" title="五、相关代码处理逻辑"></a>五、相关代码处理逻辑</h3><p>关于负载均衡的代码在com.apache.pulsar.broker.loadbalance包下。</p>
<h4 id="1-PulsarService服务启动后，会初始化负载均衡的模块"><a href="#1-PulsarService服务启动后，会初始化负载均衡的模块" class="headerlink" title="1. PulsarService服务启动后，会初始化负载均衡的模块"></a>1. PulsarService服务启动后，会初始化负载均衡的模块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void startLeaderElectionService() &#123;</span><br><span class="line">    this.leaderElectionService = new LeaderElectionService(coordinationService, getSafeWebServiceAddress(),</span><br><span class="line">        state -&gt; &#123;</span><br><span class="line">            if (state == LeaderElectionState.Leading) &#123;</span><br><span class="line">                LOG.info(&quot;This broker was elected leader&quot;);</span><br><span class="line">                if (getConfiguration().isLoadBalancerEnabled()) &#123;</span><br><span class="line">                    long loadSheddingInterval = TimeUnit.MINUTES</span><br><span class="line">                        .toMillis(getConfiguration().getLoadBalancerSheddingIntervalMinutes());</span><br><span class="line">                    long resourceQuotaUpdateInterval = TimeUnit.MINUTES</span><br><span class="line">                        .toMillis(getConfiguration().getLoadBalancerResourceQuotaUpdateIntervalMinutes());</span><br><span class="line">                    if (loadSheddingTask != null) &#123;</span><br><span class="line">                        loadSheddingTask.cancel(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (loadResourceQuotaTask != null) &#123;</span><br><span class="line">                        loadResourceQuotaTask.cancel(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 启动两个定时任务</span><br><span class="line">                    loadSheddingTask = loadManagerExecutor.scheduleAtFixedRate(</span><br><span class="line">                        new LoadSheddingTask(loadManager),</span><br><span class="line">                        loadSheddingInterval, loadSheddingInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">                    loadResourceQuotaTask = loadManagerExecutor.scheduleAtFixedRate(</span><br><span class="line">                        new LoadResourceQuotaUpdaterTask(loadManager), resourceQuotaUpdateInterval,</span><br><span class="line">                        resourceQuotaUpdateInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (leaderElectionService != null) &#123;</span><br><span class="line">                    LOG.info(&quot;This broker is a follower. Current leader is &#123;&#125;&quot;,</span><br><span class="line">                        leaderElectionService.getCurrentLeader());</span><br><span class="line">                &#125;</span><br><span class="line">                if (loadSheddingTask != null) &#123;</span><br><span class="line">                    loadSheddingTask.cancel(false);</span><br><span class="line">                    loadSheddingTask = null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (loadResourceQuotaTask != null) &#123;</span><br><span class="line">                    loadResourceQuotaTask.cancel(false);</span><br><span class="line">                    loadResourceQuotaTask = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    leaderElectionService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-负载均衡管理器选择"><a href="#2-负载均衡管理器选择" class="headerlink" title="2. 负载均衡管理器选择"></a>2. 负载均衡管理器选择</h4><p>pulsar提供了默认的负载均衡器，同时也支持自定义负载均衡策略。负载均衡管理模块LoadManager的初始化代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static LoadManager create(final PulsarService pulsar) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果配置文件中指定了自定义的均衡管理器，则使用自定义的。</span><br><span class="line">        final ServiceConfiguration conf = pulsar.getConfiguration();</span><br><span class="line">        final Class&lt;?&gt; loadManagerClass = Class.forName(conf.getLoadManagerClassName());</span><br><span class="line">        // Assume there is a constructor with one argument of PulsarService.</span><br><span class="line">        final Object loadManagerInstance = loadManagerClass.newInstance();</span><br><span class="line">        if (loadManagerInstance instanceof LoadManager) &#123;</span><br><span class="line">            final LoadManager casted = (LoadManager) loadManagerInstance;</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            return casted;</span><br><span class="line">        &#125; else if (loadManagerInstance instanceof ModularLoadManager) &#123;</span><br><span class="line">            final LoadManager casted = new ModularLoadManagerWrapper((ModularLoadManager) loadManagerInstance);</span><br><span class="line">            casted.initialize(pulsar);</span><br><span class="line">            return casted;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.warn(&quot;Error when trying to create load manager: &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用内置的负载均衡器。</span><br><span class="line">    // If we failed to create a load manager, default to SimpleLoadManagerImpl.</span><br><span class="line">    return new SimpleLoadManagerImpl(pulsar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果我们在配置文件中提供了自定义的加载管理器，则优先使用自定义的，否则使用默认的SimpleLoadManagerImpl类。</p>
<p>然后我们看下LoadManager提供的API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * LoadManager runs though set of load reports collected from different brokers and generates a recommendation of</span><br><span class="line"> * namespace/ServiceUnit placement on machines/ResourceUnit. Each Concrete Load Manager will use different algorithms to</span><br><span class="line"> * generate this mapping.</span><br><span class="line"> *</span><br><span class="line"> * Concrete Load Manager is also return the least loaded broker that should own the new namespace.</span><br><span class="line"> */</span><br><span class="line">public interface LoadManager &#123;</span><br><span class="line">    Logger LOG = LoggerFactory.getLogger(LoadManager.class);</span><br><span class="line">    String LOADBALANCE_BROKERS_ROOT = &quot;/loadbalance/brokers&quot;;</span><br><span class="line">    void start() throws PulsarServerException;</span><br><span class="line">    /**</span><br><span class="line">     * Is centralized decision making to assign a new bundle.</span><br><span class="line">     */</span><br><span class="line">    boolean isCentralized();</span><br><span class="line">    /**</span><br><span class="line">     * Returns the Least Loaded Resource Unit decided by some algorithm or criteria which is implementation specific.</span><br><span class="line">     */</span><br><span class="line">    Optional&lt;ResourceUnit&gt; getLeastLoaded(ServiceUnitId su) throws Exception;</span><br><span class="line">    /**</span><br><span class="line">     * Generate the load report.</span><br><span class="line">     */</span><br><span class="line">    LoadManagerReport generateLoadReport() throws Exception;</span><br><span class="line">    /**</span><br><span class="line">     * Set flag to force load report update.</span><br><span class="line">     */</span><br><span class="line">    void setLoadReportForceUpdateFlag();</span><br><span class="line">    /**</span><br><span class="line">     * Publish the current load report on ZK.</span><br><span class="line">     */</span><br><span class="line">    void writeLoadReportOnZookeeper() throws Exception;</span><br><span class="line">    /**</span><br><span class="line">     * Publish the current load report on ZK, forced or not.</span><br><span class="line">     * By default rely on method writeLoadReportOnZookeeper().</span><br><span class="line">     */</span><br><span class="line">    default void writeLoadReportOnZookeeper(boolean force) throws Exception &#123;</span><br><span class="line">        writeLoadReportOnZookeeper();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Update namespace bundle resource quota on ZK.</span><br><span class="line">     */</span><br><span class="line">    void writeResourceQuotasToZooKeeper() throws Exception;</span><br><span class="line">    /**</span><br><span class="line">     * Generate load balancing stats metrics.</span><br><span class="line">     */</span><br><span class="line">    List&lt;Metrics&gt; getLoadBalancingMetrics();</span><br><span class="line">    /**</span><br><span class="line">     * Unload a candidate service unit to balance the load.</span><br><span class="line">     */</span><br><span class="line">    void doLoadShedding();</span><br><span class="line">    /**</span><br><span class="line">     * Namespace bundle split.</span><br><span class="line">     */</span><br><span class="line">    void doNamespaceBundleSplit() throws Exception;</span><br><span class="line">    /**</span><br><span class="line">     * Removes visibility of current broker from loadbalancer list so, other brokers can&#x27;t redirect any request to this</span><br><span class="line">     * broker and this broker won&#x27;t accept new connection requests.</span><br><span class="line">     *</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    void disableBroker() throws Exception;</span><br><span class="line">    /**</span><br><span class="line">     * Get list of available brokers in cluster.</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    Set&lt;String&gt; getAvailableBrokers() throws Exception;</span><br><span class="line">    void stop() throws PulsarServerException;</span><br><span class="line">    /**</span><br><span class="line">     * Initialize this LoadManager.</span><br><span class="line">     *</span><br><span class="line">     * @param pulsar</span><br><span class="line">     *            The service to initialize this with.</span><br><span class="line">     */</span><br><span class="line">    void initialize(PulsarService pulsar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，LoadManager提供了关于加载状态汇报、保存状态到zk、卸载服务以平衡加载、bundle拆分、停止broker和获取可用broker等api，方便我们对整个集群的加载进行管理和控制。</p>
<p>我们自己实现的加载管理器，需要采集各个broker节点的状态，然后根据topic和bundle信息，平均分配bundle到不同的broker上，确保各个broker的负载相对均衡。</p>
<h4 id="3-LoadSheddingTask（加载移除）"><a href="#3-LoadSheddingTask（加载移除）" class="headerlink" title="3. LoadSheddingTask（加载移除）"></a>3. LoadSheddingTask（加载移除）</h4><p>这个定时任务就是调用加载管理器的doLoadShedding方法，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        loadManager.get().doLoadShedding();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.warn(&quot;Error during the load shedding&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在SimpleLoadManagerImpl中，是通过遍历所有broker汇报的bundle状态，找到其中过载的bundle，然后卸载掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pulsar.getAdminClient().namespaces().unloadNamespaceBundle(</span><br><span class="line">         LoadManagerShared.getNamespaceNameFromBundleName(bundleName),</span><br><span class="line">        LoadManagerShared.getBundleRangeFromBundleName(bundleName));</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="4-LoadResourceQuotaUpdaterTask"><a href="#4-LoadResourceQuotaUpdaterTask" class="headerlink" title="4. LoadResourceQuotaUpdaterTask"></a>4. LoadResourceQuotaUpdaterTask</h4><p>这个定时任务就是调用资源管理器的writeResourceQuatosToZookeeper把资源使用情况写入zk，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.loadManager.get().writeResourceQuotasToZooKeeper();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.warn(&quot;Error write resource quota&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、待研究问题"><a href="#六、待研究问题" class="headerlink" title="六、待研究问题"></a>六、待研究问题</h3><p>自定义均衡管理器需要注意哪些内容。</p>
<p>如何管理topic和bundle的分配策略。</p>
<p>是否可实现一个topic分配到多个bundle上，多个bundle分配到不同的broker上，数据存储不变，这样实现通过多个broker读取一个topic的数据。</p>
<h3 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h3><p><a target="_blank" rel="noopener" href="https://pulsar.apache.org/docs/en/administration-load-balance/">https://pulsar.apache.org/docs/en/administration-load-balance/</a></p>
<p><a target="_blank" rel="noopener" href="https://pulsar.apache.org/docs/en/develop-load-manager/">https://pulsar.apache.org/docs/en/develop-load-manager/</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/10/pulsar/%E8%AF%BB%E5%8F%96%E5%92%8C%E8%A7%A3%E6%9E%90pulsar%E4%BF%9D%E5%AD%98%E5%9C%A8bookkeeper%E4%B8%8A%E7%9A%84%E6%B6%88%E6%81%AF/">读取和解析pulsar保存在bookkeeper上的消息</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><p>pulsar使用bk对消息进行持久化，为了实现只读broker，需要跨过pulsar直接连接bk读取消息。在bk中ledger是一个日志段，bk以ledger为粒度进行数据的多地备份，ledger包含多个entry，每个entry对应pulsar中的一条或者多条消息。</p>
<p>而pulsar每个topic在bk中的存储信息保存在zk中。即我们可以通过zk中获取特定topic的ledger信息，然后连接到bk，读取ledger下的每个entry的消息。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tmp;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.BookKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.api.DigestType;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.api.LedgerEntries;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.api.LedgerEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.bookkeeper.client.api.ReadHandle;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.common.api.proto.MessageMetadata;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.common.protocol.Commands;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/10 16:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BKMain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(BKMain.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BKMain</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BKMain</span>();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        load01();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">load01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// zookeeper地址</span></span><br><span class="line">        <span class="comment">// bk的信息保存在zk的/ledger路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">connectionString</span> <span class="operator">=</span> <span class="string">&quot;x.x.x.x:2181&quot;</span>;</span><br><span class="line">        <span class="type">BookKeeper</span> <span class="variable">bkClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookKeeper</span>(connectionString);</span><br><span class="line">        <span class="comment">// 通过zk上/managed-ledgers/tenant_c/ns1/persistent/storeV2获取topic storeV2的ledgerId</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ledgerId</span> <span class="operator">=</span> <span class="number">56990</span>;</span><br><span class="line">        <span class="comment">// 设置加密方式和密码（同pulsar一样）</span></span><br><span class="line">        <span class="type">ReadHandle</span> <span class="variable">handle</span> <span class="operator">=</span> bkClient.newOpenLedgerOp().withRecovery(<span class="literal">false</span>).withLedgerId(ledgerId)</span><br><span class="line">                .withDigestType(DigestType.CRC32C).withPassword(<span class="string">&quot;&quot;</span>.getBytes(Charsets.UTF_8)).execute().get();</span><br><span class="line">        <span class="comment">// 获取上一次被添加确认的entryId。则这个entryId之前的数据对外是可见的</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> handle.readLastAddConfirmed();</span><br><span class="line">        log.info(<span class="string">&quot;id=&quot;</span> + id);</span><br><span class="line">        <span class="type">long</span> <span class="variable">firstEntry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEntry</span> <span class="operator">=</span> id;</span><br><span class="line">        <span class="type">LedgerEntries</span> <span class="variable">entries</span> <span class="operator">=</span> handle.read(firstEntry, lastEntry);</span><br><span class="line">        <span class="keyword">if</span> (entries != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (LedgerEntry entry : entries) &#123;</span><br><span class="line">                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> entry.getEntryBuffer();</span><br><span class="line">                <span class="comment">// 解析每一条消息（因为我们本身没有采用批量的方式发送消息，没有压缩，没有加密，而且指定的schema也是string，所以解析部分也很简单）</span></span><br><span class="line">                Commands.skipBrokerEntryMetadataIfExist(buf);</span><br><span class="line">                Commands.skipChecksumIfPresent(buf);</span><br><span class="line">                sb.setLength(<span class="number">0</span>);</span><br><span class="line">                sb.append(<span class="string">&quot;ledgerId=&quot;</span>).append(entry.getLedgerId());</span><br><span class="line">                sb.append(<span class="string">&quot;, entryId=&quot;</span>).append(entry.getEntryId());</span><br><span class="line">                sb.append(<span class="string">&quot;, dataLen=&quot;</span>).append(entry.getLength() + buf.readableBytes());</span><br><span class="line">                <span class="type">MessageMetadata</span> <span class="variable">msgMetadata</span> <span class="operator">=</span> Commands.parseMessageMetadata(buf);</span><br><span class="line">                sb.append(<span class="string">&quot;, numMessages=&quot;</span>).append(msgMetadata.getNumMessagesInBatch());</span><br><span class="line">                sb.append(<span class="string">&quot;, publishTime=&quot;</span>).append(msgMetadata.getPublishTime());</span><br><span class="line">                sb.append(<span class="string">&quot;, sequenceId=&quot;</span>).append(msgMetadata.getSequenceId());</span><br><span class="line">                <span class="comment">// 如果有些字段不是必须的，则需要先判断是否有该字段，否则解析会报错。</span></span><br><span class="line">                sb.append(<span class="string">&quot;, numChunks=&quot;</span>).append(msgMetadata.hasNumChunksFromMsg() ? msgMetadata.getNumChunksFromMsg() : <span class="number">0</span>);</span><br><span class="line">                sb.append(<span class="string">&quot;, replicateFrom=&quot;</span>).append(msgMetadata.hasReplicatedFrom() ? msgMetadata.getReplicatedFrom() : <span class="string">&quot;none&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] dataBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">                buf.readBytes(dataBytes);</span><br><span class="line">                sb.append(<span class="string">&quot;, data=&quot;</span>).append(<span class="keyword">new</span> <span class="title class_">String</span>(dataBytes));</span><br><span class="line">                log.info(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            entries.close();</span><br><span class="line">        &#125;</span><br><span class="line">        handle.close();</span><br><span class="line">        bkClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ledgerId=56990, entryId=0, dataLen=90, numMessages=1, publishTime=1628583539500, sequenceId=0, numChunks=0, replicateFrom=none, data=value 0</span><br><span class="line">ledgerId=56990, entryId=1, dataLen=138, numMessages=1, publishTime=1628583539504, sequenceId=1, numChunks=0, replicateFrom=none, data=value 1</span><br><span class="line">ledgerId=56990, entryId=2, dataLen=186, numMessages=1, publishTime=1628583539504, sequenceId=2, numChunks=0, replicateFrom=none, data=value 2</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/09/pulsar/pulsar%E6%B6%88%E6%81%AF%E8%AF%BB%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/">pulsar消息读流程（一</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><p>大致介绍下pulsar的消息读的过程</p>
<p>consumer通过lookup命令查找到负责消费topic的broker地址，然后连接到该broker。broker接收到请求后，首先查找内存中有没有该订阅名称的consumer信息，如果有，则找到对应的subscription信息，然后建立和consumer的关系。之后从zk和bk中获取消息处理的ledger和对应的cursor。</p>
<p>然后consumer可以定时发送通知（sendFlowPermitsToBroker），broker接收到通知后就从ledger读消息返回给consumer。消息的发送是异步的，在handleFlow中处理consumer的通知，然后读取数据，读取完成后就发送给consumer。</p>
<h1 id="1-consumer端的处理流程"><a href="#1-consumer端的处理流程" class="headerlink" title="1. consumer端的处理流程"></a>1. consumer端的处理流程</h1><p>consumer的创建代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Consumer&lt;String&gt; c = client.newConsumer(Schema.STRING)</span><br><span class="line">    .topic(topic)</span><br><span class="line">    .subscriptionName(&quot;subscription_001&quot;)</span><br><span class="line">    .receiverQueueSize(4)</span><br><span class="line">    .subscribe();</span><br><span class="line">Message&lt;String&gt; msg = c.receive(5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>在subscribe后，会创建一个consumer对象，然后调用该对象的receive方法获取消息。</p>
<p><strong>ConsumerBase</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Message&lt;T&gt; receive(int timeout, TimeUnit unit) throws PulsarClientException &#123;</span><br><span class="line">    if (conf.getReceiverQueueSize() == 0) &#123;</span><br><span class="line">        throw new PulsarClientException.InvalidConfigurationException(</span><br><span class="line">            &quot;Can&#x27;t use receive with timeout, if the queue size is 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (listener != null) &#123;</span><br><span class="line">        throw new PulsarClientException.InvalidConfigurationException(</span><br><span class="line">            &quot;Cannot use receive() when a listener has been set&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    verifyConsumerState();</span><br><span class="line">    return internalReceive(timeout, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ConsumerImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Message&lt;T&gt; <span class="title function_">internalReceive</span><span class="params">(<span class="type">int</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> PulsarClientException &#123;</span><br><span class="line">    Message&lt;T&gt; message;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先从缓存队列中获取，如果获取不到则直接返回。</span></span><br><span class="line">        message = incomingMessages.poll(timeout, unit);</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂时不返回消息，而是给broker发送通知，表示自己可以接收更多的消息了。</span></span><br><span class="line">        messageProcessed(message);</span><br><span class="line">        <span class="keyword">return</span> beforeConsume(message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (state != State.Closing &amp;&amp; state != State.Closed) &#123;</span><br><span class="line">            stats.incrementNumReceiveFailed();</span><br><span class="line">            <span class="keyword">throw</span> PulsarClientException.unwrap(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">messageProcessed</span><span class="params">(Message&lt;?&gt; msg)</span> &#123;</span><br><span class="line">    <span class="type">ClientCnx</span> <span class="variable">currentCnx</span> <span class="operator">=</span> cnx();</span><br><span class="line">    <span class="type">ClientCnx</span> <span class="variable">msgCnx</span> <span class="operator">=</span> ((MessageImpl&lt;?&gt;) msg).getCnx();</span><br><span class="line">    lastDequeuedMessageId = msg.getMessageId();</span><br><span class="line">    <span class="keyword">if</span> (msgCnx != currentCnx) &#123;</span><br><span class="line">        <span class="comment">// The processed message did belong to the old queue that was cleared after reconnection.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        increaseAvailablePermits(currentCnx);</span><br><span class="line">        stats.updateNumMsgsReceived(msg);</span><br><span class="line">        trackMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    decreaseIncomingMessageSize(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx)</span> &#123;</span><br><span class="line">    increaseAvailablePermits(currentCnx, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> AVAILABLE_PERMITS_UPDATER.addAndGet(<span class="built_in">this</span>, delta);</span><br><span class="line">    <span class="keyword">while</span> (available &gt;= receiverQueueRefillThreshold &amp;&amp; !paused) &#123;</span><br><span class="line">        <span class="comment">// 确保能发送一次通知</span></span><br><span class="line">        <span class="keyword">if</span> (AVAILABLE_PERMITS_UPDATER.compareAndSet(<span class="built_in">this</span>, available, <span class="number">0</span>)) &#123;</span><br><span class="line">            sendFlowPermitsToBroker(currentCnx, available);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            available = AVAILABLE_PERMITS_UPDATER.get(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * send the flow command to have the broker start pushing messages</span></span><br><span class="line"><span class="comment"> * 发送flow通知给broker，异步获取更多消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendFlowPermitsToBroker</span><span class="params">(ClientCnx cnx, <span class="type">int</span> numMessages)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnx != <span class="literal">null</span> &amp;&amp; numMessages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;[&#123;&#125;] [&#123;&#125;] Adding &#123;&#125; additional permits&quot;</span>, topic, subscription, numMessages);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            cnx.ctx().writeAndFlush(Commands.newFlow(consumerId, numMessages))</span><br><span class="line">                .addListener(writeFuture -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!writeFuture.isSuccess()) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;Consumer &#123;&#125; failed to send &#123;&#125; permits to broker: &#123;&#125;&quot;</span>, consumerId, numMessages,</span><br><span class="line">                                  writeFuture.cause().getMessage());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;Consumer &#123;&#125; sent &#123;&#125; permits to broker&quot;</span>, consumerId, numMessages);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnx.ctx().writeAndFlush(Commands.newFlow(consumerId, numMessages), cnx.ctx().voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="2-broker端的处理流程"><a href="#2-broker端的处理流程" class="headerlink" title="2. broker端的处理流程"></a>2. broker端的处理流程</h1><p>和consumer交互的主要是ServerCnx中的handleConnect、handleSubscribe、handleFlow、handleAck四个方法，connect中处理认证信息，subscribe中获取订阅名称，保存订阅关系，flow中接收消息接收通知，触发从ledger中读取消息，ack中处理消息消费确认信息。</p>
<p>在broker中，每一个topic对应一个处理实例（PersistentTopic或者NonPersistentTopic），这个实例中保存topic信息和相关订阅信息（subscriptions）。</p>
<p>subscription本身是一个map变量，以SubscriptionName作为key，保存详细的订阅信息（即每一个订阅名称的所有客户端共享一组订阅信息，用于处理消息订阅的四种类型）。</p>
<p>在Subscription中有一个dispatcher变量，该变量直接存储所有的consumer信息。</p>
<p>所以，上述信息的存储关系链是：</p>
<p>topic -&gt; subscription -&gt; dispatcher -&gt; consumer</p>
<h2 id="2-1-zookeeper中存储的信息"><a href="#2-1-zookeeper中存储的信息" class="headerlink" title="2.1 zookeeper中存储的信息"></a>2.1 zookeeper中存储的信息</h2><p>消息订阅信息保存在zookeeper中的&#x2F;managed_ledgers路径下，其中有两个重要的信息：ledger信息和cursor信息。</p>
<p>ledger存储topic消息在bk中的信息，cursor存储消费者读取进度，在zk中的路径分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/managed_ledgers/&#123;tenant&#125;/&#123;namespace&#125;/persistent/&#123;topic&#125;</span><br><span class="line">/managed_ledgers/&#123;tenant&#125;/&#123;namespace&#125;/persistent/&#123;topic&#125;/&#123;subscription_name&#125;</span><br></pre></td></tr></table></figure>



<p>在zk中的这部分信息可以直接解析出来，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZKMetaData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/managed-ledgers/tenant_c/ns1/persistent/topic_name&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = getValue(path);</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bytes is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MLDataFormats.<span class="type">ManagedLedgerInfo</span> <span class="variable">info</span> <span class="operator">=</span> MLDataFormats.ManagedLedgerInfo.parseFrom(bytes);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (MLDataFormats.ManagedLedgerInfo.LedgerInfo ls : info.getLedgerInfoList()) &#123;</span><br><span class="line">        sb.setLength(<span class="number">0</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;ledgerId=&quot;</span>).append(ls.getLedgerId());</span><br><span class="line">        sb.append(<span class="string">&quot;, entries=&quot;</span>).append(ls.getEntries());</span><br><span class="line">        sb.append(<span class="string">&quot;, size=&quot;</span>).append(ls.getSize());</span><br><span class="line">        sb.append(<span class="string">&quot;, timestamp=&quot;</span>).append(ls.getTimestamp());</span><br><span class="line">        System.out.println(<span class="string">&quot;debug vv &quot;</span> + sb);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZKMetaDataCursorInfo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/managed-ledgers/tenant_c/ns1/persistent/topic_name/subscription_name_0&quot;</span>;</span><br><span class="line">    path = <span class="string">&quot;/managed-ledgers/tenant_c/ns1/persistent/topic_name/subscription_name_1&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = getValue(path);</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bytes is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MLDataFormats.<span class="type">ManagedCursorInfo</span> <span class="variable">info</span> <span class="operator">=</span> MLDataFormats.ManagedCursorInfo.parseFrom(bytes);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.setLength(<span class="number">0</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;markDeleteLedgerId=&quot;</span>).append(info.getMarkDeleteLedgerId());</span><br><span class="line">    sb.append(<span class="string">&quot;, markDeleteEntryId=&quot;</span>).append(info.getMarkDeleteEntryId());</span><br><span class="line">    sb.append(<span class="string">&quot;, lastActive=&quot;</span>).append(info.getLastActive());</span><br><span class="line">    System.out.println(<span class="string">&quot;debug vv &quot;</span> + sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">byte</span>[] getValue(String path) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">ZooKeeper</span> <span class="variable">zoo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;x.x.x.x:2181&quot;</span>, <span class="number">10000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;state &quot;</span> + event.getState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">byte</span>[] bytes = zoo.getData(path, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    zoo.close();</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>testZKMetaData输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug vv ledgerId=56929, entries=10, size=710, timestamp=1628234384802</span><br><span class="line">debug vv ledgerId=56933, entries=10, size=720, timestamp=1628235295486</span><br><span class="line">debug vv ledgerId=56937, entries=10, size=710, timestamp=1628240968389</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug vv markDeleteLedgerId=56933, markDeleteEntryId=9, lastActive=1628236717415</span><br><span class="line">debug vv markDeleteLedgerId=56937, markDeleteEntryId=2, lastActive=1628240766897</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2-ManagedLedgerInfo和ManagedCursorInfo结构"><a href="#2-2-ManagedLedgerInfo和ManagedCursorInfo结构" class="headerlink" title="2.2 ManagedLedgerInfo和ManagedCursorInfo结构"></a>2.2 ManagedLedgerInfo和ManagedCursorInfo结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * &quot;License&quot;); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *   http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing,</span><br><span class="line"> * software distributed under the License is distributed on an</span><br><span class="line"> * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span><br><span class="line"> * KIND, either express or implied.  See the License for the</span><br><span class="line"> * specific language governing permissions and limitations</span><br><span class="line"> * under the License.</span><br><span class="line"> */</span><br><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line">option java_package = &quot;org.apache.bookkeeper.mledger.proto&quot;;</span><br><span class="line">option optimize_for = SPEED;</span><br><span class="line">message KeyValue &#123;</span><br><span class="line">    required string key = 1;</span><br><span class="line">    required string value = 2;</span><br><span class="line">&#125;</span><br><span class="line">message OffloadDriverMetadata &#123;</span><br><span class="line">    required string name = 1;</span><br><span class="line">    repeated KeyValue properties = 2;</span><br><span class="line">&#125;</span><br><span class="line">message OffloadContext &#123;</span><br><span class="line">    optional int64 uidMsb = 1;</span><br><span class="line">    optional int64 uidLsb = 2;</span><br><span class="line">    optional bool complete = 3;</span><br><span class="line">    optional bool bookkeeperDeleted = 4;</span><br><span class="line">    optional int64 timestamp = 5;</span><br><span class="line">    optional OffloadDriverMetadata driverMetadata = 6;</span><br><span class="line">    repeated OffloadSegment offloadSegment = 7;</span><br><span class="line">&#125;</span><br><span class="line">message OffloadSegment &#123;</span><br><span class="line">    optional int64 uidMsb = 1;</span><br><span class="line">    optional int64 uidLsb = 2;</span><br><span class="line">    optional bool complete = 3;</span><br><span class="line">    optional int64 assignedTimestamp = 4; //timestamp in millisecond</span><br><span class="line">    optional int64 offloadedTimestamp = 5; //timestamp in millisecond</span><br><span class="line">    optional int64 endEntryId = 6;</span><br><span class="line">    optional OffloadDriverMetadata driverMetadata = 7;</span><br><span class="line">&#125;</span><br><span class="line">message ManagedLedgerInfo &#123;</span><br><span class="line">    message LedgerInfo &#123;</span><br><span class="line">        required int64 ledgerId = 1;</span><br><span class="line">        optional int64 entries = 2;</span><br><span class="line">        optional int64 size = 3;</span><br><span class="line">        optional int64 timestamp = 4;</span><br><span class="line">        optional OffloadContext offloadContext = 5;</span><br><span class="line">    &#125;</span><br><span class="line">  repeated LedgerInfo ledgerInfo = 1;</span><br><span class="line">    // If present, it signals the managed ledger has been</span><br><span class="line">    // terminated and this was the position of the last</span><br><span class="line">    // committed entry.</span><br><span class="line">    // No more entries can be written.</span><br><span class="line">    optional NestedPositionInfo terminatedPosition = 2;</span><br><span class="line">    repeated KeyValue properties = 3;</span><br><span class="line">&#125;</span><br><span class="line">message PositionInfo &#123;</span><br><span class="line">    required int64 ledgerId = 1;</span><br><span class="line">    required int64 entryId = 2;</span><br><span class="line">    repeated MessageRange individualDeletedMessages = 3;</span><br><span class="line">    // Additional custom properties associated with</span><br><span class="line">    // the current cursor position</span><br><span class="line">    repeated LongProperty properties = 4;</span><br><span class="line">    // Store which index in the batch message has been deleted</span><br><span class="line">    repeated BatchedEntryDeletionIndexInfo batchedEntryDeletionIndexInfo = 5;</span><br><span class="line">&#125;</span><br><span class="line">message NestedPositionInfo &#123;</span><br><span class="line">    required int64 ledgerId = 1;</span><br><span class="line">    required int64 entryId  = 2;</span><br><span class="line">&#125;</span><br><span class="line">message MessageRange &#123;</span><br><span class="line">    required NestedPositionInfo lowerEndpoint = 1;</span><br><span class="line">    required NestedPositionInfo upperEndpoint = 2;</span><br><span class="line">&#125;</span><br><span class="line">message BatchedEntryDeletionIndexInfo &#123;</span><br><span class="line">    required NestedPositionInfo position = 1;</span><br><span class="line">    repeated int64 deleteSet = 2;</span><br><span class="line">&#125;</span><br><span class="line">// Generic string and long tuple</span><br><span class="line">message LongProperty &#123;</span><br><span class="line">    required string name = 1;</span><br><span class="line">    required int64 value  = 2;</span><br><span class="line">&#125;</span><br><span class="line">message ManagedCursorInfo &#123;</span><br><span class="line">    // If the ledger id is -1, then the mark-delete position is</span><br><span class="line">    // the one from the (ledgerId, entryId) snapshot below</span><br><span class="line">    required int64 cursorsLedgerId = 1;</span><br><span class="line">    // Last snapshot of the mark-delete position</span><br><span class="line">    optional int64 markDeleteLedgerId = 2;</span><br><span class="line">    optional int64 markDeleteEntryId = 3;</span><br><span class="line">    repeated MessageRange individualDeletedMessages = 4;</span><br><span class="line">    // Additional custom properties associated with</span><br><span class="line">    // the current cursor position</span><br><span class="line">    repeated LongProperty properties = 5;</span><br><span class="line">    optional int64 lastActive = 6;</span><br><span class="line">    // Store which index in the batch message has been deleted</span><br><span class="line">    repeated BatchedEntryDeletionIndexInfo batchedEntryDeletionIndexInfo = 7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-判断topic是属于哪一个broker"><a href="#2-3-判断topic是属于哪一个broker" class="headerlink" title="2.3 判断topic是属于哪一个broker"></a>2.3 判断topic是属于哪一个broker</h2><p>通过topic查找bundle，然后判断bundle是否属于broker。</p>
<p>OwnershipCache中的ownershipReadOnlyCache：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private CompletableFuture&lt;Optional&lt;Map.Entry&lt;NamespaceEphemeralData, Stat&gt;&gt;&gt; resolveOwnership(String path) &#123;</span><br><span class="line">    // 通过缓存的zk信息，找到该path(topic全路径)对应的的bundle信息</span><br><span class="line">    return ownershipReadOnlyCache.getWithStatAsync(path).thenApply(optionalOwnerDataWithStat -&gt; &#123;</span><br><span class="line">        if (optionalOwnerDataWithStat.isPresent()) &#123;</span><br><span class="line">            Map.Entry&lt;NamespaceEphemeralData, Stat&gt; ownerDataWithStat = optionalOwnerDataWithStat.get();</span><br><span class="line">            Stat stat = ownerDataWithStat.getValue();</span><br><span class="line">            if (stat.getEphemeralOwner() == localZkCache.getZooKeeper().getSessionId()) &#123;</span><br><span class="line">                LOG.info(&quot;Successfully reestablish ownership of &#123;&#125;&quot;, path);</span><br><span class="line">                OwnedBundle ownedBundle = new OwnedBundle(ServiceUnitUtils.suBundleFromPath(path, bundleFactory));</span><br><span class="line">                if (selfOwnerInfo.getNativeUrl().equals(ownerDataWithStat.getKey().getNativeUrl())) &#123;</span><br><span class="line">                    ownedBundlesCache.put(path, CompletableFuture.completedFuture(ownedBundle));</span><br><span class="line">                &#125;</span><br><span class="line">                ownershipReadOnlyCache.invalidate(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return optionalOwnerDataWithStat;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ul>
<li>consumer可以随机连上一个broker，通过发送lookup命令可以最终找到一个处理所需topic的broker地址，然后连接到该broker。</li>
<li>broker接收到consumer连接后，建立好topic - subscription - dispatcher - consumer的关系，同时打开ledger和cursor，准备消息的读写。</li>
<li>consumer建立好连接后，不定时的发送flow命令，通知broker可以发送更多的消息了，broker接收到命令后，通过ledger读取消息并异步发送给consumer。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/06/pulsar/pulsar%E5%AF%B9%E6%B6%88%E6%81%AF%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/">pulsar对消息进行加密</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><blockquote>
<p>pular支持对消息的传输过程进行加密，加密方式有两种：一种是直接使用TLS，一种是基于加密算法进行数据加密。</p>
<p>本文主要是记录下基于加密算法进行加密的方法。</p>
</blockquote>
<h1 id="1-加解密的流程"><a href="#1-加解密的流程" class="headerlink" title="1. 加解密的流程"></a>1. 加解密的流程</h1><p>pulsar使用AES对数据进行加密，AES的密钥和消息一起转发，并且AES密钥使用ECDSA&#x2F;RSA进行加密。</p>
<p>如果使用pulsar的加密功能，需要先生成一对密钥：公钥、私钥。生产者使用公钥对AES密钥进行加密，消费者使用私钥对AES密钥进行解密。</p>
<p>由于pulsar本身是不存储密钥的，所以如果生产者和消费者丢失了密钥，则数据就永远不能解密了。</p>
<p>下面分别是生产者加密流程和消费者解密流程：</p>
<p><img src="/../../images/640-20231008224629933.png" alt="图片"></p>
<p><img src="/../../images/640-20231008224629923.png" alt="图片"></p>
<h1 id="2-具体实现方式"><a href="#2-具体实现方式" class="headerlink" title="2. 具体实现方式"></a>2. 具体实现方式</h1><h2 id="2-1-使用openssl生成密钥对"><a href="#2-1-使用openssl生成密钥对" class="headerlink" title="2.1 使用openssl生成密钥对"></a>2.1 使用openssl生成密钥对</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl ecparam -name secp521r1 -genkey -param_enc explicit -out test_ecdsa_privkey.pem</span><br><span class="line">openssl ec -in test_ecdsa_privkey.pem -pubout -outform pkcs8 -out test_ecdsa_pubkey.pem</span><br></pre></td></tr></table></figure>

<p>2.2 实现CryptoKeyReader接口，用于pulsar获取密钥</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> encrypt;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.CryptoKeyReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.EncryptionKeyInfo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 9:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RawFileKeyReader</span> <span class="keyword">implements</span> <span class="title class_">CryptoKeyReader</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">publicKeyFile</span> <span class="operator">=</span> <span class="string">&quot;F:\\download\\test_ecdsa_pubkey.pem&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">privateKeyFile</span> <span class="operator">=</span> <span class="string">&quot;F:\\download\\test_ecdsa_privkey.pem&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EncryptionKeyInfo <span class="title function_">getPublicKey</span><span class="params">(String keyName, Map&lt;String, String&gt; metadata)</span> &#123;</span><br><span class="line">        <span class="type">EncryptionKeyInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncryptionKeyInfo</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;getPublicKey&quot;</span>);</span><br><span class="line">            info.setKey(Files.readAllBytes(<span class="keyword">new</span> <span class="title class_">File</span>(publicKeyFile).toPath()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EncryptionKeyInfo <span class="title function_">getPrivateKey</span><span class="params">(String keyName, Map&lt;String, String&gt; metadata)</span> &#123;</span><br><span class="line">        <span class="type">EncryptionKeyInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncryptionKeyInfo</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;getPrivateKey&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            info.setKey(Files.readAllBytes(<span class="keyword">new</span> <span class="title class_">File</span>(privateKeyFile).toPath()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-编写生产者和消费者进行测试"><a href="#2-3-编写生产者和消费者进行测试" class="headerlink" title="2.3 编写生产者和消费者进行测试"></a>2.3 编写生产者和消费者进行测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> encrypt;</span><br><span class="line"><span class="keyword">import</span> auth.client.VVAuthentication;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 8:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(EncryptTest.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EncryptTest</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncryptTest</span>();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;persistent://tenant_c/ns1/topic1&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PulsarClient</span> <span class="variable">client</span> <span class="operator">=</span> PulsarClient.builder()</span><br><span class="line">                .authentication(<span class="keyword">new</span> <span class="title class_">VVAuthentication</span>())</span><br><span class="line">                .serviceUrl(<span class="string">&quot;pulsar://172.20.140.11:6650&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        produce(client);</span><br><span class="line">        consume(client);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> client.newProducer()</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .producerName(<span class="string">&quot;pro_encrypt&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置AES密钥，如果不设置则不会对消息加密</span></span><br><span class="line">                .addEncryptionKey(<span class="string">&quot;vv_01&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置从哪获取公钥/私钥</span></span><br><span class="line">                .cryptoKeyReader(<span class="keyword">new</span> <span class="title class_">RawFileKeyReader</span>())</span><br><span class="line">                .create();</span><br><span class="line">        <span class="type">MessageId</span> <span class="variable">id</span> <span class="operator">=</span> p.newMessage(Schema.STRING).key(<span class="string">&quot;key-1&quot;</span>).value(<span class="string">&quot;hello world&quot;</span>).send();</span><br><span class="line">        p.flush();</span><br><span class="line">        log.info(<span class="string">&quot;send &quot;</span> + id);</span><br><span class="line">        p.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> client.newConsumer()</span><br><span class="line">                .subscriptionName(<span class="string">&quot;con_encrypt&quot;</span>)</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .cryptoKeyReader(<span class="keyword">new</span> <span class="title class_">RawFileKeyReader</span>())</span><br><span class="line">                .subscribe();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> c.receive(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c.acknowledge(msg);</span><br><span class="line">            log.info(<span class="string">&quot;receive &quot;</span> + msg.getKey() + <span class="string">&quot;, &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getData()));</span><br><span class="line">        &#125;</span><br><span class="line">        c.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getPublicKey</span><br><span class="line">12:29:21.462 [main] INFO  encrypt.EncryptTest - send 56925:3:-1</span><br><span class="line">getPrivateKey</span><br><span class="line">12:29:21.535 [main] INFO  encrypt.EncryptTest - receive key-1, hello world</span><br></pre></td></tr></table></figure>

<p>可以看到在生产者端使用公钥对AES密钥加密，在消费者端使用私钥对AES密钥进行解密。</p>
<p><strong>生产者设置数据加密密钥：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Add public encryption key, used by producer to encrypt the data key.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;At the time of producer creation, Pulsar client checks if there are keys added to encryptionKeys. If keys are</span><br><span class="line">  * found, a callback &#123;@link CryptoKeyReader#getPrivateKey(String, Map)&#125; and</span><br><span class="line">  * &#123;@link CryptoKeyReader#getPublicKey(String, Map)&#125; is invoked against each key to load the values of the key.</span><br><span class="line">  * Application should implement this callback to return the key in pkcs8 format. If compression is enabled, message</span><br><span class="line">  * is encrypted after compression. If batch messaging is enabled, the batched message is encrypted.</span><br><span class="line">  *</span><br><span class="line">  * @param key</span><br><span class="line">  *            the name of the encryption key in the key store</span><br><span class="line">  * @return the producer builder instance</span><br><span class="line">  */</span><br><span class="line"> ProducerBuilder&lt;T&gt; addEncryptionKey(String key);</span><br></pre></td></tr></table></figure>



<p>当生产者创建时，pulsar客户端检查是否添加了密钥，如果找到了就回调CryptoKeyReader的方法获取公钥&#x2F;私钥。应用需要实现CryptoKeyReader的方法，并返回pkcs8格式的密钥。如果消息开启了压缩，则消息会在压缩后被加密。如果消息是批量发送的，则消息被打包后会被加密。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/05/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(3)/">认证和授权(3)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><h1 id="1-认证和授权流程"><a href="#1-认证和授权流程" class="headerlink" title="1. 认证和授权流程"></a>1. 认证和授权流程</h1><p>认证和授权需要一个第三方用户管理中心，该管理中心的功能包含以下几点：</p>
<ol>
<li>提供用户注册和管理。</li>
<li>提供tenant、namespace、topic的创建和管理。</li>
<li>提供用户信息和权限的验证接口。</li>
</ol>
<p>当新增一个业务时，需要创建对应的用户，然后使用该用户创建tenant、namespace和topic。然后客户端可以携带用户名&#x2F;密码连接到broker，broker到管理中心验证用户是否有效，拉取用户的权限并保存到本地，之后对客户端的操作进行权限的验证。</p>
<p>整体流程：</p>
<p><img src="/../../images/640-20231007110807330.png" alt="图片"></p>
<p>上述设计的核心是把tenant、namespace、topic的看作一种资源，消息的发布和订阅看作是对资源的使用，认证和授权的方案设计就可以分成两部分：</p>
<ol>
<li>对资源的管理权限</li>
<li>对资源的使用权限</li>
</ol>
<p>其中，对资源的管理权限可以由用户中心去做，可以创建用户，给用户分配资源和使用权限，同时也可以给用户创建子用户，给子用户分配主用户权限下的资源等。用户中心的输出就是&lt;角色，权限&gt;的集合，把这个集合提供给broker，这样broker就可以根据这个集合判断用户的操作是否合法。</p>
<h1 id="2-数据表设计"><a href="#2-数据表设计" class="headerlink" title="2. 数据表设计"></a>2. 数据表设计</h1><table>
<thead>
<tr>
<th>表名</th>
<th>含义</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>sys_user_info</td>
<td>用户信息表</td>
<td>配置用户信息</td>
<td></td>
</tr>
<tr>
<td>sys_service_group</td>
<td>业务分组表</td>
<td>用户属于某一个业务</td>
<td></td>
</tr>
<tr>
<td>sys_role</td>
<td>角色表</td>
<td>用角色进行权限的控制</td>
<td></td>
</tr>
<tr>
<td>sys_user_role_map</td>
<td>用户和角色关系表</td>
<td>用户和角色之间的关系，一个用户可能属于多个角色</td>
<td></td>
</tr>
<tr>
<td>res_cluster</td>
<td>集群表</td>
<td>配置ADMQ集群信息，包含名称、地址等</td>
<td></td>
</tr>
<tr>
<td>res_tenant</td>
<td>租户表</td>
<td>配置集群下的租户信息</td>
<td></td>
</tr>
<tr>
<td>res_namespace</td>
<td>命名空间表</td>
<td>配置租户下的namespace信息</td>
<td></td>
</tr>
<tr>
<td>res_topic</td>
<td>topic表</td>
<td>配置namespace下的topic信息</td>
<td></td>
</tr>
<tr>
<td>sys_role_res</td>
<td>角色和资源权限关系表</td>
<td>配置角色和资源之间的关系和对应的权限</td>
<td></td>
</tr>
<tr>
<td>sys_authority</td>
<td>权限配置表</td>
<td>配置资源权限字典</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-1-用户信息表"><a href="#2-1-用户信息表" class="headerlink" title="2.1 用户信息表"></a>2.1 用户信息表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户ID</td>
<td>bigint(20)</td>
<td>主键递增</td>
</tr>
<tr>
<td>username</td>
<td>用户名称</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>nick</td>
<td>昵称</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>passwd</td>
<td>用户密码</td>
<td>varchar(128)</td>
<td>加密后</td>
</tr>
<tr>
<td>service_group</td>
<td>业务分组</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>update_time</td>
<td>修改时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-2-业务分组表"><a href="#2-2-业务分组表" class="headerlink" title="2.2 业务分组表"></a>2.2 业务分组表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>组ID</td>
<td>bigint(20)</td>
<td>主键递增</td>
</tr>
<tr>
<td>group_name</td>
<td>分组名称</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>update_time</td>
<td>修改时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-3-角色表"><a href="#2-3-角色表" class="headerlink" title="2.3 角色表"></a>2.3 角色表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>组ID</td>
<td>bigint(20)</td>
<td>主键递增</td>
</tr>
<tr>
<td>role_name</td>
<td>角色名称</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>update_time</td>
<td>修改时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-4-用户和角色关系表"><a href="#2-4-用户和角色关系表" class="headerlink" title="2.4 用户和角色关系表"></a>2.4 用户和角色关系表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>user_id</td>
<td>用户id</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>role_id</td>
<td>角色id</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-5-集群表"><a href="#1-5-集群表" class="headerlink" title="1.5 集群表"></a>1.5 集群表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>组ID</td>
<td>bigint(20)</td>
<td>主键递增</td>
</tr>
<tr>
<td>name</td>
<td>集群名称</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>address</td>
<td>集群地址</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>update_time</td>
<td>修改时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-6-租户表"><a href="#1-6-租户表" class="headerlink" title="1.6 租户表"></a>1.6 租户表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>组ID</td>
<td>bigint(20)</td>
<td>主键递增</td>
</tr>
<tr>
<td>clusters</td>
<td>所属集群</td>
<td>varchar(128)</td>
<td>可以属于多个集群</td>
</tr>
<tr>
<td>name</td>
<td>名称</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>is_valid</td>
<td>是否有效</td>
<td>int(2)</td>
<td>1：有效，2：无效</td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>update_time</td>
<td>修改时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-7-命名空间表"><a href="#1-7-命名空间表" class="headerlink" title="1.7 命名空间表"></a>1.7 命名空间表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>组ID</td>
<td>bigint(20)</td>
<td>主键递增</td>
</tr>
<tr>
<td>tenant</td>
<td>租户ID</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>名称</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>is_valid</td>
<td>是否有效</td>
<td>int(2)</td>
<td>1：有效，2：无效</td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>update_time</td>
<td>修改时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-8-topic表"><a href="#1-8-topic表" class="headerlink" title="1.8 topic表"></a>1.8 topic表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>组ID</td>
<td>bigint(20)</td>
<td>主键递增</td>
</tr>
<tr>
<td>tenant</td>
<td>租户ID</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>namespace</td>
<td>命名空间ID</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>名称</td>
<td>varchar(128)</td>
<td></td>
</tr>
<tr>
<td>is_valid</td>
<td>是否有效</td>
<td>int(2)</td>
<td>1：有效，2：无效</td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>update_time</td>
<td>修改时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-9-角色和资源权限关系表"><a href="#1-9-角色和资源权限关系表" class="headerlink" title="1.9 角色和资源权限关系表"></a>1.9 角色和资源权限关系表</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>role_id</td>
<td>角色ID</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>res_type</td>
<td>资源类型</td>
<td>int(11)</td>
<td>1：cluster2：tenant3：namespace4：topic</td>
</tr>
<tr>
<td>res_id</td>
<td>资源ID</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>authorities</td>
<td>权限列表</td>
<td>varchar(128)</td>
<td>逗号隔开</td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>1.10 权限配置表</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>含义</strong></th>
<th><strong>类型</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>主键</td>
<td>int(11)</td>
<td></td>
</tr>
<tr>
<td>desc</td>
<td>权限描述</td>
<td>varchar(256)</td>
<td></td>
</tr>
<tr>
<td>add_time</td>
<td>添加时间</td>
<td>bigint(20)</td>
<td></td>
</tr>
<tr>
<td>remark</td>
<td>备注信息</td>
<td>varchar(256)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>目前支持的几种权限：</strong></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>创建tenant</td>
<td></td>
</tr>
<tr>
<td>101</td>
<td>删除tenant</td>
<td></td>
</tr>
<tr>
<td>102</td>
<td>tenant下所有topic的写权限</td>
<td></td>
</tr>
<tr>
<td>103</td>
<td>tenant下所有topic的读权限</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>创建namespace</td>
<td></td>
</tr>
<tr>
<td>201</td>
<td>删除namespace</td>
<td></td>
</tr>
<tr>
<td>202</td>
<td>namespace下所有topic的写权限</td>
<td></td>
</tr>
<tr>
<td>203</td>
<td>namespace下所有topic的读权限</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>创建topic</td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>删除topic</td>
<td></td>
</tr>
<tr>
<td>302</td>
<td>topic的写权限</td>
<td></td>
</tr>
<tr>
<td>303</td>
<td>topic的读权限</td>
<td></td>
</tr>
</tbody></table>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/04/pulsar/pulsar%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%EF%BC%88negativeAckRedeliveryDelay%EF%BC%89%E7%9A%84%E8%A7%A3%E9%87%8A/">pulsar失败重试（negativeAckRedeliveryDelay）的解释</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><blockquote>
<p>在pulsar讨论群里看到关于这个api的问题，然后就去看了代码，了解了其功能和详细处理逻辑，在此记录下。</p>
</blockquote>
<h1 id="1-消息发布订阅流程"><a href="#1-消息发布订阅流程" class="headerlink" title="1. 消息发布订阅流程"></a>1. 消息发布订阅流程</h1><p><img src="/../../images/image-20231008221757348.png" alt="image-20231008221757348"></p>
<p>如上图所示，消费者收到消息并返回确认后，broker端就认为这条消息被成功转发了。但是consumer端接收到消息后可能会处理失败，导致没有发送确认给broker。broker端有一个未确认消息队列，这个队列达到一定大小后就会阻塞，这时broker就不会继续发送消息给consumer，也不会重复发送以前未确认的消息给consumer。如果consumer和broker断开连接了，未确认的消息就又会重新发送给consumer了。</p>
<p>这时候有人看到negativeAckRedeliveryDelay，猜想是不是可以设置重复消费消息，即当一定时间内没有确认后能再次接收到该消息。然后我看过代码后发现确实是能实现的，实现方式是handler回复消费失败后，把失败的消息发送给broker，broker再发送给consumer。</p>
<h1 id="2-关于消息重复发送的解释"><a href="#2-关于消息重复发送的解释" class="headerlink" title="2. 关于消息重复发送的解释"></a>2. 关于消息重复发送的解释</h1><p><img src="/../../images/image-20231008221819464.png" alt="image-20231008221819464"></p>
<p>broker发送Msg01给consumer1，consumer1在handle中处理失败，调用negativeAcknowledge方法，发送处理失败的消息信息给broker，broker收到后再选择发送给consumer1或者consumer2.</p>
<p>其中两个重要的API：</p>
<p><strong>ConsumerBuilder，用于设置多长时间后再次收到处理失败的消息。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConsumerBuilder&lt;T&gt; ackTimeoutTickTime(long tickTime, TimeUnit timeUnit);</span><br><span class="line">    /**</span><br><span class="line">     * Set the delay to wait before re-delivering messages that have failed to be process.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;When application uses &#123;@link Consumer#negativeAcknowledge(Message)&#125;, the failed message</span><br><span class="line">     * will be redelivered after a fixed timeout. The default is 1 min.</span><br><span class="line">     *</span><br><span class="line">     * @param redeliveryDelay</span><br><span class="line">     *            redelivery delay for failed messages</span><br><span class="line">     * @param timeUnit</span><br><span class="line">     *            unit in which the timeout is provided.</span><br><span class="line">     * @return the consumer builder instance</span><br><span class="line">     * @see Consumer#negativeAcknowledge(Message)</span><br><span class="line">     */</span><br><span class="line"> ConsumerBuilder&lt;T&gt; negativeAckRedeliveryDelay(long redeliveryDelay, TimeUnit timeUnit);</span><br></pre></td></tr></table></figure>

<p><strong>Consumer，用于通知broker自己处理消息失败了。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Acknowledge the failure to process a single message.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;When a message is &quot;negatively acked&quot; it will be marked for redelivery after</span><br><span class="line">     * some fixed delay. The delay is configurable when constructing the consumer</span><br><span class="line">     * with &#123;@link ConsumerBuilder#negativeAckRedeliveryDelay(long, TimeUnit)&#125;.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This call is not blocking.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Example of usage:</span><br><span class="line">     * &lt;pre&gt;&lt;code&gt;</span><br><span class="line">     * while (true) &#123;</span><br><span class="line">     *     Message&amp;lt;String&amp;gt; msg = consumer.receive();</span><br><span class="line">     *</span><br><span class="line">     *     try &#123;</span><br><span class="line">     *          // Process message...</span><br><span class="line">     *</span><br><span class="line">     *          consumer.acknowledge(msg);</span><br><span class="line">     *     &#125; catch (Throwable t) &#123;</span><br><span class="line">     *          log.warn(&quot;Failed to process message&quot;);</span><br><span class="line">     *          consumer.negativeAcknowledge(msg);</span><br><span class="line">     *     &#125;</span><br><span class="line">     * &#125;</span><br><span class="line">     * &lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param message</span><br><span class="line">     *            The &#123;@code Message&#125; to be acknowledged</span><br><span class="line">     */</span><br><span class="line">    void negativeAcknowledge(Message&lt;?&gt; message);</span><br></pre></td></tr></table></figure>

<h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><p>测试的思路是：</p>
<ol>
<li>编写两个客户端，同时订阅一份数据。</li>
<li>在第一个客户端里返回无效确认，第二个客户端里返回有效确认。</li>
<li>确认第一个客户端返回取消确认的消息是否能被第二个客户端收到。</li>
</ol>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ack;</span><br><span class="line"><span class="keyword">import</span> auth.client.VVAuthentication;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/4 16:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedeliverTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(RedeliverTest.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">RedeliverTest</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedeliverTest</span>();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;persistent://tenant_vv/ns1/redeliver_test&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer(<span class="literal">true</span>, latch)).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确保第一个消费者先收到消息</span></span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; consumer(<span class="literal">false</span>, latch)).start();</span><br><span class="line">        produce();</span><br><span class="line">        log.info(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PulsarClient</span> <span class="variable">client</span> <span class="operator">=</span> newClient()) &#123;</span><br><span class="line">            <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> client.newProducer()</span><br><span class="line">                    .topic(topic)</span><br><span class="line">                    .create();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">                p.newMessage(Schema.STRING).value(<span class="string">&quot;data_&quot;</span> + i).key(<span class="string">&quot;sub mode &quot;</span>+ i).sendAsync();</span><br><span class="line">            &#125;</span><br><span class="line">            p.flush();</span><br><span class="line">            p.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">boolean</span> replay, CountDownLatch latch)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PulsarClient</span> <span class="variable">client</span> <span class="operator">=</span> newClient()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="string">&quot;replay_mode_&quot;</span> + replay;</span><br><span class="line">            <span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> client.newConsumer(Schema.STRING)</span><br><span class="line">                    .topic(topic)</span><br><span class="line">                    <span class="comment">// 设置消息处理失败后，2秒后再此收到消息。</span></span><br><span class="line">                    .negativeAckRedeliveryDelay(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .subscriptionType(SubscriptionType.Shared)</span><br><span class="line">                    .subscriptionName(<span class="string">&quot;sub_name&quot;</span>)</span><br><span class="line">                    .subscribe();</span><br><span class="line">            latch.countDown();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                Message&lt;String&gt; msg = c.receive(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (replay) &#123;</span><br><span class="line">                    c.negativeAcknowledge(msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c.acknowledge(msg);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(tag + <span class="string">&quot; receive &quot;</span> + msg.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            c.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PulsarClient <span class="title function_">newClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PulsarClient</span> <span class="variable">client</span> <span class="operator">=</span> PulsarClient.builder()</span><br><span class="line">                .serviceUrl(<span class="string">&quot;pulsar://x.x.x.x:6650&quot;</span>)</span><br><span class="line">                .authentication(<span class="keyword">new</span> <span class="title class_">VVAuthentication</span>())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:52:56.639 [Thread-1] INFO  ack.RedeliverTest - replay_mode_true receive data_0</span><br><span class="line">16:52:56.639 [Thread-1] INFO  ack.RedeliverTest - replay_mode_true receive data_1</span><br><span class="line">16:52:58.660 [Thread-3] INFO  ack.RedeliverTest - replay_mode_false receive data_0</span><br><span class="line">16:52:58.660 [Thread-3] INFO  ack.RedeliverTest - replay_mode_false receive data_1</span><br></pre></td></tr></table></figure>

<p>可以看到，第一个客户端收到消息并调用negativeAcknowledge返回无效确认后，第二个客户端在2秒后能收到消息了，并且消息是有序的。</p>
<h1 id="4-涉及到的主要代码"><a href="#4-涉及到的主要代码" class="headerlink" title="4. 涉及到的主要代码"></a>4. 涉及到的主要代码</h1><p>主要逻辑是，consumer处理失败后，把失败的消息通知给broker，broker把失败消息缓存起来，标记为需要重新发送的消息，然后每次发送消息给消费者的时候检查是否有需要重发的消息，如果有的话就发送。</p>
<h2 id="4-1-ConsumerImpl"><a href="#4-1-ConsumerImpl" class="headerlink" title="4.1 ConsumerImpl"></a>4.1 ConsumerImpl</h2><p>保存消息并等待发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">negativeAcknowledge</span><span class="params">(MessageId messageId)</span> &#123;</span><br><span class="line">    negativeAcksTracker.add(messageId);</span><br><span class="line">    <span class="comment">// Ensure the message is not redelivered for ack-timeout, since we did receive an &quot;ack&quot;</span></span><br><span class="line">    unAckedMessageTracker.remove(messageId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用接收消息的netty channel发送失败消息通知给broker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redeliverUnacknowledgedMessages</span><span class="params">(Set&lt;MessageId&gt; messageIds)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (messageIds.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    checkArgument(messageIds.stream().findFirst().get() <span class="keyword">instanceof</span> MessageIdImpl);</span><br><span class="line">    <span class="keyword">if</span> (conf.getSubscriptionType() != SubscriptionType.Shared</span><br><span class="line">        &amp;&amp; conf.getSubscriptionType() != SubscriptionType.Key_Shared) &#123;</span><br><span class="line">        <span class="comment">// We cannot redeliver single messages if subscription type is not Shared</span></span><br><span class="line">        redeliverUnacknowledgedMessages();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ClientCnx</span> <span class="variable">cnx</span> <span class="operator">=</span> cnx();</span><br><span class="line">    <span class="keyword">if</span> (isConnected() &amp;&amp; cnx.getRemoteEndpointProtocolVersion() &gt;= ProtocolVersion.v2.getValue()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">messagesFromQueue</span> <span class="operator">=</span> removeExpiredMessagesFromQueue(messageIds);</span><br><span class="line">        Iterable&lt;List&lt;MessageIdImpl&gt;&gt; batches = Iterables.partition(</span><br><span class="line">            messageIds.stream()</span><br><span class="line">            .map(messageId -&gt; (MessageIdImpl)messageId)</span><br><span class="line">            .collect(Collectors.toSet()), MAX_REDELIVER_UNACKNOWLEDGED);</span><br><span class="line">        batches.forEach(ids -&gt; &#123;</span><br><span class="line">            getRedeliveryMessageIdData(ids).thenAccept(messageIdData -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!messageIdData.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">cmd</span> <span class="operator">=</span> Commands.newRedeliverUnacknowledgedMessages(consumerId, messageIdData);</span><br><span class="line">                    cnx.ctx().writeAndFlush(cmd, cnx.ctx().voidPromise());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (messagesFromQueue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            increaseAvailablePermits(cnx, messagesFromQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;[&#123;&#125;] [&#123;&#125;] [&#123;&#125;] Redeliver unacked messages and increase &#123;&#125; permits&quot;</span>, subscription, topic,</span><br><span class="line">                      consumerName, messagesFromQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnx == <span class="literal">null</span> || (getState() == State.Connecting)) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;[&#123;&#125;] Client Connection needs to be established for redelivery of unacknowledged messages&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;[&#123;&#125;] Reconnecting the client to redeliver the messages.&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">        cnx.ctx().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-2-NegativeAcksTraker"><a href="#4-2-NegativeAcksTraker" class="headerlink" title="4.2 NegativeAcksTraker"></a>4.2 NegativeAcksTraker</h2><p>添加处理失败的消息到缓存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MessageId messageId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (messageId <span class="keyword">instanceof</span> BatchMessageIdImpl) &#123;</span><br><span class="line">        <span class="type">BatchMessageIdImpl</span> <span class="variable">batchMessageId</span> <span class="operator">=</span> (BatchMessageIdImpl) messageId;</span><br><span class="line">        messageId = <span class="keyword">new</span> <span class="title class_">MessageIdImpl</span>(batchMessageId.getLedgerId(), batchMessageId.getEntryId(),</span><br><span class="line">                                      batchMessageId.getPartitionIndex());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nackedMessages == <span class="literal">null</span>) &#123;</span><br><span class="line">        nackedMessages = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    nackedMessages.put(messageId, System.nanoTime() + nackDelayNanos);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Schedule a task and group all the redeliveries for same period. Leave a small buffer to allow for</span></span><br><span class="line">        <span class="comment">// nack immediately following the current one will be batched into the same redeliver request.</span></span><br><span class="line">        <span class="built_in">this</span>.timeout = timer.newTimeout(<span class="built_in">this</span>::triggerRedelivery, timerIntervalNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过触发器发送失败消息到broker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">triggerRedelivery</span><span class="params">(Timeout t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nackedMessages.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.timeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Group all the nacked messages into one single re-delivery request</span></span><br><span class="line">    Set&lt;MessageId&gt; messagesToRedeliver = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    nackedMessages.forEach((msgId, timestamp) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; now) &#123;</span><br><span class="line">            addChunkedMessageIdsAndRemoveFromSequnceMap(msgId, messagesToRedeliver, <span class="built_in">this</span>.consumer);</span><br><span class="line">            messagesToRedeliver.add(msgId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    messagesToRedeliver.forEach(nackedMessages::remove);</span><br><span class="line">    consumer.onNegativeAcksSend(messagesToRedeliver);</span><br><span class="line">    <span class="comment">// 使用netty发送消息给broker</span></span><br><span class="line">    consumer.redeliverUnacknowledgedMessages(messagesToRedeliver);</span><br><span class="line">    <span class="built_in">this</span>.timeout = timer.newTimeout(<span class="built_in">this</span>::triggerRedelivery, timerIntervalNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-ServerCnx"><a href="#4-3-ServerCnx" class="headerlink" title="4.3 ServerCnx"></a>4.3 ServerCnx</h2><p>处理接收到的需要重新发送的消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleRedeliverUnacknowledged</span><span class="params">(CommandRedeliverUnacknowledgedMessages redeliver)</span> &#123;</span><br><span class="line">    checkArgument(state == State.Connected);</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;[&#123;&#125;] Received Resend Command from consumer &#123;&#125; &quot;</span>, remoteAddress, redeliver.getConsumerId());</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture&lt;Consumer&gt; consumerFuture = consumers.get(redeliver.getConsumerId());</span><br><span class="line">    <span class="keyword">if</span> (consumerFuture != <span class="literal">null</span> &amp;&amp; consumerFuture.isDone() &amp;&amp; !consumerFuture.isCompletedExceptionally()) &#123;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> consumerFuture.getNow(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (redeliver.getMessageIdsCount() &gt; <span class="number">0</span> &amp;&amp; Subscription.isIndividualAckMode(consumer.subType())) &#123;</span><br><span class="line">            consumer.redeliverUnacknowledgedMessages(redeliver.getMessageIdsList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            consumer.redeliverUnacknowledgedMessages();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-Consumer"><a href="#4-4-Consumer" class="headerlink" title="4.4 Consumer"></a>4.4 Consumer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redeliverUnacknowledgedMessages</span><span class="params">(List&lt;MessageIdData&gt; messageIds)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalRedeliveryMessages</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    List&lt;PositionImpl&gt; pendingPositions = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">for</span> (MessageIdData msg : messageIds) &#123;</span><br><span class="line">        <span class="type">PositionImpl</span> <span class="variable">position</span> <span class="operator">=</span> PositionImpl.get(msg.getLedgerId(), msg.getEntryId());</span><br><span class="line">        <span class="type">LongPair</span> <span class="variable">batchSize</span> <span class="operator">=</span> pendingAcks.get(position.getLedgerId(), position.getEntryId());</span><br><span class="line">        <span class="keyword">if</span> (batchSize != <span class="literal">null</span>) &#123;</span><br><span class="line">            pendingAcks.remove(position.getLedgerId(), position.getEntryId());</span><br><span class="line">            totalRedeliveryMessages += batchSize.first;</span><br><span class="line">            pendingPositions.add(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addAndGetUnAckedMsgs(<span class="built_in">this</span>, -totalRedeliveryMessages);</span><br><span class="line">    blockedConsumerOnUnackedMsgs = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;[&#123;&#125;-&#123;&#125;] consumer &#123;&#125; received &#123;&#125; msg-redelivery &#123;&#125;&quot;</span>, topicName, subscription, consumerId,</span><br><span class="line">                  totalRedeliveryMessages, pendingPositions.size());</span><br><span class="line">    &#125;</span><br><span class="line">    subscription.redeliverUnacknowledgedMessages(<span class="built_in">this</span>, pendingPositions);</span><br><span class="line">    msgRedeliver.recordMultipleEvents(totalRedeliveryMessages, totalRedeliveryMessages);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfBlockedPermits</span> <span class="operator">=</span> PERMITS_RECEIVED_WHILE_CONSUMER_BLOCKED_UPDATER.getAndSet(<span class="built_in">this</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// if permitsReceivedWhileConsumerBlocked has been accumulated then pass it to Dispatcher to flow messages</span></span><br><span class="line">    <span class="keyword">if</span> (numberOfBlockedPermits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        MESSAGE_PERMITS_UPDATER.getAndAdd(<span class="built_in">this</span>, numberOfBlockedPermits);</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;[&#123;&#125;-&#123;&#125;] Added &#123;&#125; blockedPermits to broker.service.Consumer&#x27;s messagePermits for consumer &#123;&#125;&quot;</span>,</span><br><span class="line">                      topicName, subscription, numberOfBlockedPermits, consumerId);</span><br><span class="line">        &#125;</span><br><span class="line">        subscription.consumerFlow(<span class="built_in">this</span>, numberOfBlockedPermits);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-PersistentDispatcherMultipleConsumers"><a href="#4-5-PersistentDispatcherMultipleConsumers" class="headerlink" title="4.5 PersistentDispatcherMultipleConsumers"></a>4.5 PersistentDispatcherMultipleConsumers</h2><p>保存消息到缓存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">redeliverUnacknowledgedMessages</span><span class="params">(Consumer consumer, List&lt;PositionImpl&gt; positions)</span> &#123;</span><br><span class="line">        positions.forEach(position -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (addMessageToReplay(position.getLedgerId(), position.getEntryId())) &#123;</span><br><span class="line">                redeliveryTracker.addIfAbsent(position);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;[&#123;&#125;-&#123;&#125;] Redelivering unacknowledged messages for consumer &#123;&#125;&quot;</span>, name, consumer, positions);</span><br><span class="line">        &#125;</span><br><span class="line">        readMoreEntries();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>这里只是总结下消息重发的处理逻辑，具体broker和consumer之间是怎么通信的还需要继续研究…</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/03/Java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%20-%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%88CompletableFuture%EF%BC%89/">函数式编程 - 异步处理（CompletableFuture）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/java/java%E9%AB%98%E7%BA%A7/">java高级</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><h4 id="一、示例"><a href="#一、示例" class="headerlink" title="一、示例"></a>一、示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/2 17:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(FunctionTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FunctionTest</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FunctionTest</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------------------------------   函数式编程方式  ------------------------------------&quot;</span>);</span><br><span class="line">        main.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------------------------------ 经典的异步实现方式 ------------------------------------&quot;</span>);</span><br><span class="line">        main.runOld();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 定义任务内容</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            value += <span class="number">101</span>;</span><br><span class="line">            log.info(<span class="string">&quot;supplyAsync, value=&quot;</span> + value);</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%d&quot;</span>, value);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;sleep done&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行完任务后执行匿名函数</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; next = future.thenAccept(v -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;thenAccept, value=&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取任务的执行结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        log.info(<span class="string">&quot;thenAccept, get=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">runOld</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        value = <span class="number">101</span>;</span><br><span class="line">        LinkedBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 启动线程执行任务</span></span><br><span class="line">        task(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞方式等待任务执行结束</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> queue.take();</span><br><span class="line">        log.info(<span class="string">&quot;thenAccept, get=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">task</span><span class="params">(LinkedBlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;failed&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value += <span class="number">101</span>;</span><br><span class="line">                log.info(<span class="string">&quot;supplyAsync, value=&quot;</span> + value);</span><br><span class="line">                result = String.format(<span class="string">&quot;%d&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、输出"><a href="#二、输出" class="headerlink" title="二、输出"></a>二、输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------------------   函数式编程方式  ------------------------------------</span><br><span class="line">08:47:51.571 [ForkJoinPool.commonPool-worker-1] INFO  main.FunctionTest - supplyAsync, value=202</span><br><span class="line">08:47:52.575 [main] INFO  main.FunctionTest - sleep done</span><br><span class="line">08:47:52.575 [main] INFO  main.FunctionTest - thenAccept, value=202</span><br><span class="line">08:47:52.575 [main] INFO  main.FunctionTest - thenAccept, get=202</span><br><span class="line"></span><br><span class="line">------------------------------------ 经典的异步实现方式 ------------------------------------</span><br><span class="line">08:47:52.576 [Thread-1] INFO  main.FunctionTest - supplyAsync, value=202</span><br><span class="line">08:47:52.576 [main] INFO  main.FunctionTest - thenAccept, get=202</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<h4 id="三、解释"><a href="#三、解释" class="headerlink" title="三、解释"></a>三、解释</h4><p>解决的是执行完一个异步函数后，得到执行结果或者根据执行结果继续执行后续的处理逻辑。</p>
<p>之前的方法是把异步执行的任务放到线程中执行，然后另外一个线程监听通知队列或者阻塞等待任务执行完毕，任务执行完后往队列放一个通知，通知等待线程。</p>
<p>现在可以采用更为简洁的方式去处理这种场景：</p>
<ol>
<li>定义一个异步函数</li>
<li>使异步函数执行</li>
<li>获取执行结果</li>
</ol>
<p>当调用get、thenAccept等方法后，java本身会帮助我们执行异步逻辑，并以阻塞的方式等待结果。</p>
<p><strong>一个函数对象只会执行一次，执行完之后会保存这个结果，下次调用get等计算方法的时候直接使用上次的计算结果。</strong></p>
<h4 id="四、查看代码"><a href="#四、查看代码" class="headerlink" title="四、查看代码"></a>四、查看代码</h4><p>通过get方法查看具体的执行方式：</p>
<p>CompletableFuture.get()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public T get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    Object r;</span><br><span class="line">    return reportGet((r = result) == null ? waitingGet(true) : r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数之前执行过，则会把结果保存到result变量中，调用get方法执行返回result结果；</p>
<p>如果函数没有执行过，则调用waitingGet方法执行。</p>
<p>下面看waitingGet方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object waitingGet(boolean interruptible) &#123;</span><br><span class="line">        Signaller q = null;</span><br><span class="line">        boolean queued = false;</span><br><span class="line">        int spins = -1;</span><br><span class="line">        Object r;</span><br><span class="line">        while ((r = result) == null) &#123;</span><br><span class="line">            if (spins &lt; 0) spins = SPINS;</span><br><span class="line">            else if (spins &gt; 0) &#123;</span><br><span class="line">                if (ThreadLocalRandom.nextSecondarySeed() &gt;= 0) --spins;</span><br><span class="line">            &#125; else if (q == null) q = new Signaller(interruptible, 0L, 0L);</span><br><span class="line">            else if (!queued) queued = tryPushStack(q);</span><br><span class="line">            else if (interruptible &amp;&amp; q.interruptControl &lt; 0) &#123;</span><br><span class="line">                q.thread = null;</span><br><span class="line">                cleanStack();</span><br><span class="line">                return null;</span><br><span class="line">            &#125; else if (q.thread != null &amp;&amp; result == null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ForkJoinPool.managedBlock(q);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                    q.interruptControl = -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (q != null) &#123;</span><br><span class="line">            q.thread = null;</span><br><span class="line">            if (q.interruptControl &lt; 0) &#123;</span><br><span class="line">                if (interruptible)</span><br><span class="line">                    r = null;</span><br><span class="line">                    // report interruption            </span><br><span class="line">                else Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        postComplete();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此方法的目的是阻塞的方式检测定义的function是否执行完毕，执行完毕或者出现异常后返回结果。</p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>这种编程方式是一种思维的转变，让异步结构变得更清晰，前后关系也很清楚（都是A-&gt;B-&gt;C），可以把所有的异步代码放在一起写，不需要添加额外的异步执行结果判断变量。</p>
<p>但是需要一段时间去习惯这种写法，否则也会被其中各种匿名函数和api绕晕。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/01/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(2)/">认证和授权(2)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><p>前面介绍了认证和授权的主要流程，本篇重点说明pulsar授权信息的存储以及怎么结合第三方用户中心实现授权管理。</p>
<ol>
<li>基于pulsar-admin的授权指令</li>
</ol>
<p>关于cluster、broker、bookie、tenant、namespace、topic的命令。</p>
<p>具体可参考：<a target="_blank" rel="noopener" href="https://pulsar.apache.org/pulsar-admin-cli/?version=2.8.0">https://pulsar.apache.org/pulsar-admin-cli/?version=2.8.0</a></p>
<ol start="2">
<li>授权信息存储</li>
</ol>
<p>使用pulsar默认的授权管理类（org.apache.pulsar.broker.authorization.PulsarAuthorizationProvider），授权信息会保存到global-zookeeper中，路径如下：</p>
<p>[zk: 172.20.140.11:2184(CONNECTED) 5] ls -R &#x2F;admin&#x2F;policies &#x2F;admin&#x2F;policies &#x2F;admin&#x2F;policies&#x2F;public &#x2F;admin&#x2F;policies&#x2F;pulsar &#x2F;admin&#x2F;policies&#x2F;tenant_c &#x2F;admin&#x2F;policies&#x2F;tenant_vv &#x2F;admin&#x2F;policies&#x2F;public&#x2F;default &#x2F;admin&#x2F;policies&#x2F;pulsar&#x2F;system &#x2F;admin&#x2F;policies&#x2F;tenant_vv&#x2F;ns1</p>
<p>查看&#x2F;admin&#x2F;policies&#x2F;tenant_vv&#x2F;ns1的节点内容</p>
<p>{ “auth_policies”: { “destination_auth”: {}, “namespace_auth”: { “vv123”: [ “consume”, “produce” ] }, “subscription_auth_roles”: {} }, “backlog_quota_map”: {}, “bundles”: { “boundaries”: [ “0x00000000”, “0x40000000”, “0x80000000”, “0xc0000000”, “0xffffffff” ], “numBundles”: 4 }, “clusterDispatchRate”: {}, “clusterSubscribeRate”: {}, “deleted”: false, “encryption_required”: false, “is_allow_auto_update_schema”: true, “latency_stats_sample_rate”: {}, “offload_threshold”: -1, “properties”: {}, “publishMaxMessageRate”: {}, “replication_clusters”: [ “vv” ], “replicatorDispatchRate”: {}, “schema_auto_update_compatibility_strategy”: “Full”, “schema_compatibility_strategy”: “UNDEFINED”, “schema_validation_enforced”: false, “subscriptionDispatchRate”: {}, “subscription_auth_mode”: “None”, “subscription_expiration_time_minutes”: 0, “subscription_types_enabled”: [], “topicDispatchRate”: {} }</p>
<p>在auth_policies里可以看到给角色vv123分配了produce和consume权限。</p>
<ol start="3">
<li>授权实现思路</li>
</ol>
<p>首先需要对所有需要权限的操作进行拦截，pulsar提供了如下两个接口：</p>
<p>&#x2F;&#x2F; 处理连接认证的 org.apache.pulsar.broker.authentication.AuthenticationProvider </p>
<p>&#x2F;&#x2F; 处理授权的 org.apache.pulsar.broker.authorization.AuthorizationProvider</p>
<p>定义一组需要进行权限管理的操作，具体如下：</p>
<p>定义好用户和操作之间的关系，并给每一个用户分配唯一的token标识</p>
<p>在一次连接中保存用户的token信息和权限，并定时更新权限</p>
<p>针对用户的每一次操作都根据token进行权限的验证</p>
<p>由此我们可以知道，授权管理的前提是有一个用户管理中心，管理中心负责用户的创建和权限的分配。客户端连接的时候去用户中心获取token信息，然后携带token连接到broker，broker在用户第一次连接是去管理中心获取用户的权限信息并缓存。最后就是对用户的操作进行权限的判断了。</p>
<ol start="4">
<li>用户信息管理中心</li>
</ol>
<p>结合pulsar的常用操作，我们可以设计几张表保存用户信息和权限信息。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/29/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(1)/">认证和授权(1)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>本系列文章准备详细的说明pulsar的认证和授权流程，并结合市场上常见的主-主账号授权、主-子账号授权需求提供解决办法。</p>
<h3 id="2-整体结构"><a href="#2-整体结构" class="headerlink" title="2. 整体结构"></a>2. 整体结构</h3><p>首先我们需要对pulsar有一个整体的认识，pulsar本身是一个分布式部署的消息订阅分发中间件，它主要包含三个组件：</p>
<p>zookeeper：负责配置管理</p>
<p>broker：对外提供服务，接收发布订阅请求</p>
<p>bookkeeper：负责消息的持久化</p>
<p><img src="/../../images/image-20210611184242420.png" alt="image-20210611184242420"></p>
<h3 id="3-通信方式"><a href="#3-通信方式" class="headerlink" title="3. 通信方式"></a>3. 通信方式</h3><p>pulsar提供了两种服务，一种是http的，主要负责处理创建tenant、namespace、topic和获取集群状态等信息；另外一种是基于netty写的tcp服务，主要用于接收客户端发送的消息和订阅请求。</p>
<p>http服务都在org.apache.pulsar.broker.admin包下，可以看到对于cluster、broker、tenant、namespace等都提供了对应的api操作接口。</p>
<p>tcp服务的核心处理类是org.apache.pulsar.broker.service.ServerCnx。</p>
<p>消息格式为TLV格式的二进制数据，每条消息的前4个字节为消息的总长度。</p>
<p>看下具体的消息格式：</p>
<p><img src="/../../images/image-20231007104802008.png" alt="image-20231007104802008"></p>
<h3 id="4-认证处理逻辑"><a href="#4-认证处理逻辑" class="headerlink" title="4. 认证处理逻辑"></a>4. 认证处理逻辑</h3><p>客户端和broker之间是TCP长连接，在客户端连接到broker后，broker会对客户端的合法性进行验证，如果不合法则断开连接，判断流程是：</p>
<ol>
<li>判断是否开启了连接认证（conf&#x2F;broker.conf：authenticationEnabled）</li>
<li>如果没有开启认证，则返回连接成功</li>
<li>如果开启了认证，则获取认证内容、认证客户端选择的服务端认证策略</li>
<li>如果服务端不支持客户端提供的认证策略，则返回认证失败</li>
<li>如果支持，则调用策略的认证方法（AuthenticationProvider.authenticate）</li>
<li>如果认证过程没有抛出异常，则返回认证成功，并保存认证结果（这里的认证结果就是role，后续会根据role对客户端的其他操作进行授权管理）</li>
<li>认证过程完成。</li>
</ol>
<p>认证处理包含几个重要的接口</p>
<ul>
<li><p>服务端（broker）：</p>
<p>org.apache.pulsar.broker.authentication.AuthenticationProvider，核心方法如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ServiceConfiguration config)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 初始化时使用，在broker启动的时候初始化。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAuthMethodName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 范围认证策略的名称，需要和客户端发送的名称保持一致。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">authenticate</span><span class="params">(AuthenticationDataSource authData)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="comment">// 进行客户端认证，返回客户端的角色名称。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// broker关闭时调用此方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>客户端：</p>
<p>org.apache.pulsar.client.api.Authentication</p>
<p>org.apache.pulsar.client.api.AuthenticationDataProvider，核心方法如下：</p>
</li>
</ul>
<p><strong>Authentication</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAuthMethodName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 认证策略的名称。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AuthenticationDataProvider <span class="title function_">getAuthData</span><span class="params">()</span> <span class="keyword">throws</span> PulsarClientException &#123;</span><br><span class="line">   <span class="comment">// 返回认证数据持有对象，即另外一个核心接口的实现类。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, String&gt; authParams)</span> &#123;</span><br><span class="line">    <span class="comment">// 程序启动时调用，可以得到配置文件中的配置项。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> PulsarClientException &#123;</span><br><span class="line">    <span class="comment">// 程序启动时调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 程序停止时调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AuthenticationDataProvider</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasDataForHttp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// http区是否有数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; getHttpHeaders() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">// 获取http头信息，如果上述方法返回true，则这里要设置http header内容。然后broker端才能根据http header name获取到数据。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasDataFromCommand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 是否有命令数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getCommandData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果上述方法返回true，则这里要返回broker端需要的数据。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-授权处理逻辑"><a href="#5-授权处理逻辑" class="headerlink" title="5. 授权处理逻辑"></a>5. 授权处理逻辑</h3><p>授权需要在客户端连接认证的基础上进行，根据连接认证完成后生成的role对后续的操作进行权限管理。</p>
<p>授权管理包含两部分：</p>
<ul>
<li>使用pulsar-admin管理集群时的权限验证（http协议）</li>
<li>客户端连接到broker进行数据读写时的权限验证（tcp协议）</li>
</ul>
<p>上述两部分授权的处理逻辑其实没有区别，都是先通过连接认证获取获取客户端的role，然后根据role判断客户端是否有对应操作的权限。由于上边已经说了role的获取途径，下面重点写下pulsar对于客户端的哪些操作进行了权限的判断。</p>
<p><img src="/../../images/image-20231007105427754.png" alt="image-20231007105427754"></p>
<h3 id="6-自定义认证和授权"><a href="#6-自定义认证和授权" class="headerlink" title="6. 自定义认证和授权"></a>6. 自定义认证和授权</h3><p>自定义认证和授权只需要实现前两节中列出的接口即可。</p>
<h3 id="7-第三方认证和授权中心"><a href="#7-第三方认证和授权中心" class="headerlink" title="7. 第三方认证和授权中心"></a>7. 第三方认证和授权中心</h3><p>为了能更好的对客户端的权限进行管理，需要一个统一的第三方认证中心，记录tenant、namespace和topic的信息以及用户信息，并建立起用户和操作之间的权限关系。这样，在客户端连接到broker后，broker就可以根据客户端传递的用户信息对客户端操作进行权限验证。</p>
<h3 id="8-具体实现（不包含真正的权限验证部分，只是为了测试整体流程）"><a href="#8-具体实现（不包含真正的权限验证部分，只是为了测试整体流程）" class="headerlink" title="8. 具体实现（不包含真正的权限验证部分，只是为了测试整体流程）"></a>8. 具体实现（不包含真正的权限验证部分，只是为了测试整体流程）</h3><h4 id="8-1-实现broker端认证接口"><a href="#8-1-实现broker端认证接口" class="headerlink" title="8.1 实现broker端认证接口"></a>8.1 实现broker端认证接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> auth.server;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.broker.ServiceConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.broker.authentication.AuthenticationDataSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.broker.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.naming.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VVAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(VVAuthenticationProvider.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;vv_auth_v2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">seq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> <span class="string">&quot;vv_auth&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ServiceConfiguration config)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; initialize&quot;</span> + <span class="string">&quot;, seq=&quot;</span> + seq.incrementAndGet());</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; superRoles = config.getSuperUserRoles();</span><br><span class="line">        <span class="keyword">if</span> (superRoles == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String role : superRoles) &#123;</span><br><span class="line">            log.info(methodName + <span class="string">&quot; initialize &quot;</span> + role + <span class="string">&quot;, seq=&quot;</span> + seq.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthMethodName</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; getAuthMethodName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">authenticate</span><span class="params">(AuthenticationDataSource authData)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; authenticate&quot;</span> + <span class="string">&quot;, seq=&quot;</span> + seq.incrementAndGet());</span><br><span class="line">        <span class="type">String</span> <span class="variable">roleToken</span> <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (authData.hasDataFromCommand()) &#123;</span><br><span class="line">            roleToken = authData.getCommandData();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (authData.hasDataFromHttp()) &#123;</span><br><span class="line">            roleToken = authData.getHttpHeader(header);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;Authentication data source does not have a role token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; authenticate &quot;</span> + roleToken + <span class="string">&quot;, seq=&quot;</span> + seq.incrementAndGet());</span><br><span class="line">        <span class="keyword">return</span> roleToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; close&quot;</span> + <span class="string">&quot;, seq=&quot;</span> + seq.incrementAndGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-2-实现客户端认证接口"><a href="#8-2-实现客户端认证接口" class="headerlink" title="8.2 实现客户端认证接口"></a>8.2 实现客户端认证接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> auth.client;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.AuthenticationDataProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.PulsarClientException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 14:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VVAuthentication</span> <span class="keyword">implements</span> <span class="title class_">Authentication</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(VVAuthentication.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;vv_auth_v2&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthMethodName</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; getAuthMethodName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationDataProvider <span class="title function_">getAuthData</span><span class="params">()</span> <span class="keyword">throws</span> PulsarClientException &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; getAuthData&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VVAuthenticationDataProvider</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, String&gt; authParams)</span> &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; configure&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (authParams == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        authParams.forEach((key, value) -&gt; &#123;</span><br><span class="line">            log.info(methodName + <span class="string">&quot; configure &quot;</span> + key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> PulsarClientException &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> auth.client;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.AuthenticationDataProvider;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/27 14:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VVAuthenticationDataProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationDataProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(VVAuthenticationDataProvider.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;vv_auth_v2&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> <span class="string">&quot;vv_auth&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;vv-role&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasDataForHttp</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; hasDataForHttp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; getHttpHeaders() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; getHttpHeaders&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headers.put(header, token);</span><br><span class="line">        <span class="keyword">return</span> headers.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasDataFromCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; hasDataFromCommand&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCommandData</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(methodName + <span class="string">&quot; getCommandData&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-3-修改conf-broker-conf配置文件"><a href="#8-3-修改conf-broker-conf配置文件" class="headerlink" title="8.3 修改conf&#x2F;broker.conf配置文件"></a>8.3 修改conf&#x2F;broker.conf配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### --- Authentication --- ###</span><br><span class="line"># Enable authentication</span><br><span class="line"># 开启连接认证</span><br><span class="line">authenticationEnabled=true</span><br><span class="line"># Authentication provider name list, which is comma separated list of class names</span><br><span class="line"># 自定义的broker端实现的处理类</span><br><span class="line">authenticationProviders=auth.server.VVAuthenticationProvider</span><br><span class="line"># Interval of time for checking for expired authentication credentials</span><br><span class="line">authenticationRefreshCheckSeconds=60</span><br><span class="line"># Enforce authorization</span><br><span class="line"># 开启授权认证</span><br><span class="line">authorizationEnabled=true</span><br><span class="line"># Authorization provider fully qualified class-name</span><br><span class="line"># 自定义的授权认证处理类</span><br><span class="line">authorizationProvider=auth.server.VVPulsarAuthorizationProvider</span><br><span class="line"># Allow wildcard matching in authorization</span><br><span class="line"># (wildcard matching only applicable if wildcard-char:</span><br><span class="line"># * presents at first or last position eg: *.pulsar.service, pulsar.service.*)</span><br><span class="line">authorizationAllowWildcardsMatching=false</span><br><span class="line"># Role names that are treated as &quot;super-user&quot;, meaning they will be able to do all admin</span><br><span class="line"># operations and publish/consume from all topics</span><br><span class="line"># 超级用户，创建tenant的时候需要超级用户</span><br><span class="line">superUserRoles=vv-role,cc-role</span><br><span class="line"># Authentication settings of the broker itself. Used when the broker connects to other brokers,</span><br><span class="line"># either in same or other clusters</span><br><span class="line">brokerClientTlsEnabled=false</span><br><span class="line"># 自定义的客户端认证实现类</span><br><span class="line">brokerClientAuthenticationPlugin=auth.client2.client.VVAuthentication</span><br><span class="line">brokerClientAuthenticationParameters=</span><br><span class="line">brokerClientTrustCertsFilePath=</span><br></pre></td></tr></table></figure>

<h4 id="8-4-重启broker"><a href="#8-4-重启broker" class="headerlink" title="8.4 重启broker"></a>8.4 重启broker</h4><p>.&#x2F;bin&#x2F;pulsar-daemon stop broker</p>
<p>.&#x2F;bin&#x2F;pulsar-daemon start broker</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="8-5-验证是否有效"><a href="#8-5-验证是否有效" class="headerlink" title="8.5 验证是否有效"></a>8.5 验证是否有效</h5><p><strong>通过pulsar-admin命令进行验证</strong></p>
<p>首先配置conf&#x2F;client.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authPlugin=auth.client2.client.VVAuthenticationauthParams=</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>执行命令并验证结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行以下命令./bin/pulsar-admin tenants list# 客户端侧输出日志18:21:52.173 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 configure18:21:52.175 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 configure token=123456vv18:21:52.335 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 getAuthMethodName18:21:52.336 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 start18:21:52.611 [main] INFO  auth.client.VVAuthentication - vv_auth_v2 getAuthData18:21:52.612 [main] INFO  auth.client.VVAuthenticationDataProvider - vv_auth_v2 hasDataForHttp18:21:52.789 [main] INFO  auth.client.VVAuthenticationDataProvider - vv_auth_v2 hasDataForHttp18:21:52.789 [main] INFO  auth.client.VVAuthenticationDataProvider - vv_auth_v2 getHttpHeaders# 服务端（broker）侧输出日志18:23:53.957 [pulsar-web-41-11] INFO  auth.server.VVAuthenticationProvider - vv_auth_v2 authenticate, seq=329618:23:53.957 [pulsar-web-41-11] INFO  auth.server.VVAuthenticationProvider - vv_auth_v2 authenticate vv-role, seq=329718:23:53.958 [pulsar-web-41-11] INFO  org.eclipse.jetty.server.RequestLog - x.x.x.x - - [29/Jul/2021:18:23:53 +0800] &quot;GET /admin/v2/tenants HTTP/1.1&quot; 200 42 &quot;-&quot; &quot;Pulsar-Java-v2.8.0&quot; 1# 在pulsar-admin侧可以看到输出的tenant列表&quot;public&quot;&quot;pulsar&quot;&quot;tenant_c&quot;&quot;tenant_vv&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>通过java程序验证</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> auth;</span><br><span class="line"><span class="keyword">import</span> auth.client.VVAuthentication;</span><br><span class="line"><span class="keyword">import</span> org.apache.pulsar.client.api.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/19 10:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(AuthTest.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AuthTest</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthTest</span>();</span><br><span class="line">        main.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pulsarUrl</span> <span class="operator">=</span> <span class="string">&quot;pulsar://x.x.x.x:6650&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;persistent://tenant_vv/ns1/auth_test&quot;</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VVAuthentication</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PulsarClient</span> <span class="variable">client</span> <span class="operator">=</span> PulsarClient.builder()</span><br><span class="line">                .authentication(authentication)</span><br><span class="line">                .serviceUrl(pulsarUrl)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//        send(client);</span></span><br><span class="line"><span class="comment">//        testReader(client);</span></span><br><span class="line">        consume(client);</span><br><span class="line">        System.out.println(<span class="string">&quot;connect successed &quot;</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> client.newConsumer()</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .subscriptionName(<span class="string">&quot;consumer-test&quot;</span>)</span><br><span class="line">                .subscribe();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> consumer.receive();</span><br><span class="line">            <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;recv &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(m.getData()));</span><br><span class="line">                consumer.acknowledge(m);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> client.newProducer()</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .create();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            p.newMessage().key(<span class="string">&quot;aaa&quot;</span>).value((<span class="string">&quot;hello &quot;</span> + i).getBytes()).send();</span><br><span class="line">            log.info(<span class="string">&quot;send &quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p.flush();</span><br><span class="line">        p.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;send done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testReader</span><span class="params">(PulsarClient client)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> client.newReader()</span><br><span class="line">                .subscriptionName(<span class="string">&quot;reader-test&quot;</span>)</span><br><span class="line">                .topic(topic)</span><br><span class="line">                .startMessageId(MessageId.earliest)</span><br><span class="line"><span class="comment">//                .startMessageId(DefaultImplementation.newMessageId(121493, -1, -1))</span></span><br><span class="line">                .create();</span><br><span class="line">        <span class="keyword">while</span> (reader.hasMessageAvailable()) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> reader.readNext();</span><br><span class="line">            log.info(<span class="string">&quot;reader recv msg, id=&quot;</span> + msg.getMessageId() + <span class="string">&quot; key=&quot;</span> + msg.getKey() + <span class="string">&quot;, value=&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getData()));</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/28/pulsar/pulsar%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83(0)/">认证和授权(0)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/pulsar/">pulsar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/pulsar/">pulsar</a></span><div class="content"><h3 id="pulsar认证说明"><a href="#pulsar认证说明" class="headerlink" title="pulsar认证说明"></a>pulsar认证说明</h3><p>pulsar支持TLS、Athenz、Kerberos、JSON Web Token等认证，也支持自定义认证。</p>
<p>pulsar基于Netty进行数据的通信，通信内容的格式是TLV。服务端处理数据的类是org.apache.pulsar.broker.service.ServerCnx，客户端处理数据的类是org.apache.pulsar.client.impl.ClientCnx，这两个类都继承PulsarDecoder，在PulsarDecoder中区分各种type，然后根据type调用各种业务处理，在CONNECT中处理认证。</p>
<p>可以看下pulsar中的消息类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> PARTITIONED_METADATA</span><br><span class="line"><span class="keyword">case</span> PARTITIONED_METADATA_RESPONSE</span><br><span class="line"><span class="keyword">case</span> LOOKUP</span><br><span class="line"><span class="keyword">case</span> LOOKUP_RESPONSE</span><br><span class="line"><span class="keyword">case</span> ACK</span><br><span class="line"><span class="keyword">case</span> ACK_RESPONSE</span><br><span class="line"><span class="keyword">case</span> CLOSE_CONSUMER</span><br><span class="line"><span class="keyword">case</span> CLOSE_PRODUCER</span><br><span class="line"><span class="keyword">case</span> CONNECT</span><br><span class="line"><span class="keyword">case</span> CONNECTED</span><br><span class="line"><span class="keyword">case</span> ERROR</span><br><span class="line"><span class="keyword">case</span> FLOW</span><br><span class="line"><span class="keyword">case</span> MESSAGE</span><br><span class="line"><span class="keyword">case</span> PRODUCER</span><br><span class="line"><span class="keyword">case</span> SEND</span><br><span class="line"><span class="keyword">case</span> SEND_ERROR</span><br><span class="line"><span class="keyword">case</span> SEND_RECEIPT</span><br><span class="line"><span class="keyword">case</span> SUBSCRIBE</span><br><span class="line"><span class="keyword">case</span> SUCCESS</span><br><span class="line"><span class="keyword">case</span> PRODUCER_SUCCESS</span><br><span class="line"><span class="keyword">case</span> UNSUBSCRIBE</span><br><span class="line"><span class="keyword">case</span> SEEK</span><br><span class="line"><span class="keyword">case</span> PING</span><br><span class="line"><span class="keyword">case</span> PONG</span><br><span class="line"><span class="keyword">case</span> REDELIVER_UNACKNOWLEDGED_MESSAGES</span><br><span class="line"><span class="keyword">case</span> CONSUMER_STATS</span><br><span class="line"><span class="keyword">case</span> CONSUMER_STATS_RESPONSE</span><br><span class="line"><span class="keyword">case</span> REACHED_END_OF_TOPIC</span><br><span class="line"><span class="keyword">case</span> GET_LAST_MESSAGE_ID</span><br><span class="line"><span class="keyword">case</span> GET_LAST_MESSAGE_ID_RESPONSE</span><br><span class="line"><span class="keyword">case</span> ACTIVE_CONSUMER_CHANGE</span><br><span class="line"><span class="keyword">case</span> GET_TOPICS_OF_NAMESPACE</span><br><span class="line"><span class="keyword">case</span> GET_TOPICS_OF_NAMESPACE_RESPONSE</span><br><span class="line"><span class="keyword">case</span> GET_SCHEMA</span><br><span class="line"><span class="keyword">case</span> GET_SCHEMA_RESPONSE</span><br><span class="line"><span class="keyword">case</span> GET_OR_CREATE_SCHEMA</span><br><span class="line"><span class="keyword">case</span> GET_OR_CREATE_SCHEMA_RESPONSE</span><br><span class="line"><span class="keyword">case</span> AUTH_CHALLENGE</span><br><span class="line"><span class="keyword">case</span> AUTH_RESPONSE</span><br><span class="line"><span class="keyword">case</span> NEW_TXN</span><br><span class="line"><span class="keyword">case</span> NEW_TXN_RESPONSE</span><br><span class="line"><span class="keyword">case</span> ADD_PARTITION_TO_TXN</span><br><span class="line"><span class="keyword">case</span> ADD_PARTITION_TO_TXN_RESPONSE</span><br><span class="line"><span class="keyword">case</span> ADD_SUBSCRIPTION_TO_TXN</span><br><span class="line"><span class="keyword">case</span> ADD_SUBSCRIPTION_TO_TXN_RESPONSE</span><br><span class="line"><span class="keyword">case</span> END_TXN</span><br><span class="line"><span class="keyword">case</span> END_TXN_RESPONSE</span><br><span class="line"><span class="keyword">case</span> END_TXN_ON_PARTITION</span><br><span class="line"><span class="keyword">case</span> END_TXN_ON_PARTITION_RESPONSE</span><br><span class="line"><span class="keyword">case</span> END_TXN_ON_SUBSCRIPTION</span><br><span class="line"><span class="keyword">case</span> END_TXN_ON_SUBSCRIPTION_RESPONSE</span><br></pre></td></tr></table></figure>



<h3 id="pulsar认证实现步骤"><a href="#pulsar认证实现步骤" class="headerlink" title="pulsar认证实现步骤"></a>pulsar认证实现步骤</h3><p>pulsar的认证很简单，下面两个步骤就可以完成。</p>
<ol>
<li>分别实现org.apache.pulsar.client.api.Authentication和org.apache.pulsar.broker.authentication.AuthenticationProvider接口，第一个用户客户端侧认证，第二个用户服务端侧认证。</li>
<li>修改conf&#x2F;broker.conf文件，开启认证功能。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable authentication</span><br><span class="line">authenticationEnabled=true</span><br><span class="line"># Authentication provider name list, which is comma separated list of class names</span><br><span class="line">authenticationProviders=auth.server.VVAuthenticationProvider</span><br><span class="line"># Interval of time for checking for expired authentication credentials</span><br><span class="line">authenticationRefreshCheckSeconds=60</span><br><span class="line"># Role names that are treated as &quot;super-user&quot;, meaning they will be able to do all admin</span><br><span class="line"># operations and publish/consume from all topics</span><br><span class="line">superUserRoles=vv-role,cc-role</span><br><span class="line"># Authentication settings of the broker itself. Used when the broker connects to other brokers,</span><br><span class="line"># either in same or other clusters</span><br><span class="line">brokerClientTlsEnabled=false</span><br><span class="line">brokerClientAuthenticationPlugin=auth.client2.client.VVAuthentication</span><br><span class="line">brokerClientAuthenticationParameters=</span><br><span class="line">brokerClientTrustCertsFilePath=</span><br></pre></td></tr></table></figure>



<p>需要注意的是，broker和client之间有认证，broker和broker之间也有认证，所以在自己实现的认证接口中需要区分角色，以免造成数据处理问题。</p>
<h3 id="pulsar授权说明"><a href="#pulsar授权说明" class="headerlink" title="pulsar授权说明"></a>pulsar授权说明</h3><p>pulsar认证和授权是分开的，认证部分用于验证客户端是否合法，授权部分则是细分了各个客户端的权限，包含tenant、namespace、topic操作权限等。授权部分和认证部分虽然是分开的，但是授权是基于角色进行的，而角色是由认证部分生成的，所以要开启授权的前提是先开启认证。</p>
<h3 id="pulsar授权实现步骤"><a href="#pulsar授权实现步骤" class="headerlink" title="pulsar授权实现步骤"></a>pulsar授权实现步骤</h3><ol>
<li>实现org.apache.pulsar.broker.authorization.AuthorizationProvider接口</li>
<li>修改conf&#x2F;broker.conf文件，开启授权功能。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enforce authorization</span><br><span class="line">authorizationEnabled=true</span><br><span class="line"># Authorization provider fully qualified class-name</span><br><span class="line">authorizationProvider=auth.server.VVPulsarAuthorizationProvider</span><br><span class="line"></span><br><span class="line"># Allow wildcard matching in authorization</span><br><span class="line"># (wildcard matching only applicable if wildcard-char:</span><br><span class="line"># * presents at first or last position eg: *.pulsar.service, pulsar.service.*)</span><br><span class="line">authorizationAllowWildcardsMatching=false</span><br><span class="line"></span><br><span class="line"># Role names that are treated as &quot;super-user&quot;, meaning they will be able to do all admin</span><br><span class="line"># operations and publish/consume from all topics</span><br><span class="line">superUserRoles=vv-role,cc-role</span><br></pre></td></tr></table></figure></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2024 By iMine</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>